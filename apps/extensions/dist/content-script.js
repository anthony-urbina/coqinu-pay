(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":1,"buffer":2,"ieee754":3}],3:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],4:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],5:[function(require,module,exports){
(function (process,global,Buffer){(function (){
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@metamask/json-rpc-engine/dist/JsonRpcEngine.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/dist/JsonRpcEngine.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _JsonRpcEngine_instances, _a, _JsonRpcEngine_isDestroyed, _JsonRpcEngine_middleware, _JsonRpcEngine_notificationHandler, _JsonRpcEngine_assertIsNotDestroyed, _JsonRpcEngine_handleBatch, _JsonRpcEngine_handle, _JsonRpcEngine_processRequest, _JsonRpcEngine_runAllMiddleware, _JsonRpcEngine_runMiddleware, _JsonRpcEngine_runReturnHandlers, _JsonRpcEngine_checkForCompletion;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpcEngine = void 0;
const rpc_errors_1 = __webpack_require__(/*! @metamask/rpc-errors */ "./node_modules/@metamask/rpc-errors/dist/index.js");
const safe_event_emitter_1 = __importDefault(__webpack_require__(/*! @metamask/safe-event-emitter */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/safe-event-emitter/index.js"));
const utils_1 = __webpack_require__(/*! @metamask/utils */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/index.js");
const DESTROYED_ERROR_MESSAGE = 'This engine is destroyed and can no longer be used.';
/**
 * A JSON-RPC request and response processor.
 * Give it a stack of middleware, pass it requests, and get back responses.
 */
class JsonRpcEngine extends safe_event_emitter_1.default {
    /**
     * Constructs a {@link JsonRpcEngine} instance.
     *
     * @param options - Options bag.
     * @param options.notificationHandler - A function for handling JSON-RPC
     * notifications. A JSON-RPC notification is defined as a JSON-RPC request
     * without an `id` property. If this option is _not_ provided, notifications
     * will be treated the same as requests. If this option _is_ provided,
     * notifications will be passed to the handler function without touching
     * the engine's middleware stack. This function should not throw or reject.
     */
    constructor({ notificationHandler } = {}) {
        super();
        _JsonRpcEngine_instances.add(this);
        /**
         * Indicating whether this engine is destroyed or not.
         */
        _JsonRpcEngine_isDestroyed.set(this, false);
        _JsonRpcEngine_middleware.set(this, void 0);
        _JsonRpcEngine_notificationHandler.set(this, void 0);
        __classPrivateFieldSet(this, _JsonRpcEngine_middleware, [], "f");
        __classPrivateFieldSet(this, _JsonRpcEngine_notificationHandler, notificationHandler, "f");
    }
    /**
     * Calls the `destroy()` function of any middleware with that property, clears
     * the middleware array, and marks this engine as destroyed. A destroyed
     * engine cannot be used.
     */
    destroy() {
        __classPrivateFieldGet(this, _JsonRpcEngine_middleware, "f").forEach((middleware) => {
            if (
            // `in` walks the prototype chain, which is probably the desired
            // behavior here.
            'destroy' in middleware &&
                typeof middleware.destroy === 'function') {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                middleware.destroy();
            }
        });
        __classPrivateFieldSet(this, _JsonRpcEngine_middleware, [], "f");
        __classPrivateFieldSet(this, _JsonRpcEngine_isDestroyed, true, "f");
    }
    /**
     * Add a middleware function to the engine's middleware stack.
     *
     * @param middleware - The middleware function to add.
     */
    push(middleware) {
        __classPrivateFieldGet(this, _JsonRpcEngine_instances, "m", _JsonRpcEngine_assertIsNotDestroyed).call(this);
        __classPrivateFieldGet(this, _JsonRpcEngine_middleware, "f").push(middleware);
    }
    // TODO: Replace `any` with type
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    handle(req, callback) {
        __classPrivateFieldGet(this, _JsonRpcEngine_instances, "m", _JsonRpcEngine_assertIsNotDestroyed).call(this);
        if (callback && typeof callback !== 'function') {
            throw new Error('"callback" must be a function if provided.');
        }
        if (Array.isArray(req)) {
            if (callback) {
                return __classPrivateFieldGet(this, _JsonRpcEngine_instances, "m", _JsonRpcEngine_handleBatch).call(this, req, callback);
            }
            return __classPrivateFieldGet(this, _JsonRpcEngine_instances, "m", _JsonRpcEngine_handleBatch).call(this, req);
        }
        if (callback) {
            return __classPrivateFieldGet(this, _JsonRpcEngine_instances, "m", _JsonRpcEngine_handle).call(this, req, callback);
        }
        return this._promiseHandle(req);
    }
    /**
     * Returns this engine as a middleware function that can be pushed to other
     * engines.
     *
     * @returns This engine as a middleware function.
     */
    asMiddleware() {
        __classPrivateFieldGet(this, _JsonRpcEngine_instances, "m", _JsonRpcEngine_assertIsNotDestroyed).call(this);
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        return (req, res, next, end) => __awaiter(this, void 0, void 0, function* () {
            try {
                const [middlewareError, isComplete, returnHandlers] = yield __classPrivateFieldGet(JsonRpcEngine, _a, "m", _JsonRpcEngine_runAllMiddleware).call(JsonRpcEngine, req, res, __classPrivateFieldGet(this, _JsonRpcEngine_middleware, "f"));
                if (isComplete) {
                    yield __classPrivateFieldGet(JsonRpcEngine, _a, "m", _JsonRpcEngine_runReturnHandlers).call(JsonRpcEngine, returnHandlers);
                    return end(middlewareError);
                }
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                return next((handlerCallback) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield __classPrivateFieldGet(JsonRpcEngine, _a, "m", _JsonRpcEngine_runReturnHandlers).call(JsonRpcEngine, returnHandlers);
                        // TODO: Replace `any` with type
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    }
                    catch (error) {
                        return handlerCallback(error);
                    }
                    return handlerCallback();
                }));
                // TODO: Replace `any` with type
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (error) {
                return end(error);
            }
        });
    }
    /**
     * A promise-wrapped _handle.
     *
     * @param request - The JSON-RPC request.
     * @returns The JSON-RPC response.
     */
    // This function is used in tests, so we cannot easily change it to use the
    // hash syntax.
    // eslint-disable-next-line no-restricted-syntax
    _promiseHandle(request) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                __classPrivateFieldGet(this, _JsonRpcEngine_instances, "m", _JsonRpcEngine_handle).call(this, request, (error, res) => {
                    // For notifications, the response will be `undefined`, and any caught
                    // errors are unexpected and should be surfaced to the caller.
                    if (error && res === undefined) {
                        reject(error);
                    }
                    else {
                        // Excepting notifications, there will always be a response, and it will
                        // always have any error that is caught and propagated.
                        resolve(res);
                    }
                }).catch(reject);
            });
        });
    }
}
exports.JsonRpcEngine = JsonRpcEngine;
_a = JsonRpcEngine, _JsonRpcEngine_isDestroyed = new WeakMap(), _JsonRpcEngine_middleware = new WeakMap(), _JsonRpcEngine_notificationHandler = new WeakMap(), _JsonRpcEngine_instances = new WeakSet(), _JsonRpcEngine_assertIsNotDestroyed = function _JsonRpcEngine_assertIsNotDestroyed() {
    if (__classPrivateFieldGet(this, _JsonRpcEngine_isDestroyed, "f")) {
        throw new Error(DESTROYED_ERROR_MESSAGE);
    }
}, _JsonRpcEngine_handleBatch = function _JsonRpcEngine_handleBatch(requests, callback) {
    return __awaiter(this, void 0, void 0, function* () {
        // The order here is important
        try {
            // If the batch is an empty array, the response array must contain a single object
            if (requests.length === 0) {
                const response = [
                    {
                        id: null,
                        jsonrpc: '2.0',
                        error: new rpc_errors_1.JsonRpcError(rpc_errors_1.errorCodes.rpc.invalidRequest, 'Request batch must contain plain objects. Received an empty array'),
                    },
                ];
                if (callback) {
                    return callback(null, response);
                }
                return response;
            }
            // 2. Wait for all requests to finish, or throw on some kind of fatal
            // error
            const responses = (yield Promise.all(
            // 1. Begin executing each request in the order received
            requests.map(this._promiseHandle.bind(this)))).filter(
            // Filter out any notification responses.
            (response) => response !== undefined);
            // 3. Return batch response
            if (callback) {
                return callback(null, responses);
            }
            return responses;
        }
        catch (error) {
            if (callback) {
                return callback(error);
            }
            throw error;
        }
    });
}, _JsonRpcEngine_handle = function _JsonRpcEngine_handle(callerReq, callback) {
    var _b;
    return __awaiter(this, void 0, void 0, function* () {
        if (!callerReq ||
            Array.isArray(callerReq) ||
            typeof callerReq !== 'object') {
            const error = new rpc_errors_1.JsonRpcError(rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
            return callback(error, { id: null, jsonrpc: '2.0', error });
        }
        if (typeof callerReq.method !== 'string') {
            const error = new rpc_errors_1.JsonRpcError(rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
            if (__classPrivateFieldGet(this, _JsonRpcEngine_notificationHandler, "f") && !(0, utils_1.isJsonRpcRequest)(callerReq)) {
                // Do not reply to notifications, even if they are malformed.
                return callback(null);
            }
            return callback(error, {
                // Typecast: This could be a notification, but we want to access the
                // `id` even if it doesn't exist.
                id: (_b = callerReq.id) !== null && _b !== void 0 ? _b : null,
                jsonrpc: '2.0',
                error,
            });
        }
        // Handle notifications.
        // We can't use isJsonRpcNotification here because that narrows callerReq to
        // "never" after the if clause for unknown reasons.
        if (__classPrivateFieldGet(this, _JsonRpcEngine_notificationHandler, "f") && !(0, utils_1.isJsonRpcRequest)(callerReq)) {
            try {
                yield __classPrivateFieldGet(this, _JsonRpcEngine_notificationHandler, "f").call(this, callerReq);
            }
            catch (error) {
                return callback(error);
            }
            return callback(null);
        }
        let error = null;
        // Handle requests.
        // Typecast: Permit missing id's for backwards compatibility.
        const req = Object.assign({}, callerReq);
        const res = {
            id: req.id,
            jsonrpc: req.jsonrpc,
        };
        try {
            yield __classPrivateFieldGet(JsonRpcEngine, _a, "m", _JsonRpcEngine_processRequest).call(JsonRpcEngine, req, res, __classPrivateFieldGet(this, _JsonRpcEngine_middleware, "f"));
            // TODO: Replace `any` with type
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (_error) {
            // A request handler error, a re-thrown middleware error, or something
            // unexpected.
            error = _error;
        }
        if (error) {
            // Ensure no result is present on an errored response
            delete res.result;
            if (!res.error) {
                res.error = (0, rpc_errors_1.serializeError)(error);
            }
        }
        return callback(error, res);
    });
}, _JsonRpcEngine_processRequest = function _JsonRpcEngine_processRequest(req, res, middlewares) {
    return __awaiter(this, void 0, void 0, function* () {
        const [error, isComplete, returnHandlers] = yield __classPrivateFieldGet(JsonRpcEngine, _a, "m", _JsonRpcEngine_runAllMiddleware).call(JsonRpcEngine, req, res, middlewares);
        // Throw if "end" was not called, or if the response has neither a result
        // nor an error.
        __classPrivateFieldGet(JsonRpcEngine, _a, "m", _JsonRpcEngine_checkForCompletion).call(JsonRpcEngine, req, res, isComplete);
        // The return handlers should run even if an error was encountered during
        // middleware processing.
        yield __classPrivateFieldGet(JsonRpcEngine, _a, "m", _JsonRpcEngine_runReturnHandlers).call(JsonRpcEngine, returnHandlers);
        // Now we re-throw the middleware processing error, if any, to catch it
        // further up the call chain.
        if (error) {
            // eslint-disable-next-line @typescript-eslint/no-throw-literal
            throw error;
        }
    });
}, _JsonRpcEngine_runAllMiddleware = function _JsonRpcEngine_runAllMiddleware(req, res, middlewares) {
    return __awaiter(this, void 0, void 0, function* () {
        const returnHandlers = [];
        let error = null;
        let isComplete = false;
        // Go down stack of middleware, call and collect optional returnHandlers
        for (const middleware of middlewares) {
            [error, isComplete] = yield __classPrivateFieldGet(JsonRpcEngine, _a, "m", _JsonRpcEngine_runMiddleware).call(JsonRpcEngine, req, res, middleware, returnHandlers);
            if (isComplete) {
                break;
            }
        }
        return [error, isComplete, returnHandlers.reverse()];
    });
}, _JsonRpcEngine_runMiddleware = function _JsonRpcEngine_runMiddleware(request, response, middleware, returnHandlers) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            const end = (error) => {
                const parsedError = error || response.error;
                if (parsedError) {
                    response.error = (0, rpc_errors_1.serializeError)(parsedError);
                }
                // True indicates that the request should end
                resolve([parsedError, true]);
            };
            const next = (returnHandler) => {
                if (response.error) {
                    end(response.error);
                }
                else {
                    if (returnHandler) {
                        if (typeof returnHandler !== 'function') {
                            end(new rpc_errors_1.JsonRpcError(rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. ` +
                                `Received "${typeof returnHandler}" for request:\n${jsonify(request)}`, { request: request }));
                        }
                        returnHandlers.push(returnHandler);
                    }
                    // False indicates that the request should not end
                    resolve([null, false]);
                }
            };
            try {
                middleware(request, response, next, end);
                // TODO: Replace `any` with type
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (error) {
                end(error);
            }
        });
    });
}, _JsonRpcEngine_runReturnHandlers = function _JsonRpcEngine_runReturnHandlers(handlers) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const handler of handlers) {
            yield new Promise((resolve, reject) => {
                handler((error) => (error ? reject(error) : resolve()));
            });
        }
    });
}, _JsonRpcEngine_checkForCompletion = function _JsonRpcEngine_checkForCompletion(request, response, isComplete) {
    if (!(0, utils_1.hasProperty)(response, 'result') && !(0, utils_1.hasProperty)(response, 'error')) {
        throw new rpc_errors_1.JsonRpcError(rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:\n${jsonify(request)}`, { request: request });
    }
    if (!isComplete) {
        throw new rpc_errors_1.JsonRpcError(rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:\n${jsonify(request)}`, { request: request });
    }
};
/**
 * JSON-stringifies a request object.
 *
 * @param request - The request object to JSON-stringify.
 * @returns The JSON-stringified request object.
 */
function jsonify(request) {
    return JSON.stringify(request, null, 2);
}


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/dist/createAsyncMiddleware.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/dist/createAsyncMiddleware.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createAsyncMiddleware = void 0;
/**
 * JsonRpcEngine only accepts callback-based middleware directly.
 * createAsyncMiddleware exists to enable consumers to pass in async middleware
 * functions.
 *
 * Async middleware have no "end" function. Instead, they "end" if they return
 * without calling "next". Rather than passing in explicit return handlers,
 * async middleware can simply await "next", and perform operations on the
 * response object when execution resumes.
 *
 * To accomplish this, createAsyncMiddleware passes the async middleware a
 * wrapped "next" function. That function calls the internal JsonRpcEngine
 * "next" function with a return handler that resolves a promise when called.
 *
 * The return handler will always be called. Its resolution of the promise
 * enables the control flow described above.
 *
 * @param asyncMiddleware - The asynchronous middleware function to wrap.
 * @returns The wrapped asynchronous middleware function, ready to be consumed
 * by JsonRpcEngine.
 */
function createAsyncMiddleware(asyncMiddleware) {
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    return (request, response, next, end) => __awaiter(this, void 0, void 0, function* () {
        // nextPromise is the key to the implementation
        // it is resolved by the return handler passed to the
        // "next" function
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
            resolveNextPromise = resolve;
        });
        let returnHandlerCallback = null;
        let nextWasCalled = false;
        // This will be called by the consumer's async middleware.
        const asyncNext = () => __awaiter(this, void 0, void 0, function* () {
            nextWasCalled = true;
            // We pass a return handler to next(). When it is called by the engine,
            // the consumer's async middleware will resume executing.
            next((runReturnHandlersCallback) => {
                // This callback comes from JsonRpcEngine._runReturnHandlers
                returnHandlerCallback = runReturnHandlersCallback;
                resolveNextPromise();
            });
            return nextPromise;
        });
        try {
            yield asyncMiddleware(request, response, asyncNext);
            if (nextWasCalled) {
                yield nextPromise; // we must wait until the return handler is called
                returnHandlerCallback(null);
            }
            else {
                end(null);
            }
            // TODO: Replace `any` with type
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            if (returnHandlerCallback) {
                returnHandlerCallback(error);
            }
            else {
                end(error);
            }
        }
    });
}
exports.createAsyncMiddleware = createAsyncMiddleware;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/dist/createScaffoldMiddleware.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/dist/createScaffoldMiddleware.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createScaffoldMiddleware = void 0;
/**
 * Creates a middleware function from an object of RPC method handler functions,
 * keyed to particular method names. If a method corresponding to a key of this
 * object is requested, this middleware will pass it to the corresponding
 * handler and return the result.
 *
 * @param handlers - The RPC method handler functions.
 * @returns The scaffold middleware function.
 */
function createScaffoldMiddleware(handlers) {
    return (req, res, next, end) => {
        const handler = handlers[req.method];
        // if no handler, return
        if (handler === undefined) {
            return next();
        }
        // if handler is fn, call as middleware
        if (typeof handler === 'function') {
            return handler(req, res, next, end);
        }
        // if handler is some other value, use as result
        res.result = handler;
        return end();
    };
}
exports.createScaffoldMiddleware = createScaffoldMiddleware;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/dist/getUniqueId.js":
/*!********************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/dist/getUniqueId.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUniqueId = void 0;
// uint32 (two's complement) max
// more conservative than Number.MAX_SAFE_INTEGER
const MAX = 4294967295;
let idCounter = Math.floor(Math.random() * MAX);
/**
 * Gets an ID that is guaranteed to be unique so long as no more than
 * 4_294_967_295 (uint32 max) IDs are created, or the IDs are rapidly turned
 * over.
 *
 * @returns The unique ID.
 */
function getUniqueId() {
    idCounter = (idCounter + 1) % MAX;
    return idCounter;
}
exports.getUniqueId = getUniqueId;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/dist/idRemapMiddleware.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/dist/idRemapMiddleware.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createIdRemapMiddleware = void 0;
const getUniqueId_1 = __webpack_require__(/*! ./getUniqueId */ "./node_modules/@metamask/json-rpc-engine/dist/getUniqueId.js");
/**
 * Returns a middleware function that overwrites the `id` property of each
 * request with an ID that is guaranteed to be unique, and restores the original
 * ID in a return handler.
 *
 * If used, should be the first middleware in the stack.
 *
 * @returns The ID remap middleware function.
 */
function createIdRemapMiddleware() {
    return (request, response, next, _end) => {
        const originalId = request.id;
        const newId = (0, getUniqueId_1.getUniqueId)();
        request.id = newId;
        response.id = newId;
        next((done) => {
            request.id = originalId;
            response.id = originalId;
            done();
        });
    };
}
exports.createIdRemapMiddleware = createIdRemapMiddleware;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/dist/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./createAsyncMiddleware */ "./node_modules/@metamask/json-rpc-engine/dist/createAsyncMiddleware.js"), exports);
__exportStar(__webpack_require__(/*! ./createScaffoldMiddleware */ "./node_modules/@metamask/json-rpc-engine/dist/createScaffoldMiddleware.js"), exports);
__exportStar(__webpack_require__(/*! ./getUniqueId */ "./node_modules/@metamask/json-rpc-engine/dist/getUniqueId.js"), exports);
__exportStar(__webpack_require__(/*! ./idRemapMiddleware */ "./node_modules/@metamask/json-rpc-engine/dist/idRemapMiddleware.js"), exports);
__exportStar(__webpack_require__(/*! ./JsonRpcEngine */ "./node_modules/@metamask/json-rpc-engine/dist/JsonRpcEngine.js"), exports);
__exportStar(__webpack_require__(/*! ./mergeMiddleware */ "./node_modules/@metamask/json-rpc-engine/dist/mergeMiddleware.js"), exports);


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/dist/mergeMiddleware.js":
/*!************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/dist/mergeMiddleware.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeMiddleware = void 0;
const JsonRpcEngine_1 = __webpack_require__(/*! ./JsonRpcEngine */ "./node_modules/@metamask/json-rpc-engine/dist/JsonRpcEngine.js");
/**
 * Takes a stack of middleware and joins them into a single middleware function.
 *
 * @param middlewareStack - The middleware stack to merge.
 * @returns The merged middleware function.
 */
function mergeMiddleware(middlewareStack) {
    const engine = new JsonRpcEngine_1.JsonRpcEngine();
    middlewareStack.forEach((middleware) => engine.push(middleware));
    return engine.asMiddleware();
}
exports.mergeMiddleware = mergeMiddleware;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/safe-event-emitter/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/safe-event-emitter/index.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
function safeApply(handler, context, args) {
    try {
        Reflect.apply(handler, context, args);
    }
    catch (err) {
        // Throw error after timeout so as not to interrupt the stack
        setTimeout(() => {
            throw err;
        });
    }
}
function arrayClone(arr) {
    const n = arr.length;
    const copy = new Array(n);
    for (let i = 0; i < n; i += 1) {
        copy[i] = arr[i];
    }
    return copy;
}
class SafeEventEmitter extends events_1.EventEmitter {
    emit(type, ...args) {
        let doError = type === 'error';
        const events = this._events;
        if (events !== undefined) {
            doError = doError && events.error === undefined;
        }
        else if (!doError) {
            return false;
        }
        // If there is no 'error' event listener then throw.
        if (doError) {
            let er;
            if (args.length > 0) {
                [er] = args;
            }
            if (er instanceof Error) {
                // Note: The comments on the `throw` lines are intentional, they show
                // up in Node's output if this results in an unhandled exception.
                throw er; // Unhandled 'error' event
            }
            // At least give some kind of context to the user
            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);
            err.context = er;
            throw err; // Unhandled 'error' event
        }
        const handler = events[type];
        if (handler === undefined) {
            return false;
        }
        if (typeof handler === 'function') {
            safeApply(handler, this, args);
        }
        else {
            const len = handler.length;
            const listeners = arrayClone(handler);
            for (let i = 0; i < len; i += 1) {
                safeApply(listeners[i], this, args);
            }
        }
        return true;
    }
}
exports["default"] = SafeEventEmitter;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/logging.ts
var _debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"); var _debug2 = _interopRequireDefault(_debug);
var globalLogger = _debug2.default.call(void 0, "metamask");
function createProjectLogger(projectName) {
  return globalLogger.extend(projectName);
}
function createModuleLogger(projectLogger, moduleName) {
  return projectLogger.extend(moduleName);
}




exports.createProjectLogger = createProjectLogger; exports.createModuleLogger = createModuleLogger;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};





exports.__privateGet = __privateGet; exports.__privateAdd = __privateAdd; exports.__privateSet = __privateSet;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/versions.ts






var _semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var VersionStruct = _superstruct.refine.call(void 0, 
  _superstruct.string.call(void 0, ),
  "Version",
  (value) => {
    if (_semver.valid.call(void 0, value) === null) {
      return `Expected SemVer version, got "${value}"`;
    }
    return true;
  }
);
var VersionRangeStruct = _superstruct.refine.call(void 0, 
  _superstruct.string.call(void 0, ),
  "Version range",
  (value) => {
    if (_semver.validRange.call(void 0, value) === null) {
      return `Expected SemVer range, got "${value}"`;
    }
    return true;
  }
);
function isValidSemVerVersion(version) {
  return _superstruct.is.call(void 0, version, VersionStruct);
}
function isValidSemVerRange(versionRange) {
  return _superstruct.is.call(void 0, versionRange, VersionRangeStruct);
}
function assertIsSemVerVersion(version) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, version, VersionStruct);
}
function assertIsSemVerRange(range) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, range, VersionRangeStruct);
}
function gtVersion(version1, version2) {
  return _semver.gt.call(void 0, version1, version2);
}
function gtRange(version, range) {
  return _semver.gtr.call(void 0, version, range);
}
function satisfiesVersionRange(version, versionRange) {
  return _semver.satisfies.call(void 0, version, versionRange, {
    includePrerelease: true
  });
}











exports.VersionStruct = VersionStruct; exports.VersionRangeStruct = VersionRangeStruct; exports.isValidSemVerVersion = isValidSemVerVersion; exports.isValidSemVerRange = isValidSemVerRange; exports.assertIsSemVerVersion = assertIsSemVerVersion; exports.assertIsSemVerRange = assertIsSemVerRange; exports.gtVersion = gtVersion; exports.gtRange = gtRange; exports.satisfiesVersionRange = satisfiesVersionRange;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-4NIRTM4M.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-4NIRTM4M.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));// src/promise.ts
function createDeferredPromise({
  suppressUnhandledRejection = false
} = {}) {
  let resolve;
  let reject;
  const promise = new Promise(
    (innerResolve, innerReject) => {
      resolve = innerResolve;
      reject = innerReject;
    }
  );
  if (suppressUnhandledRejection) {
    promise.catch((_error) => {
    });
  }
  return { promise, resolve, reject };
}



exports.createDeferredPromise = createDeferredPromise;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));// src/time.ts
var Duration = /* @__PURE__ */ ((Duration2) => {
  Duration2[Duration2["Millisecond"] = 1] = "Millisecond";
  Duration2[Duration2["Second"] = 1e3] = "Second";
  Duration2[Duration2["Minute"] = 6e4] = "Minute";
  Duration2[Duration2["Hour"] = 36e5] = "Hour";
  Duration2[Duration2["Day"] = 864e5] = "Day";
  Duration2[Duration2["Week"] = 6048e5] = "Week";
  Duration2[Duration2["Year"] = 31536e6] = "Year";
  return Duration2;
})(Duration || {});
var isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
var assertIsNonNegativeInteger = (number, name) => {
  if (!isNonNegativeInteger(number)) {
    throw new Error(
      `"${name}" must be a non-negative integer. Received: "${number}".`
    );
  }
};
function inMilliseconds(count, duration) {
  assertIsNonNegativeInteger(count, "count");
  return count * duration;
}
function timeSince(timestamp) {
  assertIsNonNegativeInteger(timestamp, "timestamp");
  return Date.now() - timestamp;
}





exports.Duration = Duration; exports.inMilliseconds = inMilliseconds; exports.timeSince = timeSince;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-5AVWINSB.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-5AVWINSB.js ***!
  \****************************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/base64.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var base64 = (struct, options = {}) => {
  const paddingRequired = _nullishCoalesce(options.paddingRequired, () => ( false));
  const characterSet = _nullishCoalesce(options.characterSet, () => ( "base64"));
  let letters;
  if (characterSet === "base64") {
    letters = String.raw`[A-Za-z0-9+\/]`;
  } else {
    _chunk6ZDHSOUVjs.assert.call(void 0, characterSet === "base64url");
    letters = String.raw`[-_A-Za-z0-9]`;
  }
  let re;
  if (paddingRequired) {
    re = new RegExp(
      `^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`,
      "u"
    );
  } else {
    re = new RegExp(
      `^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`,
      "u"
    );
  }
  return _superstruct.pattern.call(void 0, struct, re);
};



exports.base64 = base64;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkIZC266HSjs = __webpack_require__(/*! ./chunk-IZC266HS.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-IZC266HS.js");

// src/assert.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
function isConstructable(fn) {
  return Boolean(typeof _optionalChain([fn, 'optionalAccess', _ => _.prototype, 'optionalAccess', _2 => _2.constructor, 'optionalAccess', _3 => _3.name]) === "string");
}
function getErrorMessageWithoutTrailingPeriod(error) {
  return _chunkIZC266HSjs.getErrorMessage.call(void 0, error).replace(/\.$/u, "");
}
function getError(ErrorWrapper, message) {
  if (isConstructable(ErrorWrapper)) {
    return new ErrorWrapper({
      message
    });
  }
  return ErrorWrapper({
    message
  });
}
var AssertionError = class extends Error {
  constructor(options) {
    super(options.message);
    this.code = "ERR_ASSERTION";
  }
};
function assert(value, message = "Assertion failed.", ErrorWrapper = AssertionError) {
  if (!value) {
    if (message instanceof Error) {
      throw message;
    }
    throw getError(ErrorWrapper, message);
  }
}
function assertStruct(value, struct, errorPrefix = "Assertion failed", ErrorWrapper = AssertionError) {
  try {
    _superstruct.assert.call(void 0, value, struct);
  } catch (error) {
    throw getError(
      ErrorWrapper,
      `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`
    );
  }
}
function assertExhaustive(_object) {
  throw new Error(
    "Invalid branch reached. Should be detected during compilation."
  );
}






exports.AssertionError = AssertionError; exports.assert = assert; exports.assertStruct = assertStruct; exports.assertExhaustive = assertExhaustive;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));



var _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js");


var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/coercers.ts









var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var NumberLikeStruct = _superstruct.union.call(void 0, [_superstruct.number.call(void 0, ), _superstruct.bigint.call(void 0, ), _superstruct.string.call(void 0, ), _chunkQEPVHEP7js.StrictHexStruct]);
var NumberCoercer = _superstruct.coerce.call(void 0, _superstruct.number.call(void 0, ), NumberLikeStruct, Number);
var BigIntCoercer = _superstruct.coerce.call(void 0, _superstruct.bigint.call(void 0, ), NumberLikeStruct, BigInt);
var BytesLikeStruct = _superstruct.union.call(void 0, [_chunkQEPVHEP7js.StrictHexStruct, _superstruct.instance.call(void 0, Uint8Array)]);
var BytesCoercer = _superstruct.coerce.call(void 0, 
  _superstruct.instance.call(void 0, Uint8Array),
  _superstruct.union.call(void 0, [_chunkQEPVHEP7js.StrictHexStruct]),
  _chunkQEPVHEP7js.hexToBytes
);
var HexCoercer = _superstruct.coerce.call(void 0, _chunkQEPVHEP7js.StrictHexStruct, _superstruct.instance.call(void 0, Uint8Array), _chunkQEPVHEP7js.bytesToHex);
function createNumber(value) {
  try {
    const result = _superstruct.create.call(void 0, value, NumberCoercer);
    _chunk6ZDHSOUVjs.assert.call(void 0, 
      Number.isFinite(result),
      `Expected a number-like value, got "${value}".`
    );
    return result;
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(`Expected a number-like value, got "${value}".`);
    }
    throw error;
  }
}
function createBigInt(value) {
  try {
    return _superstruct.create.call(void 0, value, BigIntCoercer);
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(
        `Expected a number-like value, got "${String(error.value)}".`
      );
    }
    throw error;
  }
}
function createBytes(value) {
  if (typeof value === "string" && value.toLowerCase() === "0x") {
    return new Uint8Array();
  }
  try {
    return _superstruct.create.call(void 0, value, BytesCoercer);
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(
        `Expected a bytes-like value, got "${String(error.value)}".`
      );
    }
    throw error;
  }
}
function createHex(value) {
  if (value instanceof Uint8Array && value.length === 0 || typeof value === "string" && value.toLowerCase() === "0x") {
    return "0x";
  }
  try {
    return _superstruct.create.call(void 0, value, HexCoercer);
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(
        `Expected a bytes-like value, got "${String(error.value)}".`
      );
    }
    throw error;
  }
}






exports.createNumber = createNumber; exports.createBigInt = createBigInt; exports.createBytes = createBytes; exports.createHex = createHex;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));

var _chunk6NZW4WK4js = __webpack_require__(/*! ./chunk-6NZW4WK4.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js");

// src/checksum.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var ChecksumStruct = _superstruct.size.call(void 0, 
  _chunk6NZW4WK4js.base64.call(void 0, _superstruct.string.call(void 0, ), { paddingRequired: true }),
  44,
  44
);



exports.ChecksumStruct = ChecksumStruct;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js ***!
  \****************************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-IZC266HS.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-IZC266HS.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));


var _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js");

// src/errors.ts
var _ponycause = __webpack_require__(/*! pony-cause */ "./node_modules/pony-cause/index.js");
function isError(error) {
  return error instanceof Error || _chunkQVEKZRZ2js.isObject.call(void 0, error) && error.constructor.name === "Error";
}
function isErrorWithCode(error) {
  return typeof error === "object" && error !== null && "code" in error;
}
function isErrorWithMessage(error) {
  return typeof error === "object" && error !== null && "message" in error;
}
function isErrorWithStack(error) {
  return typeof error === "object" && error !== null && "stack" in error;
}
function getErrorMessage(error) {
  if (isErrorWithMessage(error) && typeof error.message === "string") {
    return error.message;
  }
  if (_chunkQVEKZRZ2js.isNullOrUndefined.call(void 0, error)) {
    return "";
  }
  return String(error);
}
function wrapError(originalError, message) {
  if (isError(originalError)) {
    let error;
    if (Error.length === 2) {
      error = new Error(message, { cause: originalError });
    } else {
      error = new (0, _ponycause.ErrorWithCause)(message, { cause: originalError });
    }
    if (isErrorWithCode(originalError)) {
      error.code = originalError.code;
    }
    return error;
  }
  if (message.length > 0) {
    return new Error(`${String(originalError)}: ${message}`);
  }
  return new Error(String(originalError));
}







exports.isErrorWithCode = isErrorWithCode; exports.isErrorWithMessage = isErrorWithMessage; exports.isErrorWithStack = isErrorWithStack; exports.getErrorMessage = getErrorMessage; exports.wrapError = wrapError;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js ***!
  \****************************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-OLLG4H35.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-OLLG4H35.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");


var _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js");

// src/json.ts




















var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var object = (schema) => (
  // The type is slightly different from a regular object struct, because we
  // want to make properties with `undefined` in their type optional, but not
  // `undefined` itself. This means that we need a type cast.
  _superstruct.object.call(void 0, schema)
);
function hasOptional({ path, branch }) {
  const field = path[path.length - 1];
  return _chunkQVEKZRZ2js.hasProperty.call(void 0, branch[branch.length - 2], field);
}
function exactOptional(struct) {
  return new (0, _superstruct.Struct)({
    ...struct,
    type: `optional ${struct.type}`,
    validator: (value, context) => !hasOptional(context) || struct.validator(value, context),
    refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context)
  });
}
var finiteNumber = () => _superstruct.define.call(void 0, "finite number", (value) => {
  return _superstruct.is.call(void 0, value, _superstruct.number.call(void 0, )) && Number.isFinite(value);
});
var UnsafeJsonStruct = _superstruct.union.call(void 0, [
  _superstruct.literal.call(void 0, null),
  _superstruct.boolean.call(void 0, ),
  finiteNumber(),
  _superstruct.string.call(void 0, ),
  _superstruct.array.call(void 0, _superstruct.lazy.call(void 0, () => UnsafeJsonStruct)),
  _superstruct.record.call(void 0, 
    _superstruct.string.call(void 0, ),
    _superstruct.lazy.call(void 0, () => UnsafeJsonStruct)
  )
]);
var JsonStruct = _superstruct.coerce.call(void 0, UnsafeJsonStruct, _superstruct.any.call(void 0, ), (value) => {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, UnsafeJsonStruct);
  return JSON.parse(
    JSON.stringify(value, (propKey, propValue) => {
      if (propKey === "__proto__" || propKey === "constructor") {
        return void 0;
      }
      return propValue;
    })
  );
});
function isValidJson(value) {
  try {
    getSafeJson(value);
    return true;
  } catch (e) {
    return false;
  }
}
function getSafeJson(value) {
  return _superstruct.create.call(void 0, value, JsonStruct);
}
function getJsonSize(value) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, JsonStruct, "Invalid JSON value");
  const json = JSON.stringify(value);
  return new TextEncoder().encode(json).byteLength;
}
var jsonrpc2 = "2.0";
var JsonRpcVersionStruct = _superstruct.literal.call(void 0, jsonrpc2);
var JsonRpcIdStruct = _superstruct.nullable.call(void 0, _superstruct.union.call(void 0, [_superstruct.number.call(void 0, ), _superstruct.string.call(void 0, )]));
var JsonRpcErrorStruct = object({
  code: _superstruct.integer.call(void 0, ),
  message: _superstruct.string.call(void 0, ),
  data: exactOptional(JsonStruct),
  stack: exactOptional(_superstruct.string.call(void 0, ))
});
var JsonRpcParamsStruct = _superstruct.union.call(void 0, [_superstruct.record.call(void 0, _superstruct.string.call(void 0, ), JsonStruct), _superstruct.array.call(void 0, JsonStruct)]);
var JsonRpcRequestStruct = object({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  method: _superstruct.string.call(void 0, ),
  params: exactOptional(JsonRpcParamsStruct)
});
var JsonRpcNotificationStruct = object({
  jsonrpc: JsonRpcVersionStruct,
  method: _superstruct.string.call(void 0, ),
  params: exactOptional(JsonRpcParamsStruct)
});
function isJsonRpcNotification(value) {
  return _superstruct.is.call(void 0, value, JsonRpcNotificationStruct);
}
function assertIsJsonRpcNotification(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcNotificationStruct,
    "Invalid JSON-RPC notification",
    ErrorWrapper
  );
}
function isJsonRpcRequest(value) {
  return _superstruct.is.call(void 0, value, JsonRpcRequestStruct);
}
function assertIsJsonRpcRequest(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcRequestStruct,
    "Invalid JSON-RPC request",
    ErrorWrapper
  );
}
var PendingJsonRpcResponseStruct = _superstruct.object.call(void 0, {
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  result: _superstruct.optional.call(void 0, _superstruct.unknown.call(void 0, )),
  error: _superstruct.optional.call(void 0, JsonRpcErrorStruct)
});
var JsonRpcSuccessStruct = object({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  result: JsonStruct
});
var JsonRpcFailureStruct = object({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  error: JsonRpcErrorStruct
});
var JsonRpcResponseStruct = _superstruct.union.call(void 0, [
  JsonRpcSuccessStruct,
  JsonRpcFailureStruct
]);
function isPendingJsonRpcResponse(response) {
  return _superstruct.is.call(void 0, response, PendingJsonRpcResponseStruct);
}
function assertIsPendingJsonRpcResponse(response, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    response,
    PendingJsonRpcResponseStruct,
    "Invalid pending JSON-RPC response",
    ErrorWrapper
  );
}
function isJsonRpcResponse(response) {
  return _superstruct.is.call(void 0, response, JsonRpcResponseStruct);
}
function assertIsJsonRpcResponse(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcResponseStruct,
    "Invalid JSON-RPC response",
    ErrorWrapper
  );
}
function isJsonRpcSuccess(value) {
  return _superstruct.is.call(void 0, value, JsonRpcSuccessStruct);
}
function assertIsJsonRpcSuccess(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcSuccessStruct,
    "Invalid JSON-RPC success response",
    ErrorWrapper
  );
}
function isJsonRpcFailure(value) {
  return _superstruct.is.call(void 0, value, JsonRpcFailureStruct);
}
function assertIsJsonRpcFailure(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcFailureStruct,
    "Invalid JSON-RPC failure response",
    ErrorWrapper
  );
}
function isJsonRpcError(value) {
  return _superstruct.is.call(void 0, value, JsonRpcErrorStruct);
}
function assertIsJsonRpcError(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcErrorStruct,
    "Invalid JSON-RPC error",
    ErrorWrapper
  );
}
function getJsonRpcIdValidator(options) {
  const { permitEmptyString, permitFractions, permitNull } = {
    permitEmptyString: true,
    permitFractions: false,
    permitNull: true,
    ...options
  };
  const isValidJsonRpcId = (id) => {
    return Boolean(
      typeof id === "number" && (permitFractions || Number.isInteger(id)) || typeof id === "string" && (permitEmptyString || id.length > 0) || permitNull && id === null
    );
  };
  return isValidJsonRpcId;
}



































exports.object = object; exports.exactOptional = exactOptional; exports.UnsafeJsonStruct = UnsafeJsonStruct; exports.JsonStruct = JsonStruct; exports.isValidJson = isValidJson; exports.getSafeJson = getSafeJson; exports.getJsonSize = getJsonSize; exports.jsonrpc2 = jsonrpc2; exports.JsonRpcVersionStruct = JsonRpcVersionStruct; exports.JsonRpcIdStruct = JsonRpcIdStruct; exports.JsonRpcErrorStruct = JsonRpcErrorStruct; exports.JsonRpcParamsStruct = JsonRpcParamsStruct; exports.JsonRpcRequestStruct = JsonRpcRequestStruct; exports.JsonRpcNotificationStruct = JsonRpcNotificationStruct; exports.isJsonRpcNotification = isJsonRpcNotification; exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification; exports.isJsonRpcRequest = isJsonRpcRequest; exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest; exports.PendingJsonRpcResponseStruct = PendingJsonRpcResponseStruct; exports.JsonRpcSuccessStruct = JsonRpcSuccessStruct; exports.JsonRpcFailureStruct = JsonRpcFailureStruct; exports.JsonRpcResponseStruct = JsonRpcResponseStruct; exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse; exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse; exports.isJsonRpcResponse = isJsonRpcResponse; exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse; exports.isJsonRpcSuccess = isJsonRpcSuccess; exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess; exports.isJsonRpcFailure = isJsonRpcFailure; exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure; exports.isJsonRpcError = isJsonRpcError; exports.assertIsJsonRpcError = assertIsJsonRpcError; exports.getJsonRpcIdValidator = getJsonRpcIdValidator;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/hex.ts
var _sha3 = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/@noble/hashes/sha3.js");
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");

// src/bytes.ts
var _base = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");
var HEX_MINIMUM_NUMBER_CHARACTER = 48;
var HEX_MAXIMUM_NUMBER_CHARACTER = 58;
var HEX_CHARACTER_OFFSET = 87;
function getPrecomputedHexValuesBuilder() {
  const lookupTable = [];
  return () => {
    if (lookupTable.length === 0) {
      for (let i = 0; i < 256; i++) {
        lookupTable.push(i.toString(16).padStart(2, "0"));
      }
    }
    return lookupTable;
  };
}
var getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
function isBytes(value) {
  return value instanceof Uint8Array;
}
function assertIsBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, isBytes(value), "Value must be a Uint8Array.");
}
function bytesToHex(bytes) {
  assertIsBytes(bytes);
  if (bytes.length === 0) {
    return "0x";
  }
  const lookupTable = getPrecomputedHexValues();
  const hexadecimal = new Array(bytes.length);
  for (let i = 0; i < bytes.length; i++) {
    hexadecimal[i] = lookupTable[bytes[i]];
  }
  return add0x(hexadecimal.join(""));
}
function bytesToBigInt(bytes) {
  assertIsBytes(bytes);
  const hexadecimal = bytesToHex(bytes);
  return BigInt(hexadecimal);
}
function bytesToSignedBigInt(bytes) {
  assertIsBytes(bytes);
  let value = BigInt(0);
  for (const byte of bytes) {
    value = (value << BigInt(8)) + BigInt(byte);
  }
  return BigInt.asIntN(bytes.length * 8, value);
}
function bytesToNumber(bytes) {
  assertIsBytes(bytes);
  const bigint = bytesToBigInt(bytes);
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    bigint <= BigInt(Number.MAX_SAFE_INTEGER),
    "Number is not a safe integer. Use `bytesToBigInt` instead."
  );
  return Number(bigint);
}
function bytesToString(bytes) {
  assertIsBytes(bytes);
  return new TextDecoder().decode(bytes);
}
function bytesToBase64(bytes) {
  assertIsBytes(bytes);
  return _base.base64.encode(bytes);
}
function hexToBytes(value) {
  if (_optionalChain([value, 'optionalAccess', _ => _.toLowerCase, 'optionalCall', _2 => _2()]) === "0x") {
    return new Uint8Array();
  }
  assertIsHexString(value);
  const strippedValue = remove0x(value).toLowerCase();
  const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
  const bytes = new Uint8Array(normalizedValue.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    const c1 = normalizedValue.charCodeAt(i * 2);
    const c2 = normalizedValue.charCodeAt(i * 2 + 1);
    const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
    const n2 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
    bytes[i] = n1 * 16 + n2;
  }
  return bytes;
}
function bigIntToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "bigint", "Value must be a bigint.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= BigInt(0), "Value must be a non-negative bigint.");
  const hexadecimal = value.toString(16);
  return hexToBytes(hexadecimal);
}
function bigIntFits(value, bytes) {
  _chunk6ZDHSOUVjs.assert.call(void 0, bytes > 0);
  const mask = value >> BigInt(31);
  return !((~value & mask) + (value & ~mask) >> BigInt(bytes * 8 + ~0));
}
function signedBigIntToBytes(value, byteLength) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "bigint", "Value must be a bigint.");
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof byteLength === "number", "Byte length must be a number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, byteLength > 0, "Byte length must be greater than 0.");
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    bigIntFits(value, byteLength),
    "Byte length is too small to represent the given value."
  );
  let numberValue = value;
  const bytes = new Uint8Array(byteLength);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = Number(BigInt.asUintN(8, numberValue));
    numberValue >>= BigInt(8);
  }
  return bytes.reverse();
}
function numberToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "number", "Value must be a number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, "Value must be a non-negative number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    Number.isSafeInteger(value),
    "Value is not a safe integer. Use `bigIntToBytes` instead."
  );
  const hexadecimal = value.toString(16);
  return hexToBytes(hexadecimal);
}
function stringToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "string", "Value must be a string.");
  return new TextEncoder().encode(value);
}
function base64ToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "string", "Value must be a string.");
  return _base.base64.decode(value);
}
function valueToBytes(value) {
  if (typeof value === "bigint") {
    return bigIntToBytes(value);
  }
  if (typeof value === "number") {
    return numberToBytes(value);
  }
  if (typeof value === "string") {
    if (value.startsWith("0x")) {
      return hexToBytes(value);
    }
    return stringToBytes(value);
  }
  if (isBytes(value)) {
    return value;
  }
  throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
function concatBytes(values) {
  const normalizedValues = new Array(values.length);
  let byteLength = 0;
  for (let i = 0; i < values.length; i++) {
    const value = valueToBytes(values[i]);
    normalizedValues[i] = value;
    byteLength += value.length;
  }
  const bytes = new Uint8Array(byteLength);
  for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
    bytes.set(normalizedValues[i], offset);
    offset += normalizedValues[i].length;
  }
  return bytes;
}
function createDataView(bytes) {
  if (typeof Buffer !== "undefined" && bytes instanceof Buffer) {
    const buffer = bytes.buffer.slice(
      bytes.byteOffset,
      bytes.byteOffset + bytes.byteLength
    );
    return new DataView(buffer);
  }
  return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}

// src/hex.ts
var HexStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), /^(?:0x)?[0-9a-f]+$/iu);
var StrictHexStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), /^0x[0-9a-f]+$/iu);
var HexAddressStruct = _superstruct.pattern.call(void 0, 
  _superstruct.string.call(void 0, ),
  /^0x[0-9a-f]{40}$/u
);
var HexChecksumAddressStruct = _superstruct.pattern.call(void 0, 
  _superstruct.string.call(void 0, ),
  /^0x[0-9a-fA-F]{40}$/u
);
function isHexString(value) {
  return _superstruct.is.call(void 0, value, HexStruct);
}
function isStrictHexString(value) {
  return _superstruct.is.call(void 0, value, StrictHexStruct);
}
function assertIsHexString(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, isHexString(value), "Value must be a hexadecimal string.");
}
function assertIsStrictHexString(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    isStrictHexString(value),
    'Value must be a hexadecimal string, starting with "0x".'
  );
}
function isValidHexAddress(possibleAddress) {
  return _superstruct.is.call(void 0, possibleAddress, HexAddressStruct) || isValidChecksumAddress(possibleAddress);
}
function getChecksumAddress(address) {
  _chunk6ZDHSOUVjs.assert.call(void 0, _superstruct.is.call(void 0, address, HexChecksumAddressStruct), "Invalid hex address.");
  const unPrefixed = remove0x(address.toLowerCase());
  const unPrefixedHash = remove0x(bytesToHex(_sha3.keccak_256.call(void 0, unPrefixed)));
  return `0x${unPrefixed.split("").map((character, nibbleIndex) => {
    const hashCharacter = unPrefixedHash[nibbleIndex];
    _chunk6ZDHSOUVjs.assert.call(void 0, _superstruct.is.call(void 0, hashCharacter, _superstruct.string.call(void 0, )), "Hash shorter than address.");
    return parseInt(hashCharacter, 16) > 7 ? character.toUpperCase() : character;
  }).join("")}`;
}
function isValidChecksumAddress(possibleChecksum) {
  if (!_superstruct.is.call(void 0, possibleChecksum, HexChecksumAddressStruct)) {
    return false;
  }
  return getChecksumAddress(possibleChecksum) === possibleChecksum;
}
function add0x(hexadecimal) {
  if (hexadecimal.startsWith("0x")) {
    return hexadecimal;
  }
  if (hexadecimal.startsWith("0X")) {
    return `0x${hexadecimal.substring(2)}`;
  }
  return `0x${hexadecimal}`;
}
function remove0x(hexadecimal) {
  if (hexadecimal.startsWith("0x") || hexadecimal.startsWith("0X")) {
    return hexadecimal.substring(2);
  }
  return hexadecimal;
}
































exports.HexStruct = HexStruct; exports.StrictHexStruct = StrictHexStruct; exports.HexAddressStruct = HexAddressStruct; exports.HexChecksumAddressStruct = HexChecksumAddressStruct; exports.isHexString = isHexString; exports.isStrictHexString = isStrictHexString; exports.assertIsHexString = assertIsHexString; exports.assertIsStrictHexString = assertIsStrictHexString; exports.isValidHexAddress = isValidHexAddress; exports.getChecksumAddress = getChecksumAddress; exports.isValidChecksumAddress = isValidChecksumAddress; exports.add0x = add0x; exports.remove0x = remove0x; exports.isBytes = isBytes; exports.assertIsBytes = assertIsBytes; exports.bytesToHex = bytesToHex; exports.bytesToBigInt = bytesToBigInt; exports.bytesToSignedBigInt = bytesToSignedBigInt; exports.bytesToNumber = bytesToNumber; exports.bytesToString = bytesToString; exports.bytesToBase64 = bytesToBase64; exports.hexToBytes = hexToBytes; exports.bigIntToBytes = bigIntToBytes; exports.signedBigIntToBytes = signedBigIntToBytes; exports.numberToBytes = numberToBytes; exports.stringToBytes = stringToBytes; exports.base64ToBytes = base64ToBytes; exports.valueToBytes = valueToBytes; exports.concatBytes = concatBytes; exports.createDataView = createDataView;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }// src/misc.ts
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
function isObject(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
var hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
function getKnownPropertyNames(object) {
  return Object.getOwnPropertyNames(object);
}
var JsonSize = /* @__PURE__ */ ((JsonSize2) => {
  JsonSize2[JsonSize2["Null"] = 4] = "Null";
  JsonSize2[JsonSize2["Comma"] = 1] = "Comma";
  JsonSize2[JsonSize2["Wrapper"] = 1] = "Wrapper";
  JsonSize2[JsonSize2["True"] = 4] = "True";
  JsonSize2[JsonSize2["False"] = 5] = "False";
  JsonSize2[JsonSize2["Quote"] = 1] = "Quote";
  JsonSize2[JsonSize2["Colon"] = 1] = "Colon";
  JsonSize2[JsonSize2["Date"] = 24] = "Date";
  return JsonSize2;
})(JsonSize || {});
var ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  try {
    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
  } catch (_) {
    return false;
  }
}
function isASCII(character) {
  return character.charCodeAt(0) <= 127;
}
function calculateStringSize(value) {
  const size = value.split("").reduce((total, character) => {
    if (isASCII(character)) {
      return total + 1;
    }
    return total + 2;
  }, 0);
  return size + (_nullishCoalesce(value.match(ESCAPE_CHARACTERS_REGEXP), () => ( []))).length;
}
function calculateNumberSize(value) {
  return value.toString().length;
}













exports.isNonEmptyArray = isNonEmptyArray; exports.isNullOrUndefined = isNullOrUndefined; exports.isObject = isObject; exports.hasProperty = hasProperty; exports.getKnownPropertyNames = getKnownPropertyNames; exports.JsonSize = JsonSize; exports.ESCAPE_CHARACTERS_REGEXP = ESCAPE_CHARACTERS_REGEXP; exports.isPlainObject = isPlainObject; exports.isASCII = isASCII; exports.calculateStringSize = calculateStringSize; exports.calculateNumberSize = calculateNumberSize;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js ***!
  \****************************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/caip-types.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var CAIP_CHAIN_ID_REGEX = /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u;
var CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;
var CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u;
var CAIP_ACCOUNT_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u;
var CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;
var CaipChainIdStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_CHAIN_ID_REGEX);
var CaipNamespaceStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_NAMESPACE_REGEX);
var CaipReferenceStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_REFERENCE_REGEX);
var CaipAccountIdStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_ACCOUNT_ID_REGEX);
var CaipAccountAddressStruct = _superstruct.pattern.call(void 0, 
  _superstruct.string.call(void 0, ),
  CAIP_ACCOUNT_ADDRESS_REGEX
);
function isCaipChainId(value) {
  return _superstruct.is.call(void 0, value, CaipChainIdStruct);
}
function isCaipNamespace(value) {
  return _superstruct.is.call(void 0, value, CaipNamespaceStruct);
}
function isCaipReference(value) {
  return _superstruct.is.call(void 0, value, CaipReferenceStruct);
}
function isCaipAccountId(value) {
  return _superstruct.is.call(void 0, value, CaipAccountIdStruct);
}
function isCaipAccountAddress(value) {
  return _superstruct.is.call(void 0, value, CaipAccountAddressStruct);
}
function parseCaipChainId(caipChainId) {
  const match = CAIP_CHAIN_ID_REGEX.exec(caipChainId);
  if (!_optionalChain([match, 'optionalAccess', _ => _.groups])) {
    throw new Error("Invalid CAIP chain ID.");
  }
  return {
    namespace: match.groups.namespace,
    reference: match.groups.reference
  };
}
function parseCaipAccountId(caipAccountId) {
  const match = CAIP_ACCOUNT_ID_REGEX.exec(caipAccountId);
  if (!_optionalChain([match, 'optionalAccess', _2 => _2.groups])) {
    throw new Error("Invalid CAIP account ID.");
  }
  return {
    address: match.groups.accountAddress,
    chainId: match.groups.chainId,
    chain: {
      namespace: match.groups.namespace,
      reference: match.groups.reference
    }
  };
}



















exports.CAIP_CHAIN_ID_REGEX = CAIP_CHAIN_ID_REGEX; exports.CAIP_NAMESPACE_REGEX = CAIP_NAMESPACE_REGEX; exports.CAIP_REFERENCE_REGEX = CAIP_REFERENCE_REGEX; exports.CAIP_ACCOUNT_ID_REGEX = CAIP_ACCOUNT_ID_REGEX; exports.CAIP_ACCOUNT_ADDRESS_REGEX = CAIP_ACCOUNT_ADDRESS_REGEX; exports.CaipChainIdStruct = CaipChainIdStruct; exports.CaipNamespaceStruct = CaipNamespaceStruct; exports.CaipReferenceStruct = CaipReferenceStruct; exports.CaipAccountIdStruct = CaipAccountIdStruct; exports.CaipAccountAddressStruct = CaipAccountAddressStruct; exports.isCaipChainId = isCaipChainId; exports.isCaipNamespace = isCaipNamespace; exports.isCaipReference = isCaipReference; exports.isCaipAccountId = isCaipAccountId; exports.isCaipAccountAddress = isCaipAccountAddress; exports.parseCaipChainId = parseCaipChainId; exports.parseCaipAccountId = parseCaipAccountId;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js ***!
  \****************************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));


var _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js");


var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/number.ts
var numberToHex = (value) => {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "number", "Value must be a number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, "Value must be a non-negative number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    Number.isSafeInteger(value),
    "Value is not a safe integer. Use `bigIntToHex` instead."
  );
  return _chunkQEPVHEP7js.add0x.call(void 0, value.toString(16));
};
var bigIntToHex = (value) => {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "bigint", "Value must be a bigint.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, "Value must be a non-negative bigint.");
  return _chunkQEPVHEP7js.add0x.call(void 0, value.toString(16));
};
var hexToNumber = (value) => {
  _chunkQEPVHEP7js.assertIsHexString.call(void 0, value);
  const numberValue = parseInt(value, 16);
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    Number.isSafeInteger(numberValue),
    "Value is not a safe integer. Use `hexToBigInt` instead."
  );
  return numberValue;
};
var hexToBigInt = (value) => {
  _chunkQEPVHEP7js.assertIsHexString.call(void 0, value);
  return BigInt(_chunkQEPVHEP7js.add0x.call(void 0, value));
};






exports.numberToHex = numberToHex; exports.bigIntToHex = bigIntToHex; exports.hexToNumber = hexToNumber; exports.hexToBigInt = hexToBigInt;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));



var _chunk3W5G4CYIjs = __webpack_require__(/*! ./chunk-3W5G4CYI.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js");

// src/collections.ts
var _map;
var FrozenMap = class {
  constructor(entries) {
    _chunk3W5G4CYIjs.__privateAdd.call(void 0, this, _map, void 0);
    _chunk3W5G4CYIjs.__privateSet.call(void 0, this, _map, new Map(entries));
    Object.freeze(this);
  }
  get size() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).size;
  }
  [Symbol.iterator]() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map)[Symbol.iterator]();
  }
  entries() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).entries();
  }
  forEach(callbackfn, thisArg) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).forEach(
      (value, key, _map2) => callbackfn.call(thisArg, value, key, this)
    );
  }
  get(key) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).get(key);
  }
  has(key) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).has(key);
  }
  keys() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).keys();
  }
  values() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([key, value]) => `${String(key)} => ${String(value)}`).join(", ")} ` : ""}}`;
  }
};
_map = new WeakMap();
var _set;
var FrozenSet = class {
  constructor(values) {
    _chunk3W5G4CYIjs.__privateAdd.call(void 0, this, _set, void 0);
    _chunk3W5G4CYIjs.__privateSet.call(void 0, this, _set, new Set(values));
    Object.freeze(this);
  }
  get size() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).size;
  }
  [Symbol.iterator]() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set)[Symbol.iterator]();
  }
  entries() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).entries();
  }
  forEach(callbackfn, thisArg) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).forEach(
      (value, value2, _set2) => callbackfn.call(thisArg, value, value2, this)
    );
  }
  has(value) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).has(value);
  }
  keys() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).keys();
  }
  values() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((member) => String(member)).join(", ")} ` : ""}}`;
  }
};
_set = new WeakMap();
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);




exports.FrozenMap = FrozenMap; exports.FrozenSet = FrozenSet;


/***/ }),

/***/ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));__webpack_require__(/*! ./chunk-5AVWINSB.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-5AVWINSB.js");





var _chunkVFXTVNXNjs = __webpack_require__(/*! ./chunk-VFXTVNXN.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js");
__webpack_require__(/*! ./chunk-LC2CRSWD.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js");


var _chunk4NIRTM4Mjs = __webpack_require__(/*! ./chunk-4NIRTM4M.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-4NIRTM4M.js");




var _chunk4RMX5YWEjs = __webpack_require__(/*! ./chunk-4RMX5YWE.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js");
__webpack_require__(/*! ./chunk-UOTVU7OQ.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js");










var _chunk4D6XQBHAjs = __webpack_require__(/*! ./chunk-4D6XQBHA.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js");


































var _chunkOLLG4H35js = __webpack_require__(/*! ./chunk-OLLG4H35.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-OLLG4H35.js");
__webpack_require__(/*! ./chunk-RKRGAFXY.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js");



var _chunk2LBGT4GHjs = __webpack_require__(/*! ./chunk-2LBGT4GH.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js");


















var _chunkU7ZUGCE7js = __webpack_require__(/*! ./chunk-U7ZUGCE7.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js");


var _chunkE4C7EW4Rjs = __webpack_require__(/*! ./chunk-E4C7EW4R.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js");


var _chunk6NZW4WK4js = __webpack_require__(/*! ./chunk-6NZW4WK4.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js");





var _chunkDHVKFDHQjs = __webpack_require__(/*! ./chunk-DHVKFDHQ.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js");































var _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js");





var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");






var _chunkIZC266HSjs = __webpack_require__(/*! ./chunk-IZC266HS.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-IZC266HS.js");












var _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js");



var _chunkZ2RGWDD7js = __webpack_require__(/*! ./chunk-Z2RGWDD7.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js");
__webpack_require__(/*! ./chunk-3W5G4CYI.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js");
__webpack_require__(/*! ./chunk-EQMZL4XU.js */ "./node_modules/@metamask/json-rpc-engine/node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js");
































































































































exports.AssertionError = _chunk6ZDHSOUVjs.AssertionError; exports.CAIP_ACCOUNT_ADDRESS_REGEX = _chunkU7ZUGCE7js.CAIP_ACCOUNT_ADDRESS_REGEX; exports.CAIP_ACCOUNT_ID_REGEX = _chunkU7ZUGCE7js.CAIP_ACCOUNT_ID_REGEX; exports.CAIP_CHAIN_ID_REGEX = _chunkU7ZUGCE7js.CAIP_CHAIN_ID_REGEX; exports.CAIP_NAMESPACE_REGEX = _chunkU7ZUGCE7js.CAIP_NAMESPACE_REGEX; exports.CAIP_REFERENCE_REGEX = _chunkU7ZUGCE7js.CAIP_REFERENCE_REGEX; exports.CaipAccountAddressStruct = _chunkU7ZUGCE7js.CaipAccountAddressStruct; exports.CaipAccountIdStruct = _chunkU7ZUGCE7js.CaipAccountIdStruct; exports.CaipChainIdStruct = _chunkU7ZUGCE7js.CaipChainIdStruct; exports.CaipNamespaceStruct = _chunkU7ZUGCE7js.CaipNamespaceStruct; exports.CaipReferenceStruct = _chunkU7ZUGCE7js.CaipReferenceStruct; exports.ChecksumStruct = _chunkE4C7EW4Rjs.ChecksumStruct; exports.Duration = _chunk4RMX5YWEjs.Duration; exports.ESCAPE_CHARACTERS_REGEXP = _chunkQVEKZRZ2js.ESCAPE_CHARACTERS_REGEXP; exports.FrozenMap = _chunkZ2RGWDD7js.FrozenMap; exports.FrozenSet = _chunkZ2RGWDD7js.FrozenSet; exports.HexAddressStruct = _chunkQEPVHEP7js.HexAddressStruct; exports.HexChecksumAddressStruct = _chunkQEPVHEP7js.HexChecksumAddressStruct; exports.HexStruct = _chunkQEPVHEP7js.HexStruct; exports.JsonRpcErrorStruct = _chunkOLLG4H35js.JsonRpcErrorStruct; exports.JsonRpcFailureStruct = _chunkOLLG4H35js.JsonRpcFailureStruct; exports.JsonRpcIdStruct = _chunkOLLG4H35js.JsonRpcIdStruct; exports.JsonRpcNotificationStruct = _chunkOLLG4H35js.JsonRpcNotificationStruct; exports.JsonRpcParamsStruct = _chunkOLLG4H35js.JsonRpcParamsStruct; exports.JsonRpcRequestStruct = _chunkOLLG4H35js.JsonRpcRequestStruct; exports.JsonRpcResponseStruct = _chunkOLLG4H35js.JsonRpcResponseStruct; exports.JsonRpcSuccessStruct = _chunkOLLG4H35js.JsonRpcSuccessStruct; exports.JsonRpcVersionStruct = _chunkOLLG4H35js.JsonRpcVersionStruct; exports.JsonSize = _chunkQVEKZRZ2js.JsonSize; exports.JsonStruct = _chunkOLLG4H35js.JsonStruct; exports.PendingJsonRpcResponseStruct = _chunkOLLG4H35js.PendingJsonRpcResponseStruct; exports.StrictHexStruct = _chunkQEPVHEP7js.StrictHexStruct; exports.UnsafeJsonStruct = _chunkOLLG4H35js.UnsafeJsonStruct; exports.VersionRangeStruct = _chunk4D6XQBHAjs.VersionRangeStruct; exports.VersionStruct = _chunk4D6XQBHAjs.VersionStruct; exports.add0x = _chunkQEPVHEP7js.add0x; exports.assert = _chunk6ZDHSOUVjs.assert; exports.assertExhaustive = _chunk6ZDHSOUVjs.assertExhaustive; exports.assertIsBytes = _chunkQEPVHEP7js.assertIsBytes; exports.assertIsHexString = _chunkQEPVHEP7js.assertIsHexString; exports.assertIsJsonRpcError = _chunkOLLG4H35js.assertIsJsonRpcError; exports.assertIsJsonRpcFailure = _chunkOLLG4H35js.assertIsJsonRpcFailure; exports.assertIsJsonRpcNotification = _chunkOLLG4H35js.assertIsJsonRpcNotification; exports.assertIsJsonRpcRequest = _chunkOLLG4H35js.assertIsJsonRpcRequest; exports.assertIsJsonRpcResponse = _chunkOLLG4H35js.assertIsJsonRpcResponse; exports.assertIsJsonRpcSuccess = _chunkOLLG4H35js.assertIsJsonRpcSuccess; exports.assertIsPendingJsonRpcResponse = _chunkOLLG4H35js.assertIsPendingJsonRpcResponse; exports.assertIsSemVerRange = _chunk4D6XQBHAjs.assertIsSemVerRange; exports.assertIsSemVerVersion = _chunk4D6XQBHAjs.assertIsSemVerVersion; exports.assertIsStrictHexString = _chunkQEPVHEP7js.assertIsStrictHexString; exports.assertStruct = _chunk6ZDHSOUVjs.assertStruct; exports.base64 = _chunk6NZW4WK4js.base64; exports.base64ToBytes = _chunkQEPVHEP7js.base64ToBytes; exports.bigIntToBytes = _chunkQEPVHEP7js.bigIntToBytes; exports.bigIntToHex = _chunkVFXTVNXNjs.bigIntToHex; exports.bytesToBase64 = _chunkQEPVHEP7js.bytesToBase64; exports.bytesToBigInt = _chunkQEPVHEP7js.bytesToBigInt; exports.bytesToHex = _chunkQEPVHEP7js.bytesToHex; exports.bytesToNumber = _chunkQEPVHEP7js.bytesToNumber; exports.bytesToSignedBigInt = _chunkQEPVHEP7js.bytesToSignedBigInt; exports.bytesToString = _chunkQEPVHEP7js.bytesToString; exports.calculateNumberSize = _chunkQVEKZRZ2js.calculateNumberSize; exports.calculateStringSize = _chunkQVEKZRZ2js.calculateStringSize; exports.concatBytes = _chunkQEPVHEP7js.concatBytes; exports.createBigInt = _chunkDHVKFDHQjs.createBigInt; exports.createBytes = _chunkDHVKFDHQjs.createBytes; exports.createDataView = _chunkQEPVHEP7js.createDataView; exports.createDeferredPromise = _chunk4NIRTM4Mjs.createDeferredPromise; exports.createHex = _chunkDHVKFDHQjs.createHex; exports.createModuleLogger = _chunk2LBGT4GHjs.createModuleLogger; exports.createNumber = _chunkDHVKFDHQjs.createNumber; exports.createProjectLogger = _chunk2LBGT4GHjs.createProjectLogger; exports.exactOptional = _chunkOLLG4H35js.exactOptional; exports.getChecksumAddress = _chunkQEPVHEP7js.getChecksumAddress; exports.getErrorMessage = _chunkIZC266HSjs.getErrorMessage; exports.getJsonRpcIdValidator = _chunkOLLG4H35js.getJsonRpcIdValidator; exports.getJsonSize = _chunkOLLG4H35js.getJsonSize; exports.getKnownPropertyNames = _chunkQVEKZRZ2js.getKnownPropertyNames; exports.getSafeJson = _chunkOLLG4H35js.getSafeJson; exports.gtRange = _chunk4D6XQBHAjs.gtRange; exports.gtVersion = _chunk4D6XQBHAjs.gtVersion; exports.hasProperty = _chunkQVEKZRZ2js.hasProperty; exports.hexToBigInt = _chunkVFXTVNXNjs.hexToBigInt; exports.hexToBytes = _chunkQEPVHEP7js.hexToBytes; exports.hexToNumber = _chunkVFXTVNXNjs.hexToNumber; exports.inMilliseconds = _chunk4RMX5YWEjs.inMilliseconds; exports.isASCII = _chunkQVEKZRZ2js.isASCII; exports.isBytes = _chunkQEPVHEP7js.isBytes; exports.isCaipAccountAddress = _chunkU7ZUGCE7js.isCaipAccountAddress; exports.isCaipAccountId = _chunkU7ZUGCE7js.isCaipAccountId; exports.isCaipChainId = _chunkU7ZUGCE7js.isCaipChainId; exports.isCaipNamespace = _chunkU7ZUGCE7js.isCaipNamespace; exports.isCaipReference = _chunkU7ZUGCE7js.isCaipReference; exports.isErrorWithCode = _chunkIZC266HSjs.isErrorWithCode; exports.isErrorWithMessage = _chunkIZC266HSjs.isErrorWithMessage; exports.isErrorWithStack = _chunkIZC266HSjs.isErrorWithStack; exports.isHexString = _chunkQEPVHEP7js.isHexString; exports.isJsonRpcError = _chunkOLLG4H35js.isJsonRpcError; exports.isJsonRpcFailure = _chunkOLLG4H35js.isJsonRpcFailure; exports.isJsonRpcNotification = _chunkOLLG4H35js.isJsonRpcNotification; exports.isJsonRpcRequest = _chunkOLLG4H35js.isJsonRpcRequest; exports.isJsonRpcResponse = _chunkOLLG4H35js.isJsonRpcResponse; exports.isJsonRpcSuccess = _chunkOLLG4H35js.isJsonRpcSuccess; exports.isNonEmptyArray = _chunkQVEKZRZ2js.isNonEmptyArray; exports.isNullOrUndefined = _chunkQVEKZRZ2js.isNullOrUndefined; exports.isObject = _chunkQVEKZRZ2js.isObject; exports.isPendingJsonRpcResponse = _chunkOLLG4H35js.isPendingJsonRpcResponse; exports.isPlainObject = _chunkQVEKZRZ2js.isPlainObject; exports.isStrictHexString = _chunkQEPVHEP7js.isStrictHexString; exports.isValidChecksumAddress = _chunkQEPVHEP7js.isValidChecksumAddress; exports.isValidHexAddress = _chunkQEPVHEP7js.isValidHexAddress; exports.isValidJson = _chunkOLLG4H35js.isValidJson; exports.isValidSemVerRange = _chunk4D6XQBHAjs.isValidSemVerRange; exports.isValidSemVerVersion = _chunk4D6XQBHAjs.isValidSemVerVersion; exports.jsonrpc2 = _chunkOLLG4H35js.jsonrpc2; exports.numberToBytes = _chunkQEPVHEP7js.numberToBytes; exports.numberToHex = _chunkVFXTVNXNjs.numberToHex; exports.object = _chunkOLLG4H35js.object; exports.parseCaipAccountId = _chunkU7ZUGCE7js.parseCaipAccountId; exports.parseCaipChainId = _chunkU7ZUGCE7js.parseCaipChainId; exports.remove0x = _chunkQEPVHEP7js.remove0x; exports.satisfiesVersionRange = _chunk4D6XQBHAjs.satisfiesVersionRange; exports.signedBigIntToBytes = _chunkQEPVHEP7js.signedBigIntToBytes; exports.stringToBytes = _chunkQEPVHEP7js.stringToBytes; exports.timeSince = _chunk4RMX5YWEjs.timeSince; exports.valueToBytes = _chunkQEPVHEP7js.valueToBytes; exports.wrapError = _chunkIZC266HSjs.wrapError;


/***/ }),

/***/ "./node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasePostMessageStream = void 0;
const readable_stream_1 = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");
const noop = () => undefined;
const SYN = 'SYN';
const ACK = 'ACK';
/**
 * Abstract base class for postMessage streams.
 */
class BasePostMessageStream extends readable_stream_1.Duplex {
    constructor() {
        super({
            objectMode: true,
        });
        // Initialization flags
        this._init = false;
        this._haveSyn = false;
        this._log = () => null;
    }
    /**
     * Must be called at end of child constructor to initiate
     * communication with other end.
     */
    _handshake() {
        // Send synchronization message
        this._write(SYN, null, noop);
        this.cork();
    }
    _onData(data) {
        if (this._init) {
            // Forward message
            try {
                this.push(data);
                this._log(data, false);
            }
            catch (err) {
                this.emit('error', err);
            }
        }
        else if (data === SYN) {
            // Listen for handshake
            this._haveSyn = true;
            this._write(ACK, null, noop);
        }
        else if (data === ACK) {
            this._init = true;
            if (!this._haveSyn) {
                this._write(ACK, null, noop);
            }
            this.uncork();
        }
    }
    _read() {
        return undefined;
    }
    _write(data, _encoding, cb) {
        if (data !== ACK && data !== SYN) {
            this._log(data, true);
        }
        this._postMessage(data);
        cb();
    }
    _setLogger(log) {
        this._log = log;
    }
}
exports.BasePostMessageStream = BasePostMessageStream;


/***/ }),

/***/ "./node_modules/@metamask/post-message-stream/dist/WebWorker/WebWorkerParentPostMessageStream.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@metamask/post-message-stream/dist/WebWorker/WebWorkerParentPostMessageStream.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebWorkerParentPostMessageStream = void 0;
const BasePostMessageStream_1 = __webpack_require__(/*! ../BasePostMessageStream */ "./node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js");
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/@metamask/post-message-stream/dist/utils.js");
/**
 * Parent-side dedicated `WebWorker.postMessage` stream. Designed for use with
 * dedicated workers only.
 */
class WebWorkerParentPostMessageStream extends BasePostMessageStream_1.BasePostMessageStream {
    /**
     * Creates a stream for communicating with a dedicated `WebWorker`.
     *
     * @param args - Options bag.
     * @param args.worker - The Web Worker to exchange messages with. The worker
     * must instantiate a `WebWorkerPostMessageStream`.
     */
    constructor({ worker }) {
        super();
        this._target = utils_1.DEDICATED_WORKER_NAME;
        this._worker = worker;
        this._worker.onmessage = this._onMessage.bind(this);
        this._handshake();
    }
    _postMessage(data) {
        this._worker.postMessage({
            target: this._target,
            data,
        });
    }
    _onMessage(event) {
        const message = event.data;
        if (!(0, utils_1.isValidStreamMessage)(message)) {
            return;
        }
        this._onData(message.data);
    }
    _destroy() {
        this._worker.onmessage = null;
        this._worker = null;
    }
}
exports.WebWorkerParentPostMessageStream = WebWorkerParentPostMessageStream;


/***/ }),

/***/ "./node_modules/@metamask/post-message-stream/dist/WebWorker/WebWorkerPostMessageStream.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@metamask/post-message-stream/dist/WebWorker/WebWorkerPostMessageStream.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebWorkerPostMessageStream = void 0;
// We ignore coverage for the entire file due to limits on our instrumentation,
// but it is in fact covered by our tests.
const BasePostMessageStream_1 = __webpack_require__(/*! ../BasePostMessageStream */ "./node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js");
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/@metamask/post-message-stream/dist/utils.js");
/**
 * Worker-side dedicated `WebWorker.postMessage` stream. Designed for use with
 * dedicated workers only.
 */
class WebWorkerPostMessageStream extends BasePostMessageStream_1.BasePostMessageStream {
    constructor() {
        // Kudos: https://stackoverflow.com/a/18002694
        if (typeof self === 'undefined' ||
            // @ts-expect-error: No types for WorkerGlobalScope
            typeof WorkerGlobalScope === 'undefined') {
            throw new Error('WorkerGlobalScope not found. This class should only be instantiated in a WebWorker.');
        }
        super();
        this._name = utils_1.DEDICATED_WORKER_NAME;
        self.addEventListener('message', this._onMessage.bind(this));
        this._handshake();
    }
    _postMessage(data) {
        // Cast of self.postMessage due to usage of DOM lib
        self.postMessage({ data });
    }
    _onMessage(event) {
        const message = event.data;
        // validate message
        if (!(0, utils_1.isValidStreamMessage)(message) || message.target !== this._name) {
            return;
        }
        this._onData(message.data);
    }
    // worker stream lifecycle assumed to be coterminous with global scope
    _destroy() {
        return undefined;
    }
}
exports.WebWorkerPostMessageStream = WebWorkerPostMessageStream;


/***/ }),

/***/ "./node_modules/@metamask/post-message-stream/dist/browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/@metamask/post-message-stream/dist/browser.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Exports a subset of functionality for browsers
__exportStar(__webpack_require__(/*! ./window/WindowPostMessageStream */ "./node_modules/@metamask/post-message-stream/dist/window/WindowPostMessageStream.js"), exports);
__exportStar(__webpack_require__(/*! ./WebWorker/WebWorkerPostMessageStream */ "./node_modules/@metamask/post-message-stream/dist/WebWorker/WebWorkerPostMessageStream.js"), exports);
__exportStar(__webpack_require__(/*! ./WebWorker/WebWorkerParentPostMessageStream */ "./node_modules/@metamask/post-message-stream/dist/WebWorker/WebWorkerParentPostMessageStream.js"), exports);
__exportStar(__webpack_require__(/*! ./runtime/BrowserRuntimePostMessageStream */ "./node_modules/@metamask/post-message-stream/dist/runtime/BrowserRuntimePostMessageStream.js"), exports);
__exportStar(__webpack_require__(/*! ./BasePostMessageStream */ "./node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js"), exports);


/***/ }),

/***/ "./node_modules/@metamask/post-message-stream/dist/runtime/BrowserRuntimePostMessageStream.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/post-message-stream/dist/runtime/BrowserRuntimePostMessageStream.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BrowserRuntimePostMessageStream_name, _BrowserRuntimePostMessageStream_target;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserRuntimePostMessageStream = void 0;
const BasePostMessageStream_1 = __webpack_require__(/*! ../BasePostMessageStream */ "./node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js");
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/@metamask/post-message-stream/dist/utils.js");
/**
 * A {@link browser.runtime} stream.
 */
class BrowserRuntimePostMessageStream extends BasePostMessageStream_1.BasePostMessageStream {
    /**
     * Creates a stream for communicating with other streams across the extension
     * runtime.
     *
     * @param args - Options bag.
     * @param args.name - The name of the stream. Used to differentiate between
     * multiple streams sharing the same runtime.
     * @param args.target - The name of the stream to exchange messages with.
     */
    constructor({ name, target }) {
        super();
        _BrowserRuntimePostMessageStream_name.set(this, void 0);
        _BrowserRuntimePostMessageStream_target.set(this, void 0);
        __classPrivateFieldSet(this, _BrowserRuntimePostMessageStream_name, name, "f");
        __classPrivateFieldSet(this, _BrowserRuntimePostMessageStream_target, target, "f");
        this._onMessage = this._onMessage.bind(this);
        this._getRuntime().onMessage.addListener(this._onMessage);
        this._handshake();
    }
    _postMessage(data) {
        // This returns a Promise, which resolves if the receiver responds to the
        // message. Rather than responding to specific messages, we send new
        // messages in response to incoming messages, so we don't care about the
        // Promise.
        this._getRuntime().sendMessage({
            target: __classPrivateFieldGet(this, _BrowserRuntimePostMessageStream_target, "f"),
            data,
        });
    }
    _onMessage(message) {
        if (!(0, utils_1.isValidStreamMessage)(message) || message.target !== __classPrivateFieldGet(this, _BrowserRuntimePostMessageStream_name, "f")) {
            return;
        }
        this._onData(message.data);
    }
    _getRuntime() {
        var _a, _b;
        if ('chrome' in globalThis &&
            typeof ((_a = chrome === null || chrome === void 0 ? void 0 : chrome.runtime) === null || _a === void 0 ? void 0 : _a.sendMessage) === 'function') {
            return chrome.runtime;
        }
        if ('browser' in globalThis &&
            typeof ((_b = browser === null || browser === void 0 ? void 0 : browser.runtime) === null || _b === void 0 ? void 0 : _b.sendMessage) === 'function') {
            return browser.runtime;
        }
        throw new Error('browser.runtime.sendMessage is not a function. This class should only be instantiated in a web extension.');
    }
    _destroy() {
        this._getRuntime().onMessage.removeListener(this._onMessage);
    }
}
exports.BrowserRuntimePostMessageStream = BrowserRuntimePostMessageStream;
_BrowserRuntimePostMessageStream_name = new WeakMap(), _BrowserRuntimePostMessageStream_target = new WeakMap();


/***/ }),

/***/ "./node_modules/@metamask/post-message-stream/dist/utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@metamask/post-message-stream/dist/utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidStreamMessage = exports.DEDICATED_WORKER_NAME = void 0;
const utils_1 = __webpack_require__(/*! @metamask/utils */ "./node_modules/@metamask/utils/dist/index.js");
exports.DEDICATED_WORKER_NAME = 'dedicatedWorker';
/**
 * Checks whether the specified stream event message is valid per the
 * expectations of this library.
 *
 * @param message - The stream event message property.
 * @returns Whether the `message` is a valid stream message.
 */
function isValidStreamMessage(message) {
    return ((0, utils_1.isObject)(message) &&
        Boolean(message.data) &&
        (typeof message.data === 'number' ||
            typeof message.data === 'object' ||
            typeof message.data === 'string'));
}
exports.isValidStreamMessage = isValidStreamMessage;


/***/ }),

/***/ "./node_modules/@metamask/post-message-stream/dist/window/WindowPostMessageStream.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@metamask/post-message-stream/dist/window/WindowPostMessageStream.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowPostMessageStream = void 0;
const utils_1 = __webpack_require__(/*! @metamask/utils */ "./node_modules/@metamask/utils/dist/index.js");
const BasePostMessageStream_1 = __webpack_require__(/*! ../BasePostMessageStream */ "./node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js");
const utils_2 = __webpack_require__(/*! ../utils */ "./node_modules/@metamask/post-message-stream/dist/utils.js");
/* istanbul ignore next */
const getSource = (_a = Object.getOwnPropertyDescriptor(MessageEvent.prototype, 'source')) === null || _a === void 0 ? void 0 : _a.get;
(0, utils_1.assert)(getSource, 'MessageEvent.prototype.source getter is not defined.');
/* istanbul ignore next */
const getOrigin = (_b = Object.getOwnPropertyDescriptor(MessageEvent.prototype, 'origin')) === null || _b === void 0 ? void 0 : _b.get;
(0, utils_1.assert)(getOrigin, 'MessageEvent.prototype.origin getter is not defined.');
/**
 * A {@link Window.postMessage} stream.
 */
class WindowPostMessageStream extends BasePostMessageStream_1.BasePostMessageStream {
    /**
     * Creates a stream for communicating with other streams across the same or
     * different `window` objects.
     *
     * @param args - Options bag.
     * @param args.name - The name of the stream. Used to differentiate between
     * multiple streams sharing the same window object.
     * @param args.target - The name of the stream to exchange messages with.
     * @param args.targetOrigin - The origin of the target. Defaults to
     * `location.origin`, '*' is permitted.
     * @param args.targetWindow - The window object of the target stream. Defaults
     * to `window`.
     */
    constructor({ name, target, targetOrigin = location.origin, targetWindow = window, }) {
        super();
        if (typeof window === 'undefined' ||
            typeof window.postMessage !== 'function') {
            throw new Error('window.postMessage is not a function. This class should only be instantiated in a Window.');
        }
        this._name = name;
        this._target = target;
        this._targetOrigin = targetOrigin;
        this._targetWindow = targetWindow;
        this._onMessage = this._onMessage.bind(this);
        window.addEventListener('message', this._onMessage, false);
        this._handshake();
    }
    _postMessage(data) {
        this._targetWindow.postMessage({
            target: this._target,
            data,
        }, this._targetOrigin);
    }
    _onMessage(event) {
        const message = event.data;
        /* eslint-disable @typescript-eslint/no-non-null-assertion */
        if ((this._targetOrigin !== '*' &&
            getOrigin.call(event) !== this._targetOrigin) ||
            getSource.call(event) !== this._targetWindow ||
            !(0, utils_2.isValidStreamMessage)(message) ||
            message.target !== this._name) {
            return;
        }
        /* eslint-enable @typescript-eslint/no-non-null-assertion */
        this._onData(message.data);
    }
    _destroy() {
        window.removeEventListener('message', this._onMessage, false);
    }
}
exports.WindowPostMessageStream = WindowPostMessageStream;


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/BaseProvider.js":
/*!***************************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/BaseProvider.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _BaseProvider_chainId, _BaseProvider_selectedAddress;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseProvider = void 0;
const json_rpc_engine_1 = __webpack_require__(/*! @metamask/json-rpc-engine */ "./node_modules/@metamask/json-rpc-engine/dist/index.js");
const rpc_errors_1 = __webpack_require__(/*! @metamask/rpc-errors */ "./node_modules/@metamask/rpc-errors/dist/index.js");
const safe_event_emitter_1 = __importDefault(__webpack_require__(/*! @metamask/safe-event-emitter */ "./node_modules/@metamask/providers/node_modules/@metamask/safe-event-emitter/index.js"));
const fast_deep_equal_1 = __importDefault(__webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js"));
const messages_1 = __importDefault(__webpack_require__(/*! ./messages */ "./node_modules/@metamask/providers/dist/messages.js"));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@metamask/providers/dist/utils.js");
/**
 * An abstract class implementing the EIP-1193 interface. Implementers must:
 *
 * 1. At initialization, push a middleware to the internal `_rpcEngine` that
 * hands off requests to the server and receives responses in return.
 * 2. At initialization, retrieve initial state and call
 * {@link BaseProvider._initializeState} **once**.
 * 3. Ensure that the provider's state is synchronized with the wallet.
 * 4. Ensure that notifications are received and emitted as appropriate.
 */
class BaseProvider extends safe_event_emitter_1.default {
    /**
     * Create a new instance of the provider.
     *
     * @param options - An options bag.
     * @param options.logger - The logging API to use. Default: `console`.
     * @param options.maxEventListeners - The maximum number of event
     * listeners. Default: 100.
     * @param options.rpcMiddleware - The RPC middleware stack. Default: [].
     */
    constructor({ logger = console, maxEventListeners = 100, rpcMiddleware = [], } = {}) {
        super();
        /**
         * The chain ID of the currently connected Ethereum chain.
         * See [chainId.network]{@link https://chainid.network} for more information.
         */
        _BaseProvider_chainId.set(this, void 0);
        /**
         * The user's currently selected Ethereum address.
         * If null, MetaMask is either locked or the user has not permitted any
         * addresses to be viewed.
         */
        _BaseProvider_selectedAddress.set(this, void 0);
        this._log = logger;
        this.setMaxListeners(maxEventListeners);
        // Private state
        this._state = {
            ...BaseProvider._defaultState,
        };
        // Public state
        __classPrivateFieldSet(this, _BaseProvider_selectedAddress, null, "f");
        __classPrivateFieldSet(this, _BaseProvider_chainId, null, "f");
        // Bind functions to prevent consumers from making unbound calls
        this._handleAccountsChanged = this._handleAccountsChanged.bind(this);
        this._handleConnect = this._handleConnect.bind(this);
        this._handleChainChanged = this._handleChainChanged.bind(this);
        this._handleDisconnect = this._handleDisconnect.bind(this);
        this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);
        this._rpcRequest = this._rpcRequest.bind(this);
        this.request = this.request.bind(this);
        // Handle RPC requests via dapp-side RPC engine.
        //
        // ATTN: Implementers must push a middleware that hands off requests to
        // the server.
        const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();
        rpcMiddleware.forEach((middleware) => rpcEngine.push(middleware));
        this._rpcEngine = rpcEngine;
    }
    //====================
    // Public Properties
    //====================
    get chainId() {
        return __classPrivateFieldGet(this, _BaseProvider_chainId, "f");
    }
    get selectedAddress() {
        return __classPrivateFieldGet(this, _BaseProvider_selectedAddress, "f");
    }
    //====================
    // Public Methods
    //====================
    /**
     * Returns whether the provider can process RPC requests.
     *
     * @returns Whether the provider can process RPC requests.
     */
    isConnected() {
        return this._state.isConnected;
    }
    /**
     * Submits an RPC request for the given method, with the given params.
     * Resolves with the result of the method call, or rejects on error.
     *
     * @param args - The RPC request arguments.
     * @param args.method - The RPC method name.
     * @param args.params - The parameters for the RPC method.
     * @returns A Promise that resolves with the result of the RPC method,
     * or rejects if an error is encountered.
     */
    async request(args) {
        if (!args || typeof args !== 'object' || Array.isArray(args)) {
            throw rpc_errors_1.rpcErrors.invalidRequest({
                message: messages_1.default.errors.invalidRequestArgs(),
                data: args,
            });
        }
        const { method, params } = args;
        if (typeof method !== 'string' || method.length === 0) {
            throw rpc_errors_1.rpcErrors.invalidRequest({
                message: messages_1.default.errors.invalidRequestMethod(),
                data: args,
            });
        }
        if (params !== undefined &&
            !Array.isArray(params) &&
            (typeof params !== 'object' || params === null)) {
            throw rpc_errors_1.rpcErrors.invalidRequest({
                message: messages_1.default.errors.invalidRequestParams(),
                data: args,
            });
        }
        const payload = params === undefined || params === null
            ? {
                method,
            }
            : {
                method,
                params,
            };
        return new Promise((resolve, reject) => {
            this._rpcRequest(payload, (0, utils_1.getRpcPromiseCallback)(resolve, reject));
        });
    }
    //====================
    // Private Methods
    //====================
    /**
     * MUST be called by child classes.
     *
     * Sets initial state if provided and marks this provider as initialized.
     * Throws if called more than once.
     *
     * Permits the `networkVersion` field in the parameter object for
     * compatibility with child classes that use this value.
     *
     * @param initialState - The provider's initial state.
     * @param initialState.accounts - The user's accounts.
     * @param initialState.chainId - The chain ID.
     * @param initialState.isUnlocked - Whether the user has unlocked MetaMask.
     * @param initialState.networkVersion - The network version.
     * @fires BaseProvider#_initialized - If `initialState` is defined.
     * @fires BaseProvider#connect - If `initialState` is defined.
     */
    _initializeState(initialState) {
        if (this._state.initialized) {
            throw new Error('Provider already initialized.');
        }
        if (initialState) {
            const { accounts, chainId, isUnlocked, networkVersion } = initialState;
            // EIP-1193 connect
            this._handleConnect(chainId);
            this._handleChainChanged({ chainId, networkVersion });
            this._handleUnlockStateChanged({ accounts, isUnlocked });
            this._handleAccountsChanged(accounts);
        }
        // Mark provider as initialized regardless of whether initial state was
        // retrieved.
        this._state.initialized = true;
        this.emit('_initialized');
    }
    /**
     * Internal RPC method. Forwards requests to background via the RPC engine.
     * Also remap ids inbound and outbound.
     *
     * @param payload - The RPC request object.
     * @param callback - The consumer's callback.
     * @returns The result of the RPC request.
     */
    _rpcRequest(payload, callback) {
        let callbackWrapper = callback;
        if (!Array.isArray(payload)) {
            if (!payload.jsonrpc) {
                payload.jsonrpc = '2.0';
            }
            if (payload.method === 'eth_accounts' ||
                payload.method === 'eth_requestAccounts') {
                // handle accounts changing
                callbackWrapper = (error, response) => {
                    this._handleAccountsChanged(response.result ?? [], payload.method === 'eth_accounts');
                    callback(error, response);
                };
            }
            return this._rpcEngine.handle(payload, callbackWrapper);
        }
        return this._rpcEngine.handle(payload, callbackWrapper);
    }
    /**
     * When the provider becomes connected, updates internal state and emits
     * required events. Idempotent.
     *
     * @param chainId - The ID of the newly connected chain.
     * @fires MetaMaskInpageProvider#connect
     */
    _handleConnect(chainId) {
        if (!this._state.isConnected) {
            this._state.isConnected = true;
            this.emit('connect', { chainId });
            this._log.debug(messages_1.default.info.connected(chainId));
        }
    }
    /**
     * When the provider becomes disconnected, updates internal state and emits
     * required events. Idempotent with respect to the isRecoverable parameter.
     *
     * Error codes per the CloseEvent status codes as required by EIP-1193:
     * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes.
     *
     * @param isRecoverable - Whether the disconnection is recoverable.
     * @param errorMessage - A custom error message.
     * @fires BaseProvider#disconnect - If the disconnection is not recoverable.
     */
    _handleDisconnect(isRecoverable, errorMessage) {
        if (this._state.isConnected ||
            (!this._state.isPermanentlyDisconnected && !isRecoverable)) {
            this._state.isConnected = false;
            let error;
            if (isRecoverable) {
                error = new rpc_errors_1.JsonRpcError(1013, // Try again later
                errorMessage ?? messages_1.default.errors.disconnected());
                this._log.debug(error);
            }
            else {
                error = new rpc_errors_1.JsonRpcError(1011, // Internal error
                errorMessage ?? messages_1.default.errors.permanentlyDisconnected());
                this._log.error(error);
                __classPrivateFieldSet(this, _BaseProvider_chainId, null, "f");
                this._state.accounts = null;
                __classPrivateFieldSet(this, _BaseProvider_selectedAddress, null, "f");
                this._state.isUnlocked = false;
                this._state.isPermanentlyDisconnected = true;
            }
            this.emit('disconnect', error);
        }
    }
    /**
     * Upon receipt of a new `chainId`, emits the corresponding event and sets
     * and sets relevant public state. Does nothing if the given `chainId` is
     * equivalent to the existing value.
     *
     * Permits the `networkVersion` field in the parameter object for
     * compatibility with child classes that use this value.
     *
     * @fires BaseProvider#chainChanged
     * @param networkInfo - An object with network info.
     * @param networkInfo.chainId - The latest chain ID.
     */
    _handleChainChanged({ chainId, } = {}) {
        if (!(0, utils_1.isValidChainId)(chainId)) {
            this._log.error(messages_1.default.errors.invalidNetworkParams(), { chainId });
            return;
        }
        this._handleConnect(chainId);
        if (chainId !== __classPrivateFieldGet(this, _BaseProvider_chainId, "f")) {
            __classPrivateFieldSet(this, _BaseProvider_chainId, chainId, "f");
            if (this._state.initialized) {
                this.emit('chainChanged', __classPrivateFieldGet(this, _BaseProvider_chainId, "f"));
            }
        }
    }
    /**
     * Called when accounts may have changed. Diffs the new accounts value with
     * the current one, updates all state as necessary, and emits the
     * accountsChanged event.
     *
     * @param accounts - The new accounts value.
     * @param isEthAccounts - Whether the accounts value was returned by
     * a call to eth_accounts.
     */
    _handleAccountsChanged(accounts, isEthAccounts = false) {
        let _accounts = accounts;
        if (!Array.isArray(accounts)) {
            this._log.error('MetaMask: Received invalid accounts parameter. Please report this bug.', accounts);
            _accounts = [];
        }
        for (const account of accounts) {
            if (typeof account !== 'string') {
                this._log.error('MetaMask: Received non-string account. Please report this bug.', accounts);
                _accounts = [];
                break;
            }
        }
        // emit accountsChanged if anything about the accounts array has changed
        if (!(0, fast_deep_equal_1.default)(this._state.accounts, _accounts)) {
            // we should always have the correct accounts even before eth_accounts
            // returns
            if (isEthAccounts && this._state.accounts !== null) {
                this._log.error(`MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.`, _accounts);
            }
            this._state.accounts = _accounts;
            // handle selectedAddress
            if (__classPrivateFieldGet(this, _BaseProvider_selectedAddress, "f") !== _accounts[0]) {
                __classPrivateFieldSet(this, _BaseProvider_selectedAddress, _accounts[0] || null, "f");
            }
            // finally, after all state has been updated, emit the event
            if (this._state.initialized) {
                const _nextAccounts = [..._accounts];
                this.emit('accountsChanged', _nextAccounts);
            }
        }
    }
    /**
     * Upon receipt of a new isUnlocked state, sets relevant public state.
     * Calls the accounts changed handler with the received accounts, or an empty
     * array.
     *
     * Does nothing if the received value is equal to the existing value.
     * There are no lock/unlock events.
     *
     * @param opts - Options bag.
     * @param opts.accounts - The exposed accounts, if any.
     * @param opts.isUnlocked - The latest isUnlocked value.
     */
    _handleUnlockStateChanged({ accounts, isUnlocked, } = {}) {
        if (typeof isUnlocked !== 'boolean') {
            this._log.error('MetaMask: Received invalid isUnlocked parameter. Please report this bug.');
            return;
        }
        if (isUnlocked !== this._state.isUnlocked) {
            this._state.isUnlocked = isUnlocked;
            this._handleAccountsChanged(accounts ?? []);
        }
    }
}
exports.BaseProvider = BaseProvider;
_BaseProvider_chainId = new WeakMap(), _BaseProvider_selectedAddress = new WeakMap();
BaseProvider._defaultState = {
    accounts: null,
    isConnected: false,
    isUnlocked: false,
    initialized: false,
    isPermanentlyDisconnected: false,
};


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/EIP6963.js":
/*!**********************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/EIP6963.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.announceProvider = exports.requestProvider = void 0;
const utils_1 = __webpack_require__(/*! @metamask/utils */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/index.js");
/**
 * Describes the possible EIP-6963 event names
 */
var EIP6963EventNames;
(function (EIP6963EventNames) {
    EIP6963EventNames["Announce"] = "eip6963:announceProvider";
    EIP6963EventNames["Request"] = "eip6963:requestProvider";
})(EIP6963EventNames || (EIP6963EventNames = {}));
// https://github.com/thenativeweb/uuidv4/blob/bdcf3a3138bef4fb7c51f389a170666f9012c478/lib/uuidv4.ts#L5
const UUID_V4_REGEX = /(?:^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}$)|(?:^0{8}-0{4}-0{4}-0{4}-0{12}$)/u;
// https://stackoverflow.com/a/20204811
const FQDN_REGEX = /(?=^.{4,253}$)(^((?!-)[a-zA-Z0-9-]{0,62}[a-zA-Z0-9]\.)+[a-zA-Z]{2,63}$)/u;
/**
 * Intended to be used by a dapp. Forwards every announced provider to the
 * provided handler by listening for * {@link EIP6963AnnounceProviderEvent},
 * and dispatches an {@link EIP6963RequestProviderEvent}.
 *
 * @param handleProvider - A function that handles an announced provider.
 */
function requestProvider(handleProvider) {
    window.addEventListener(EIP6963EventNames.Announce, (event) => {
        if (!isValidAnnounceProviderEvent(event)) {
            throwErrorEIP6963(`Invalid EIP-6963 AnnounceProviderEvent object received from ${EIP6963EventNames.Announce} event.`);
        }
        handleProvider(event.detail);
    });
    window.dispatchEvent(new Event(EIP6963EventNames.Request));
}
exports.requestProvider = requestProvider;
/**
 * Intended to be used by a wallet. Announces a provider by dispatching
 * an {@link EIP6963AnnounceProviderEvent}, and listening for
 * {@link EIP6963RequestProviderEvent} to re-announce.
 *
 * @throws If the {@link EIP6963ProviderDetail} is invalid.
 * @param providerDetail - The {@link EIP6963ProviderDetail} to announce.
 * @param providerDetail.info - The {@link EIP6963ProviderInfo} to announce.
 * @param providerDetail.provider - The provider to announce.
 */
function announceProvider(providerDetail) {
    if (!isValidProviderDetail(providerDetail)) {
        throwErrorEIP6963('Invalid EIP-6963 ProviderDetail object.');
    }
    const { info, provider } = providerDetail;
    const _announceProvider = () => window.dispatchEvent(new CustomEvent(EIP6963EventNames.Announce, {
        detail: Object.freeze({ info: { ...info }, provider }),
    }));
    _announceProvider();
    window.addEventListener(EIP6963EventNames.Request, (event) => {
        if (!isValidRequestProviderEvent(event)) {
            throwErrorEIP6963(`Invalid EIP-6963 RequestProviderEvent object received from ${EIP6963EventNames.Request} event.`);
        }
        _announceProvider();
    });
}
exports.announceProvider = announceProvider;
/**
 * Validates an {@link EIP6963RequestProviderEvent} object.
 *
 * @param event - The {@link EIP6963RequestProviderEvent} to validate.
 * @returns Whether the {@link EIP6963RequestProviderEvent} is valid.
 */
function isValidRequestProviderEvent(event) {
    return event instanceof Event && event.type === EIP6963EventNames.Request;
}
/**
 * Validates an {@link EIP6963AnnounceProviderEvent} object.
 *
 * @param event - The {@link EIP6963AnnounceProviderEvent} to validate.
 * @returns Whether the {@link EIP6963AnnounceProviderEvent} is valid.
 */
function isValidAnnounceProviderEvent(event) {
    return (event instanceof CustomEvent &&
        event.type === EIP6963EventNames.Announce &&
        Object.isFrozen(event.detail) &&
        isValidProviderDetail(event.detail));
}
/**
 * Validates an {@link EIP6963ProviderDetail} object.
 *
 * @param providerDetail - The {@link EIP6963ProviderDetail} to validate.
 * @returns Whether the {@link EIP6963ProviderDetail} is valid.
 */
function isValidProviderDetail(providerDetail) {
    if (!(0, utils_1.isObject)(providerDetail) ||
        !(0, utils_1.isObject)(providerDetail.info) ||
        !(0, utils_1.isObject)(providerDetail.provider)) {
        return false;
    }
    const { info } = providerDetail;
    return (typeof info.uuid === 'string' &&
        UUID_V4_REGEX.test(info.uuid) &&
        typeof info.name === 'string' &&
        Boolean(info.name) &&
        typeof info.icon === 'string' &&
        info.icon.startsWith('data:image') &&
        typeof info.rdns === 'string' &&
        FQDN_REGEX.test(info.rdns));
}
/**
 * Throws an error with link to EIP-6963 specifications.
 *
 * @param message - The message to include.
 * @throws a friendly error with a link to EIP-6963.
 */
function throwErrorEIP6963(message) {
    throw new Error(`${message} See https://eips.ethereum.org/EIPS/eip-6963 for requirements.`);
}


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/MetaMaskInpageProvider.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/MetaMaskInpageProvider.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _MetaMaskInpageProvider_networkVersion;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetaMaskInpageProvider = exports.MetaMaskInpageProviderStreamName = void 0;
const rpc_errors_1 = __webpack_require__(/*! @metamask/rpc-errors */ "./node_modules/@metamask/rpc-errors/dist/index.js");
const messages_1 = __importDefault(__webpack_require__(/*! ./messages */ "./node_modules/@metamask/providers/dist/messages.js"));
const siteMetadata_1 = __webpack_require__(/*! ./siteMetadata */ "./node_modules/@metamask/providers/dist/siteMetadata.js");
const StreamProvider_1 = __webpack_require__(/*! ./StreamProvider */ "./node_modules/@metamask/providers/dist/StreamProvider.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@metamask/providers/dist/utils.js");
/**
 * The name of the stream consumed by {@link MetaMaskInpageProvider}.
 */
exports.MetaMaskInpageProviderStreamName = 'metamask-provider';
class MetaMaskInpageProvider extends StreamProvider_1.AbstractStreamProvider {
    /**
     * Creates a new `MetaMaskInpageProvider`.
     *
     * @param connectionStream - A Node.js duplex stream.
     * @param options - An options bag.
     * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.
     * Default: `metamask-provider`.
     * @param options.logger - The logging API to use. Default: `console`.
     * @param options.maxEventListeners - The maximum number of event
     * listeners. Default: 100.
     * @param options.shouldSendMetadata - Whether the provider should
     * send page metadata. Default: `true`.
     */
    constructor(connectionStream, { jsonRpcStreamName = exports.MetaMaskInpageProviderStreamName, logger = console, maxEventListeners = 100, shouldSendMetadata, } = {}) {
        super(connectionStream, {
            jsonRpcStreamName,
            logger,
            maxEventListeners,
            rpcMiddleware: (0, utils_1.getDefaultExternalMiddleware)(logger),
        });
        this._sentWarnings = {
            // properties
            chainId: false,
            networkVersion: false,
            selectedAddress: false,
            // methods
            enable: false,
            experimentalMethods: false,
            send: false,
            // events
            events: {
                close: false,
                data: false,
                networkChanged: false,
                notification: false,
            },
        };
        _MetaMaskInpageProvider_networkVersion.set(this, void 0);
        // We shouldn't perform asynchronous work in the constructor, but at one
        // point we started doing so, and changing this class isn't worth it at
        // the time of writing.
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._initializeStateAsync();
        __classPrivateFieldSet(this, _MetaMaskInpageProvider_networkVersion, null, "f");
        this.isMetaMask = true;
        this._sendSync = this._sendSync.bind(this);
        this.enable = this.enable.bind(this);
        this.send = this.send.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        this._warnOfDeprecation = this._warnOfDeprecation.bind(this);
        this._metamask = this._getExperimentalApi();
        // handle JSON-RPC notifications
        this._jsonRpcConnection.events.on('notification', (payload) => {
            const { method } = payload;
            if (utils_1.EMITTED_NOTIFICATIONS.includes(method)) {
                // deprecated
                // emitted here because that was the original order
                this.emit('data', payload);
                // deprecated
                this.emit('notification', payload.params.result);
            }
        });
        // send website metadata
        if (shouldSendMetadata) {
            if (document.readyState === 'complete') {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                (0, siteMetadata_1.sendSiteMetadata)(this._rpcEngine, this._log);
            }
            else {
                const domContentLoadedHandler = () => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    (0, siteMetadata_1.sendSiteMetadata)(this._rpcEngine, this._log);
                    window.removeEventListener('DOMContentLoaded', domContentLoadedHandler);
                };
                window.addEventListener('DOMContentLoaded', domContentLoadedHandler);
            }
        }
    }
    //====================
    // Deprecated Properties
    //====================
    get chainId() {
        if (!this._sentWarnings.chainId) {
            this._log.warn(messages_1.default.warnings.chainIdDeprecation);
            this._sentWarnings.chainId = true;
        }
        return super.chainId;
    }
    get networkVersion() {
        if (!this._sentWarnings.networkVersion) {
            this._log.warn(messages_1.default.warnings.networkVersionDeprecation);
            this._sentWarnings.networkVersion = true;
        }
        return __classPrivateFieldGet(this, _MetaMaskInpageProvider_networkVersion, "f");
    }
    get selectedAddress() {
        if (!this._sentWarnings.selectedAddress) {
            this._log.warn(messages_1.default.warnings.selectedAddressDeprecation);
            this._sentWarnings.selectedAddress = true;
        }
        return super.selectedAddress;
    }
    //====================
    // Public Methods
    //====================
    /**
     * Submits an RPC request per the given JSON-RPC request object.
     *
     * @param payload - The RPC request object.
     * @param callback - The callback function.
     */
    sendAsync(payload, callback) {
        this._rpcRequest(payload, callback);
    }
    /**
     * We override the following event methods so that we can warn consumers
     * about deprecated events:
     * `addListener`, `on`, `once`, `prependListener`, `prependOnceListener`.
     */
    addListener(eventName, listener) {
        this._warnOfDeprecation(eventName);
        return super.addListener(eventName, listener);
    }
    on(eventName, listener) {
        this._warnOfDeprecation(eventName);
        return super.on(eventName, listener);
    }
    once(eventName, listener) {
        this._warnOfDeprecation(eventName);
        return super.once(eventName, listener);
    }
    prependListener(eventName, listener) {
        this._warnOfDeprecation(eventName);
        return super.prependListener(eventName, listener);
    }
    prependOnceListener(eventName, listener) {
        this._warnOfDeprecation(eventName);
        return super.prependOnceListener(eventName, listener);
    }
    //====================
    // Private Methods
    //====================
    /**
     * When the provider becomes disconnected, updates internal state and emits
     * required events. Idempotent with respect to the isRecoverable parameter.
     *
     * Error codes per the CloseEvent status codes as required by EIP-1193:
     * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes.
     *
     * @param isRecoverable - Whether the disconnection is recoverable.
     * @param errorMessage - A custom error message.
     * @fires BaseProvider#disconnect - If the disconnection is not recoverable.
     */
    _handleDisconnect(isRecoverable, errorMessage) {
        super._handleDisconnect(isRecoverable, errorMessage);
        if (__classPrivateFieldGet(this, _MetaMaskInpageProvider_networkVersion, "f") && !isRecoverable) {
            __classPrivateFieldSet(this, _MetaMaskInpageProvider_networkVersion, null, "f");
        }
    }
    /**
     * Warns of deprecation for the given event, if applicable.
     *
     * @param eventName - The name of the event.
     */
    _warnOfDeprecation(eventName) {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-boolean-literal-compare
        if (this._sentWarnings?.events[eventName] === false) {
            this._log.warn(messages_1.default.warnings.events[eventName]);
            this._sentWarnings.events[eventName] = true;
        }
    }
    //====================
    // Deprecated Methods
    //====================
    /**
     * Equivalent to: `ethereum.request('eth_requestAccounts')`.
     *
     * @deprecated Use request({ method: 'eth_requestAccounts' }) instead.
     * @returns A promise that resolves to an array of addresses.
     */
    async enable() {
        if (!this._sentWarnings.enable) {
            this._log.warn(messages_1.default.warnings.enableDeprecation);
            this._sentWarnings.enable = true;
        }
        return new Promise((resolve, reject) => {
            try {
                this._rpcRequest({ method: 'eth_requestAccounts', params: [] }, (0, utils_1.getRpcPromiseCallback)(resolve, reject));
            }
            catch (error) {
                reject(error);
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    send(methodOrPayload, callbackOrArgs) {
        if (!this._sentWarnings.send) {
            this._log.warn(messages_1.default.warnings.sendDeprecation);
            this._sentWarnings.send = true;
        }
        if (typeof methodOrPayload === 'string' &&
            (!callbackOrArgs || Array.isArray(callbackOrArgs))) {
            return new Promise((resolve, reject) => {
                try {
                    this._rpcRequest({ method: methodOrPayload, params: callbackOrArgs }, (0, utils_1.getRpcPromiseCallback)(resolve, reject, false));
                }
                catch (error) {
                    reject(error);
                }
            });
        }
        else if (methodOrPayload &&
            typeof methodOrPayload === 'object' &&
            typeof callbackOrArgs === 'function') {
            return this._rpcRequest(methodOrPayload, callbackOrArgs);
        }
        return this._sendSync(methodOrPayload);
    }
    /**
     * Internal backwards compatibility method, used in send.
     *
     * @param payload - A JSON-RPC request object.
     * @returns A JSON-RPC response object.
     * @deprecated
     */
    _sendSync(payload) {
        let result;
        switch (payload.method) {
            case 'eth_accounts':
                result = this.selectedAddress ? [this.selectedAddress] : [];
                break;
            case 'eth_coinbase':
                result = this.selectedAddress ?? null;
                break;
            case 'eth_uninstallFilter':
                this._rpcRequest(payload, utils_1.NOOP);
                result = true;
                break;
            case 'net_version':
                result = __classPrivateFieldGet(this, _MetaMaskInpageProvider_networkVersion, "f") ?? null;
                break;
            default:
                throw new Error(messages_1.default.errors.unsupportedSync(payload.method));
        }
        return {
            id: payload.id,
            jsonrpc: payload.jsonrpc,
            result,
        };
    }
    /**
     * Constructor helper.
     *
     * Gets the experimental _metamask API as Proxy, so that we can warn consumers
     * about its experimental nature.
     *
     * @returns The experimental _metamask API.
     */
    _getExperimentalApi() {
        return new Proxy({
            /**
             * Determines if MetaMask is unlocked by the user.
             *
             * @returns Promise resolving to true if MetaMask is currently unlocked.
             */
            isUnlocked: async () => {
                if (!this._state.initialized) {
                    await new Promise((resolve) => {
                        this.on('_initialized', () => resolve());
                    });
                }
                return this._state.isUnlocked;
            },
            /**
             * Make a batch RPC request.
             *
             * @param requests - The RPC requests to make.
             */
            requestBatch: async (requests) => {
                if (!Array.isArray(requests)) {
                    throw rpc_errors_1.rpcErrors.invalidRequest({
                        message: 'Batch requests must be made with an array of request objects.',
                        data: requests,
                    });
                }
                return new Promise((resolve, reject) => {
                    this._rpcRequest(requests, (0, utils_1.getRpcPromiseCallback)(resolve, reject));
                });
            },
        }, {
            get: (obj, prop, ...args) => {
                if (!this._sentWarnings.experimentalMethods) {
                    this._log.warn(messages_1.default.warnings.experimentalMethods);
                    this._sentWarnings.experimentalMethods = true;
                }
                return Reflect.get(obj, prop, ...args);
            },
        });
    }
    /**
     * Upon receipt of a new chainId and networkVersion, emits corresponding
     * events and sets relevant public state. Does nothing if neither the chainId
     * nor the networkVersion are different from existing values.
     *
     * @fires MetamaskInpageProvider#networkChanged
     * @param networkInfo - An object with network info.
     * @param networkInfo.chainId - The latest chain ID.
     * @param networkInfo.networkVersion - The latest network ID.
     */
    _handleChainChanged({ chainId, networkVersion, } = {}) {
        // This will validate the params and disconnect the provider if the
        // networkVersion is 'loading'.
        super._handleChainChanged({ chainId, networkVersion });
        if (this._state.isConnected && networkVersion !== __classPrivateFieldGet(this, _MetaMaskInpageProvider_networkVersion, "f")) {
            __classPrivateFieldSet(this, _MetaMaskInpageProvider_networkVersion, networkVersion, "f");
            if (this._state.initialized) {
                this.emit('networkChanged', __classPrivateFieldGet(this, _MetaMaskInpageProvider_networkVersion, "f"));
            }
        }
    }
}
exports.MetaMaskInpageProvider = MetaMaskInpageProvider;
_MetaMaskInpageProvider_networkVersion = new WeakMap();


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/StreamProvider.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/StreamProvider.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamProvider = exports.AbstractStreamProvider = void 0;
const object_multiplex_1 = __importDefault(__webpack_require__(/*! @metamask/object-multiplex */ "./node_modules/@metamask/providers/node_modules/@metamask/object-multiplex/dist/index.js"));
const is_stream_1 = __webpack_require__(/*! is-stream */ "./node_modules/is-stream/index.js");
const json_rpc_middleware_stream_1 = __webpack_require__(/*! json-rpc-middleware-stream */ "./node_modules/@metamask/providers/node_modules/json-rpc-middleware-stream/dist/index.js");
const readable_stream_1 = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");
const BaseProvider_1 = __webpack_require__(/*! ./BaseProvider */ "./node_modules/@metamask/providers/dist/BaseProvider.js");
const messages_1 = __importDefault(__webpack_require__(/*! ./messages */ "./node_modules/@metamask/providers/dist/messages.js"));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@metamask/providers/dist/utils.js");
/**
 * An abstract EIP-1193 provider wired to some duplex stream via a
 * `json-rpc-middleware-stream` JSON-RPC stream middleware. Implementers must
 * call {@link AbstractStreamProvider._initializeStateAsync} after instantiation
 * to initialize the provider's state.
 */
class AbstractStreamProvider extends BaseProvider_1.BaseProvider {
    /**
     * Creates a new AbstractStreamProvider instance.
     *
     * @param connectionStream - A Node.js duplex stream.
     * @param options - An options bag.
     * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.
     * @param options.logger - The logging API to use. Default: `console`.
     * @param options.maxEventListeners - The maximum number of event
     * listeners. Default: 100.
     * @param options.rpcMiddleware - The RPC middleware stack to use.
     */
    constructor(connectionStream, { jsonRpcStreamName, logger = console, maxEventListeners = 100, rpcMiddleware = [], }) {
        super({ logger, maxEventListeners, rpcMiddleware });
        if (!(0, is_stream_1.duplex)(connectionStream)) {
            throw new Error(messages_1.default.errors.invalidDuplexStream());
        }
        // Bind functions to prevent consumers from making unbound calls
        this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
        // Set up connectionStream multiplexing
        const mux = new object_multiplex_1.default();
        (0, readable_stream_1.pipeline)(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, 'MetaMask'));
        // Set up RPC connection
        // Typecast: The type of `Duplex` is incompatible with the type of
        // `JsonRpcConnection`.
        this._jsonRpcConnection = (0, json_rpc_middleware_stream_1.createStreamMiddleware)({
            retryOnMessage: 'METAMASK_EXTENSION_CONNECT_CAN_RETRY',
        });
        (0, readable_stream_1.pipeline)(this._jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), this._jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, 'MetaMask RpcProvider'));
        // Wire up the JsonRpcEngine to the JSON-RPC connection stream
        this._rpcEngine.push(this._jsonRpcConnection.middleware);
        // Handle JSON-RPC notifications
        this._jsonRpcConnection.events.on('notification', (payload) => {
            const { method, params } = payload;
            if (method === 'metamask_accountsChanged') {
                this._handleAccountsChanged(params);
            }
            else if (method === 'metamask_unlockStateChanged') {
                this._handleUnlockStateChanged(params);
            }
            else if (method === 'metamask_chainChanged') {
                this._handleChainChanged(params);
            }
            else if (utils_1.EMITTED_NOTIFICATIONS.includes(method)) {
                this.emit('message', {
                    type: method,
                    data: params,
                });
            }
            else if (method === 'METAMASK_STREAM_FAILURE') {
                connectionStream.destroy(new Error(messages_1.default.errors.permanentlyDisconnected()));
            }
        });
    }
    //====================
    // Private Methods
    //====================
    /**
     * MUST be called by child classes.
     *
     * Calls `metamask_getProviderState` and passes the result to
     * {@link BaseProvider._initializeState}. Logs an error if getting initial state
     * fails. Throws if called after initialization has completed.
     */
    async _initializeStateAsync() {
        let initialState;
        try {
            initialState = (await this.request({
                method: 'metamask_getProviderState',
            }));
        }
        catch (error) {
            this._log.error('MetaMask: Failed to get initial state. Please report this bug.', error);
        }
        this._initializeState(initialState);
    }
    /**
     * Called when connection is lost to critical streams. Emits an 'error' event
     * from the provider with the error message and stack if present.
     *
     * @param streamName - The name of the stream that disconnected.
     * @param error - The error that caused the disconnection.
     * @fires BaseProvider#disconnect - If the provider is not already
     * disconnected.
     */
    // eslint-disable-next-line no-restricted-syntax
    _handleStreamDisconnect(streamName, error) {
        let warningMsg = `MetaMask: Lost connection to "${streamName}".`;
        if (error?.stack) {
            warningMsg += `\n${error.stack}`;
        }
        this._log.warn(warningMsg);
        if (this.listenerCount('error') > 0) {
            this.emit('error', warningMsg);
        }
        this._handleDisconnect(false, error ? error.message : undefined);
    }
    /**
     * Upon receipt of a new chainId and networkVersion, emits corresponding
     * events and sets relevant public state. This class does not have a
     * `networkVersion` property, but we rely on receiving a `networkVersion`
     * with the value of `loading` to detect when the network is changing and
     * a recoverable `disconnect` even has occurred. Child classes that use the
     * `networkVersion` for other purposes must implement additional handling
     * therefore.
     *
     * @fires BaseProvider#chainChanged
     * @param networkInfo - An object with network info.
     * @param networkInfo.chainId - The latest chain ID.
     * @param networkInfo.networkVersion - The latest network ID.
     */
    _handleChainChanged({ chainId, networkVersion, } = {}) {
        if (!(0, utils_1.isValidChainId)(chainId) || !(0, utils_1.isValidNetworkVersion)(networkVersion)) {
            this._log.error(messages_1.default.errors.invalidNetworkParams(), {
                chainId,
                networkVersion,
            });
            return;
        }
        if (networkVersion === 'loading') {
            this._handleDisconnect(true);
        }
        else {
            super._handleChainChanged({ chainId });
        }
    }
}
exports.AbstractStreamProvider = AbstractStreamProvider;
/**
 * An EIP-1193 provider wired to some duplex stream via a
 * `json-rpc-middleware-stream` JSON-RPC stream middleware. Consumers must
 * call {@link StreamProvider.initialize} after instantiation to complete
 * initialization.
 */
class StreamProvider extends AbstractStreamProvider {
    /**
     * MUST be called after instantiation to complete initialization.
     *
     * Calls `metamask_getProviderState` and passes the result to
     * {@link BaseProvider._initializeState}. Logs an error if getting initial state
     * fails. Throws if called after initialization has completed.
     */
    async initialize() {
        return this._initializeStateAsync();
    }
}
exports.StreamProvider = StreamProvider;


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/constants.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ERC20 = exports.ERC1155 = exports.ERC721 = void 0;
// TOKEN STANDARDS
exports.ERC721 = 'ERC721';
exports.ERC1155 = 'ERC1155';
exports.ERC20 = 'ERC20';


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/extension-provider/createExternalExtensionProvider.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/extension-provider/createExternalExtensionProvider.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createExternalExtensionProvider = void 0;
const detect_browser_1 = __webpack_require__(/*! detect-browser */ "./node_modules/@metamask/providers/node_modules/detect-browser/es/index.js");
const extension_port_stream_1 = __importDefault(__webpack_require__(/*! extension-port-stream */ "./node_modules/@metamask/providers/node_modules/extension-port-stream/dist/index.js"));
const external_extension_config_json_1 = __importDefault(__webpack_require__(/*! ./external-extension-config.json */ "./node_modules/@metamask/providers/dist/extension-provider/external-extension-config.json"));
const MetaMaskInpageProvider_1 = __webpack_require__(/*! ../MetaMaskInpageProvider */ "./node_modules/@metamask/providers/dist/MetaMaskInpageProvider.js");
const StreamProvider_1 = __webpack_require__(/*! ../StreamProvider */ "./node_modules/@metamask/providers/dist/StreamProvider.js");
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/@metamask/providers/dist/utils.js");
const browser = (0, detect_browser_1.detect)();
/**
 * Creates an external extension provider for the given extension type or ID.
 *
 * @param typeOrId - The extension type or ID.
 * @returns The external extension provider.
 */
function createExternalExtensionProvider(typeOrId = 'stable') {
    let provider;
    try {
        const extensionId = getExtensionId(typeOrId);
        const metamaskPort = chrome.runtime.connect(extensionId);
        const pluginStream = new extension_port_stream_1.default(metamaskPort);
        provider = new StreamProvider_1.StreamProvider(pluginStream, {
            jsonRpcStreamName: MetaMaskInpageProvider_1.MetaMaskInpageProviderStreamName,
            logger: console,
            rpcMiddleware: (0, utils_1.getDefaultExternalMiddleware)(console),
        });
        // This is asynchronous but merely logs an error and does not throw upon
        // failure. Previously this just happened as a side-effect in the
        // constructor.
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        provider.initialize();
    }
    catch (error) {
        console.dir(`MetaMask connect error.`, error);
        throw error;
    }
    return provider;
}
exports.createExternalExtensionProvider = createExternalExtensionProvider;
/**
 * Gets the extension ID for the given extension type or ID.
 *
 * @param typeOrId - The extension type or ID.
 * @returns The extension ID.
 */
function getExtensionId(typeOrId) {
    const ids = browser?.name === 'firefox' ? external_extension_config_json_1.default.firefoxIds : external_extension_config_json_1.default.chromeIds;
    return ids[typeOrId] ?? typeOrId;
}


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.eip6963RequestProvider = exports.eip6963AnnounceProvider = exports.StreamProvider = exports.shimWeb3 = exports.setGlobalProvider = exports.MetaMaskInpageProvider = exports.MetaMaskInpageProviderStreamName = exports.initializeProvider = exports.createExternalExtensionProvider = exports.BaseProvider = void 0;
const BaseProvider_1 = __webpack_require__(/*! ./BaseProvider */ "./node_modules/@metamask/providers/dist/BaseProvider.js");
Object.defineProperty(exports, "BaseProvider", ({ enumerable: true, get: function () { return BaseProvider_1.BaseProvider; } }));
const EIP6963_1 = __webpack_require__(/*! ./EIP6963 */ "./node_modules/@metamask/providers/dist/EIP6963.js");
Object.defineProperty(exports, "eip6963AnnounceProvider", ({ enumerable: true, get: function () { return EIP6963_1.announceProvider; } }));
Object.defineProperty(exports, "eip6963RequestProvider", ({ enumerable: true, get: function () { return EIP6963_1.requestProvider; } }));
const createExternalExtensionProvider_1 = __webpack_require__(/*! ./extension-provider/createExternalExtensionProvider */ "./node_modules/@metamask/providers/dist/extension-provider/createExternalExtensionProvider.js");
Object.defineProperty(exports, "createExternalExtensionProvider", ({ enumerable: true, get: function () { return createExternalExtensionProvider_1.createExternalExtensionProvider; } }));
const initializeInpageProvider_1 = __webpack_require__(/*! ./initializeInpageProvider */ "./node_modules/@metamask/providers/dist/initializeInpageProvider.js");
Object.defineProperty(exports, "initializeProvider", ({ enumerable: true, get: function () { return initializeInpageProvider_1.initializeProvider; } }));
Object.defineProperty(exports, "setGlobalProvider", ({ enumerable: true, get: function () { return initializeInpageProvider_1.setGlobalProvider; } }));
const MetaMaskInpageProvider_1 = __webpack_require__(/*! ./MetaMaskInpageProvider */ "./node_modules/@metamask/providers/dist/MetaMaskInpageProvider.js");
Object.defineProperty(exports, "MetaMaskInpageProvider", ({ enumerable: true, get: function () { return MetaMaskInpageProvider_1.MetaMaskInpageProvider; } }));
Object.defineProperty(exports, "MetaMaskInpageProviderStreamName", ({ enumerable: true, get: function () { return MetaMaskInpageProvider_1.MetaMaskInpageProviderStreamName; } }));
const shimWeb3_1 = __webpack_require__(/*! ./shimWeb3 */ "./node_modules/@metamask/providers/dist/shimWeb3.js");
Object.defineProperty(exports, "shimWeb3", ({ enumerable: true, get: function () { return shimWeb3_1.shimWeb3; } }));
const StreamProvider_1 = __webpack_require__(/*! ./StreamProvider */ "./node_modules/@metamask/providers/dist/StreamProvider.js");
Object.defineProperty(exports, "StreamProvider", ({ enumerable: true, get: function () { return StreamProvider_1.StreamProvider; } }));


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/initializeInpageProvider.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/initializeInpageProvider.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setGlobalProvider = exports.initializeProvider = void 0;
const EIP6963_1 = __webpack_require__(/*! ./EIP6963 */ "./node_modules/@metamask/providers/dist/EIP6963.js");
const MetaMaskInpageProvider_1 = __webpack_require__(/*! ./MetaMaskInpageProvider */ "./node_modules/@metamask/providers/dist/MetaMaskInpageProvider.js");
const shimWeb3_1 = __webpack_require__(/*! ./shimWeb3 */ "./node_modules/@metamask/providers/dist/shimWeb3.js");
/**
 * Initializes a MetaMaskInpageProvider and (optionally) assigns it as window.ethereum.
 *
 * @param options - An options bag.
 * @param options.connectionStream - A Node.js stream.
 * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.
 * @param options.maxEventListeners - The maximum number of event listeners.
 * @param options.providerInfo - The EIP-6963 provider info that should be announced if set.
 * @param options.shouldSendMetadata - Whether the provider should send page metadata.
 * @param options.shouldSetOnWindow - Whether the provider should be set as window.ethereum.
 * @param options.shouldShimWeb3 - Whether a window.web3 shim should be injected.
 * @param options.logger - The logging API to use. Default: `console`.
 * @returns The initialized provider (whether set or not).
 */
function initializeProvider({ connectionStream, jsonRpcStreamName, logger = console, maxEventListeners = 100, providerInfo, shouldSendMetadata = true, shouldSetOnWindow = true, shouldShimWeb3 = false, }) {
    const provider = new MetaMaskInpageProvider_1.MetaMaskInpageProvider(connectionStream, {
        jsonRpcStreamName,
        logger,
        maxEventListeners,
        shouldSendMetadata,
    });
    const proxiedProvider = new Proxy(provider, {
        // some common libraries, e.g. web3@1.x, mess with our API
        deleteProperty: () => true,
        // fix issue with Proxy unable to access private variables from getters
        // https://stackoverflow.com/a/73051482
        get(target, propName) {
            return target[propName];
        },
    });
    if (providerInfo) {
        (0, EIP6963_1.announceProvider)({
            info: providerInfo,
            provider: proxiedProvider,
        });
    }
    if (shouldSetOnWindow) {
        setGlobalProvider(proxiedProvider);
    }
    if (shouldShimWeb3) {
        (0, shimWeb3_1.shimWeb3)(proxiedProvider, logger);
    }
    return proxiedProvider;
}
exports.initializeProvider = initializeProvider;
/**
 * Sets the given provider instance as window.ethereum and dispatches the
 * 'ethereum#initialized' event on window.
 *
 * @param providerInstance - The provider instance.
 */
function setGlobalProvider(providerInstance) {
    window.ethereum = providerInstance;
    window.dispatchEvent(new Event('ethereum#initialized'));
}
exports.setGlobalProvider = setGlobalProvider;


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/messages.js":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/messages.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const messages = {
    errors: {
        disconnected: () => 'MetaMask: Disconnected from chain. Attempting to connect.',
        permanentlyDisconnected: () => 'MetaMask: Disconnected from MetaMask background. Page reload required.',
        sendSiteMetadata: () => `MetaMask: Failed to send site metadata. This is an internal error, please report this bug.`,
        unsupportedSync: (method) => `MetaMask: The MetaMask Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,
        invalidDuplexStream: () => 'Must provide a Node.js-style duplex stream.',
        invalidNetworkParams: () => 'MetaMask: Received invalid network parameters. Please report this bug.',
        invalidRequestArgs: () => `Expected a single, non-array, object argument.`,
        invalidRequestMethod: () => `'args.method' must be a non-empty string.`,
        invalidRequestParams: () => `'args.params' must be an object or array if provided.`,
        invalidLoggerObject: () => `'args.logger' must be an object if provided.`,
        invalidLoggerMethod: (method) => `'args.logger' must include required method '${method}'.`,
    },
    info: {
        connected: (chainId) => `MetaMask: Connected to chain with ID "${chainId}".`,
    },
    warnings: {
        // deprecated properties
        chainIdDeprecation: `MetaMask: 'ethereum.chainId' is deprecated and may be removed in the future. Please use the 'eth_chainId' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23`,
        networkVersionDeprecation: `MetaMask: 'ethereum.networkVersion' is deprecated and may be removed in the future. Please use the 'net_version' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23`,
        selectedAddressDeprecation: `MetaMask: 'ethereum.selectedAddress' is deprecated and may be removed in the future. Please use the 'eth_accounts' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23`,
        // deprecated methods
        enableDeprecation: `MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1102`,
        sendDeprecation: `MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193`,
        // deprecated events
        events: {
            close: `MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect`,
            data: `MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message`,
            networkChanged: `MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged`,
            notification: `MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message`,
        },
        rpc: {
            ethDecryptDeprecation: `MetaMask: The RPC method 'eth_decrypt' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686`,
            ethGetEncryptionPublicKeyDeprecation: `MetaMask: The RPC method 'eth_getEncryptionPublicKey' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686`,
            walletWatchAssetNFTExperimental: `MetaMask: The RPC method 'wallet_watchAsset' is experimental for ERC721/ERC1155 assets and may change in the future.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md and https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle`,
        },
        // misc
        experimentalMethods: `MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning.`,
    },
};
exports["default"] = messages;


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/middleware/createRpcWarningMiddleware.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/middleware/createRpcWarningMiddleware.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRpcWarningMiddleware = void 0;
const constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/@metamask/providers/dist/constants.js");
const messages_1 = __importDefault(__webpack_require__(/*! ../messages */ "./node_modules/@metamask/providers/dist/messages.js"));
/**
 * Create JSON-RPC middleware that logs warnings for deprecated RPC methods.
 *
 * @param log - The logging API to use.
 * @returns The JSON-RPC middleware.
 */
function createRpcWarningMiddleware(log) {
    const sentWarnings = {
        ethDecryptDeprecation: false,
        ethGetEncryptionPublicKeyDeprecation: false,
        walletWatchAssetNFTExperimental: false,
    };
    return (req, _res, next) => {
        if (!sentWarnings.ethDecryptDeprecation && req.method === 'eth_decrypt') {
            log.warn(messages_1.default.warnings.rpc.ethDecryptDeprecation);
            sentWarnings.ethDecryptDeprecation = true;
        }
        else if (!sentWarnings.ethGetEncryptionPublicKeyDeprecation &&
            req.method === 'eth_getEncryptionPublicKey') {
            log.warn(messages_1.default.warnings.rpc.ethGetEncryptionPublicKeyDeprecation);
            sentWarnings.ethGetEncryptionPublicKeyDeprecation = true;
        }
        else if (!sentWarnings.walletWatchAssetNFTExperimental &&
            req.method === 'wallet_watchAsset' &&
            [constants_1.ERC721, constants_1.ERC1155].includes(req.params?.type || '')) {
            log.warn(messages_1.default.warnings.rpc.walletWatchAssetNFTExperimental);
            sentWarnings.walletWatchAssetNFTExperimental = true;
        }
        next();
    };
}
exports.createRpcWarningMiddleware = createRpcWarningMiddleware;


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/shimWeb3.js":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/shimWeb3.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shimWeb3 = void 0;
/**
 * If no existing window.web3 is found, this function injects a web3 "shim" to
 * not break dapps that rely on window.web3.currentProvider.
 *
 * @param provider - The provider to set as window.web3.currentProvider.
 * @param log - The logging API to use.
 */
function shimWeb3(provider, log = console) {
    let loggedCurrentProvider = false;
    let loggedMissingProperty = false;
    if (!window.web3) {
        const SHIM_IDENTIFIER = '__isMetaMaskShim__';
        let web3Shim = { currentProvider: provider };
        Object.defineProperty(web3Shim, SHIM_IDENTIFIER, {
            value: true,
            enumerable: true,
            configurable: false,
            writable: false,
        });
        web3Shim = new Proxy(web3Shim, {
            get: (target, property, ...args) => {
                if (property === 'currentProvider' && !loggedCurrentProvider) {
                    loggedCurrentProvider = true;
                    log.warn('You are accessing the MetaMask window.web3.currentProvider shim. This property is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3');
                }
                else if (property !== 'currentProvider' &&
                    property !== SHIM_IDENTIFIER &&
                    !loggedMissingProperty) {
                    loggedMissingProperty = true;
                    log.error(`MetaMask no longer injects web3. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3`);
                    provider
                        .request({ method: 'metamask_logWeb3ShimUsage' })
                        .catch((error) => {
                        log.debug('MetaMask: Failed to log web3 shim usage.', error);
                    });
                }
                return Reflect.get(target, property, ...args);
            },
            set: (...args) => {
                log.warn('You are accessing the MetaMask window.web3 shim. This object is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3');
                return Reflect.set(...args);
            },
        });
        Object.defineProperty(window, 'web3', {
            value: web3Shim,
            enumerable: false,
            configurable: true,
            writable: true,
        });
    }
}
exports.shimWeb3 = shimWeb3;


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/siteMetadata.js":
/*!***************************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/siteMetadata.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendSiteMetadata = void 0;
const messages_1 = __importDefault(__webpack_require__(/*! ./messages */ "./node_modules/@metamask/providers/dist/messages.js"));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@metamask/providers/dist/utils.js");
/**
 * Sends site metadata over an RPC request.
 *
 * @param engine - The JSON RPC Engine to send metadata over.
 * @param log - The logging API to use.
 */
async function sendSiteMetadata(engine, log) {
    try {
        const domainMetadata = await getSiteMetadata();
        // call engine.handle directly to avoid normal RPC request handling
        engine.handle({
            jsonrpc: '2.0',
            id: 1,
            method: 'metamask_sendDomainMetadata',
            params: domainMetadata,
        }, utils_1.NOOP);
    }
    catch (error) {
        log.error({
            message: messages_1.default.errors.sendSiteMetadata(),
            originalError: error,
        });
    }
}
exports.sendSiteMetadata = sendSiteMetadata;
/**
 * Get site metadata.
 *
 * @returns The site metadata.
 */
async function getSiteMetadata() {
    return {
        name: getSiteName(window),
        icon: await getSiteIcon(window),
    };
}
/**
 * Extract a name for the site from the DOM.
 *
 * @param windowObject - The window object to extract the site name from.
 * @returns The site name.
 */
function getSiteName(windowObject) {
    const { document } = windowObject;
    const siteName = document.querySelector('head > meta[property="og:site_name"]');
    if (siteName) {
        return siteName.content;
    }
    const metaTitle = document.querySelector('head > meta[name="title"]');
    if (metaTitle) {
        return metaTitle.content;
    }
    if (document.title && document.title.length > 0) {
        return document.title;
    }
    return window.location.hostname;
}
/**
 * Extract an icon for the site from the DOM.
 *
 * @param windowObject - The window object to extract the site icon from.
 * @returns An icon URL, if one exists.
 */
async function getSiteIcon(windowObject) {
    const { document } = windowObject;
    const icons = document.querySelectorAll('head > link[rel~="icon"]');
    for (const icon of Array.from(icons)) {
        if (icon && (await imgExists(icon.href))) {
            return icon.href;
        }
    }
    return null;
}
/**
 * Return whether the given image URL exists.
 *
 * @param url - The url of the image.
 * @returns Whether the image exists.
 */
async function imgExists(url) {
    return new Promise((resolve, reject) => {
        try {
            const img = document.createElement('img');
            img.onload = () => resolve(true);
            img.onerror = () => resolve(false);
            img.src = url;
        }
        catch (error) {
            reject(error);
        }
    });
}


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NOOP = exports.isValidNetworkVersion = exports.isValidChainId = exports.getRpcPromiseCallback = exports.getDefaultExternalMiddleware = exports.EMITTED_NOTIFICATIONS = void 0;
const json_rpc_engine_1 = __webpack_require__(/*! @metamask/json-rpc-engine */ "./node_modules/@metamask/json-rpc-engine/dist/index.js");
const rpc_errors_1 = __webpack_require__(/*! @metamask/rpc-errors */ "./node_modules/@metamask/rpc-errors/dist/index.js");
const createRpcWarningMiddleware_1 = __webpack_require__(/*! ./middleware/createRpcWarningMiddleware */ "./node_modules/@metamask/providers/dist/middleware/createRpcWarningMiddleware.js");
// Constants
exports.EMITTED_NOTIFICATIONS = Object.freeze([
    'eth_subscription', // per eth-json-rpc-filters/subscriptionManager
]);
// Utility functions
/**
 * Gets the default middleware for external providers, consisting of an ID
 * remapping middleware and an error middleware.
 *
 * @param logger - The logger to use in the error middleware.
 * @returns An array of @metamask/json-rpc-engine middleware functions.
 */
const getDefaultExternalMiddleware = (logger = console) => [
    (0, json_rpc_engine_1.createIdRemapMiddleware)(),
    createErrorMiddleware(logger),
    (0, createRpcWarningMiddleware_1.createRpcWarningMiddleware)(logger),
];
exports.getDefaultExternalMiddleware = getDefaultExternalMiddleware;
/**
 * A `json-rpc-engine` middleware that logs RPC errors and validates the request
 * method.
 *
 * @param log - The logging API to use.
 * @returns A @metamask/json-rpc-engine middleware function.
 */
function createErrorMiddleware(log) {
    return (request, response, next) => {
        // json-rpc-engine will terminate the request when it notices this error
        if (typeof request.method !== 'string' || !request.method) {
            response.error = rpc_errors_1.rpcErrors.invalidRequest({
                message: `The request 'method' must be a non-empty string.`,
                data: request,
            });
        }
        next((done) => {
            const { error } = response;
            if (!error) {
                return done();
            }
            log.error(`MetaMask - RPC Error: ${error.message}`, error);
            return done();
        });
    };
}
// resolve response.result or response, reject errors
const getRpcPromiseCallback = (resolve, reject, unwrapResult = true) => (error, response) => {
    if (error || response.error) {
        reject(error || response.error);
    }
    else {
        !unwrapResult || Array.isArray(response)
            ? resolve(response)
            : resolve(response.result);
    }
};
exports.getRpcPromiseCallback = getRpcPromiseCallback;
/**
 * Checks whether the given chain ID is valid, meaning if it is non-empty,
 * '0x'-prefixed string.
 *
 * @param chainId - The chain ID to validate.
 * @returns Whether the given chain ID is valid.
 */
const isValidChainId = (chainId) => Boolean(chainId) && typeof chainId === 'string' && chainId.startsWith('0x');
exports.isValidChainId = isValidChainId;
/**
 * Checks whether the given network version is valid, meaning if it is non-empty
 * string.
 *
 * @param networkVersion - The network version to validate.
 * @returns Whether the given network version is valid.
 */
const isValidNetworkVersion = (networkVersion) => Boolean(networkVersion) && typeof networkVersion === 'string';
exports.isValidNetworkVersion = isValidNetworkVersion;
const NOOP = () => undefined;
exports.NOOP = NOOP;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/object-multiplex/dist/ObjectMultiplex.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/object-multiplex/dist/ObjectMultiplex.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObjectMultiplex = void 0;
const readable_stream_1 = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");
const once_1 = __importDefault(__webpack_require__(/*! once */ "./node_modules/once/once.js"));
const Substream_1 = __webpack_require__(/*! ./Substream */ "./node_modules/@metamask/providers/node_modules/@metamask/object-multiplex/dist/Substream.js");
const IGNORE_SUBSTREAM = Symbol('IGNORE_SUBSTREAM');
class ObjectMultiplex extends readable_stream_1.Duplex {
    constructor(opts = {}) {
        super(Object.assign(Object.assign({}, opts), { objectMode: true }));
        this._substreams = {};
    }
    createStream(name) {
        // guard stream against destroyed already
        if (this.destroyed) {
            throw new Error(`ObjectMultiplex - parent stream for name "${name}" already destroyed`);
        }
        // guard stream against ended already
        if (this._readableState.ended || this._writableState.ended) {
            throw new Error(`ObjectMultiplex - parent stream for name "${name}" already ended`);
        }
        // validate name
        if (!name) {
            throw new Error('ObjectMultiplex - name must not be empty');
        }
        if (this._substreams[name]) {
            throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
        }
        // create substream
        const substream = new Substream_1.Substream({ parent: this, name });
        this._substreams[name] = substream;
        // listen for parent stream to end
        anyStreamEnd(this, (_error) => {
            return substream.destroy(_error || undefined);
        });
        return substream;
    }
    // ignore streams (dont display orphaned data warning)
    ignoreStream(name) {
        // validate name
        if (!name) {
            throw new Error('ObjectMultiplex - name must not be empty');
        }
        if (this._substreams[name]) {
            throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
        }
        // set
        this._substreams[name] = IGNORE_SUBSTREAM;
    }
    _read() {
        return undefined;
    }
    _write(chunk, _encoding, callback) {
        const { name, data } = chunk;
        if (!name) {
            console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`);
            return callback();
        }
        // get corresponding substream
        const substream = this._substreams[name];
        if (!substream) {
            console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`);
            return callback();
        }
        // push data into substream
        if (substream !== IGNORE_SUBSTREAM) {
            substream.push(data);
        }
        return callback();
    }
}
exports.ObjectMultiplex = ObjectMultiplex;
// util
function anyStreamEnd(stream, _cb) {
    const cb = (0, once_1.default)(_cb);
    (0, readable_stream_1.finished)(stream, { readable: false }, cb);
    (0, readable_stream_1.finished)(stream, { writable: false }, cb);
}


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/object-multiplex/dist/Substream.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/object-multiplex/dist/Substream.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Substream = void 0;
const readable_stream_1 = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");
class Substream extends readable_stream_1.Duplex {
    constructor({ parent, name }) {
        super({ objectMode: true });
        this._parent = parent;
        this._name = name;
    }
    /**
     * Explicitly sets read operations to a no-op.
     */
    _read() {
        return undefined;
    }
    /**
     * Called when data should be written to this writable stream.
     *
     * @param chunk - Arbitrary object to write
     * @param encoding - Encoding to use when writing payload
     * @param callback - Called when writing is complete or an error occurs
     */
    _write(chunk, _encoding, callback) {
        this._parent.push({
            name: this._name,
            data: chunk,
        });
        callback();
    }
}
exports.Substream = Substream;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/object-multiplex/dist/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/object-multiplex/dist/index.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ObjectMultiplex_1 = __webpack_require__(/*! ./ObjectMultiplex */ "./node_modules/@metamask/providers/node_modules/@metamask/object-multiplex/dist/ObjectMultiplex.js");
module.exports = ObjectMultiplex_1.ObjectMultiplex;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/safe-event-emitter/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/safe-event-emitter/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
function safeApply(handler, context, args) {
    try {
        Reflect.apply(handler, context, args);
    }
    catch (err) {
        // Throw error after timeout so as not to interrupt the stack
        setTimeout(() => {
            throw err;
        });
    }
}
function arrayClone(arr) {
    const n = arr.length;
    const copy = new Array(n);
    for (let i = 0; i < n; i += 1) {
        copy[i] = arr[i];
    }
    return copy;
}
class SafeEventEmitter extends events_1.EventEmitter {
    emit(type, ...args) {
        let doError = type === 'error';
        const events = this._events;
        if (events !== undefined) {
            doError = doError && events.error === undefined;
        }
        else if (!doError) {
            return false;
        }
        // If there is no 'error' event listener then throw.
        if (doError) {
            let er;
            if (args.length > 0) {
                [er] = args;
            }
            if (er instanceof Error) {
                // Note: The comments on the `throw` lines are intentional, they show
                // up in Node's output if this results in an unhandled exception.
                throw er; // Unhandled 'error' event
            }
            // At least give some kind of context to the user
            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);
            err.context = er;
            throw err; // Unhandled 'error' event
        }
        const handler = events[type];
        if (handler === undefined) {
            return false;
        }
        if (typeof handler === 'function') {
            safeApply(handler, this, args);
        }
        else {
            const len = handler.length;
            const listeners = arrayClone(handler);
            for (let i = 0; i < len; i += 1) {
                safeApply(listeners[i], this, args);
            }
        }
        return true;
    }
}
exports["default"] = SafeEventEmitter;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/logging.ts
var _debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"); var _debug2 = _interopRequireDefault(_debug);
var globalLogger = _debug2.default.call(void 0, "metamask");
function createProjectLogger(projectName) {
  return globalLogger.extend(projectName);
}
function createModuleLogger(projectLogger, moduleName) {
  return projectLogger.extend(moduleName);
}




exports.createProjectLogger = createProjectLogger; exports.createModuleLogger = createModuleLogger;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};





exports.__privateGet = __privateGet; exports.__privateAdd = __privateAdd; exports.__privateSet = __privateSet;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/versions.ts






var _semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var VersionStruct = _superstruct.refine.call(void 0, 
  _superstruct.string.call(void 0, ),
  "Version",
  (value) => {
    if (_semver.valid.call(void 0, value) === null) {
      return `Expected SemVer version, got "${value}"`;
    }
    return true;
  }
);
var VersionRangeStruct = _superstruct.refine.call(void 0, 
  _superstruct.string.call(void 0, ),
  "Version range",
  (value) => {
    if (_semver.validRange.call(void 0, value) === null) {
      return `Expected SemVer range, got "${value}"`;
    }
    return true;
  }
);
function isValidSemVerVersion(version) {
  return _superstruct.is.call(void 0, version, VersionStruct);
}
function isValidSemVerRange(versionRange) {
  return _superstruct.is.call(void 0, versionRange, VersionRangeStruct);
}
function assertIsSemVerVersion(version) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, version, VersionStruct);
}
function assertIsSemVerRange(range) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, range, VersionRangeStruct);
}
function gtVersion(version1, version2) {
  return _semver.gt.call(void 0, version1, version2);
}
function gtRange(version, range) {
  return _semver.gtr.call(void 0, version, range);
}
function satisfiesVersionRange(version, versionRange) {
  return _semver.satisfies.call(void 0, version, versionRange, {
    includePrerelease: true
  });
}











exports.VersionStruct = VersionStruct; exports.VersionRangeStruct = VersionRangeStruct; exports.isValidSemVerVersion = isValidSemVerVersion; exports.isValidSemVerRange = isValidSemVerRange; exports.assertIsSemVerVersion = assertIsSemVerVersion; exports.assertIsSemVerRange = assertIsSemVerRange; exports.gtVersion = gtVersion; exports.gtRange = gtRange; exports.satisfiesVersionRange = satisfiesVersionRange;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-4NIRTM4M.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-4NIRTM4M.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));// src/promise.ts
function createDeferredPromise({
  suppressUnhandledRejection = false
} = {}) {
  let resolve;
  let reject;
  const promise = new Promise(
    (innerResolve, innerReject) => {
      resolve = innerResolve;
      reject = innerReject;
    }
  );
  if (suppressUnhandledRejection) {
    promise.catch((_error) => {
    });
  }
  return { promise, resolve, reject };
}



exports.createDeferredPromise = createDeferredPromise;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));// src/time.ts
var Duration = /* @__PURE__ */ ((Duration2) => {
  Duration2[Duration2["Millisecond"] = 1] = "Millisecond";
  Duration2[Duration2["Second"] = 1e3] = "Second";
  Duration2[Duration2["Minute"] = 6e4] = "Minute";
  Duration2[Duration2["Hour"] = 36e5] = "Hour";
  Duration2[Duration2["Day"] = 864e5] = "Day";
  Duration2[Duration2["Week"] = 6048e5] = "Week";
  Duration2[Duration2["Year"] = 31536e6] = "Year";
  return Duration2;
})(Duration || {});
var isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
var assertIsNonNegativeInteger = (number, name) => {
  if (!isNonNegativeInteger(number)) {
    throw new Error(
      `"${name}" must be a non-negative integer. Received: "${number}".`
    );
  }
};
function inMilliseconds(count, duration) {
  assertIsNonNegativeInteger(count, "count");
  return count * duration;
}
function timeSince(timestamp) {
  assertIsNonNegativeInteger(timestamp, "timestamp");
  return Date.now() - timestamp;
}





exports.Duration = Duration; exports.inMilliseconds = inMilliseconds; exports.timeSince = timeSince;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-5AVWINSB.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-5AVWINSB.js ***!
  \**********************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/base64.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var base64 = (struct, options = {}) => {
  const paddingRequired = _nullishCoalesce(options.paddingRequired, () => ( false));
  const characterSet = _nullishCoalesce(options.characterSet, () => ( "base64"));
  let letters;
  if (characterSet === "base64") {
    letters = String.raw`[A-Za-z0-9+\/]`;
  } else {
    _chunk6ZDHSOUVjs.assert.call(void 0, characterSet === "base64url");
    letters = String.raw`[-_A-Za-z0-9]`;
  }
  let re;
  if (paddingRequired) {
    re = new RegExp(
      `^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`,
      "u"
    );
  } else {
    re = new RegExp(
      `^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`,
      "u"
    );
  }
  return _superstruct.pattern.call(void 0, struct, re);
};



exports.base64 = base64;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkIZC266HSjs = __webpack_require__(/*! ./chunk-IZC266HS.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-IZC266HS.js");

// src/assert.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
function isConstructable(fn) {
  return Boolean(typeof _optionalChain([fn, 'optionalAccess', _ => _.prototype, 'optionalAccess', _2 => _2.constructor, 'optionalAccess', _3 => _3.name]) === "string");
}
function getErrorMessageWithoutTrailingPeriod(error) {
  return _chunkIZC266HSjs.getErrorMessage.call(void 0, error).replace(/\.$/u, "");
}
function getError(ErrorWrapper, message) {
  if (isConstructable(ErrorWrapper)) {
    return new ErrorWrapper({
      message
    });
  }
  return ErrorWrapper({
    message
  });
}
var AssertionError = class extends Error {
  constructor(options) {
    super(options.message);
    this.code = "ERR_ASSERTION";
  }
};
function assert(value, message = "Assertion failed.", ErrorWrapper = AssertionError) {
  if (!value) {
    if (message instanceof Error) {
      throw message;
    }
    throw getError(ErrorWrapper, message);
  }
}
function assertStruct(value, struct, errorPrefix = "Assertion failed", ErrorWrapper = AssertionError) {
  try {
    _superstruct.assert.call(void 0, value, struct);
  } catch (error) {
    throw getError(
      ErrorWrapper,
      `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`
    );
  }
}
function assertExhaustive(_object) {
  throw new Error(
    "Invalid branch reached. Should be detected during compilation."
  );
}






exports.AssertionError = AssertionError; exports.assert = assert; exports.assertStruct = assertStruct; exports.assertExhaustive = assertExhaustive;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));



var _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js");


var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/coercers.ts









var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var NumberLikeStruct = _superstruct.union.call(void 0, [_superstruct.number.call(void 0, ), _superstruct.bigint.call(void 0, ), _superstruct.string.call(void 0, ), _chunkQEPVHEP7js.StrictHexStruct]);
var NumberCoercer = _superstruct.coerce.call(void 0, _superstruct.number.call(void 0, ), NumberLikeStruct, Number);
var BigIntCoercer = _superstruct.coerce.call(void 0, _superstruct.bigint.call(void 0, ), NumberLikeStruct, BigInt);
var BytesLikeStruct = _superstruct.union.call(void 0, [_chunkQEPVHEP7js.StrictHexStruct, _superstruct.instance.call(void 0, Uint8Array)]);
var BytesCoercer = _superstruct.coerce.call(void 0, 
  _superstruct.instance.call(void 0, Uint8Array),
  _superstruct.union.call(void 0, [_chunkQEPVHEP7js.StrictHexStruct]),
  _chunkQEPVHEP7js.hexToBytes
);
var HexCoercer = _superstruct.coerce.call(void 0, _chunkQEPVHEP7js.StrictHexStruct, _superstruct.instance.call(void 0, Uint8Array), _chunkQEPVHEP7js.bytesToHex);
function createNumber(value) {
  try {
    const result = _superstruct.create.call(void 0, value, NumberCoercer);
    _chunk6ZDHSOUVjs.assert.call(void 0, 
      Number.isFinite(result),
      `Expected a number-like value, got "${value}".`
    );
    return result;
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(`Expected a number-like value, got "${value}".`);
    }
    throw error;
  }
}
function createBigInt(value) {
  try {
    return _superstruct.create.call(void 0, value, BigIntCoercer);
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(
        `Expected a number-like value, got "${String(error.value)}".`
      );
    }
    throw error;
  }
}
function createBytes(value) {
  if (typeof value === "string" && value.toLowerCase() === "0x") {
    return new Uint8Array();
  }
  try {
    return _superstruct.create.call(void 0, value, BytesCoercer);
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(
        `Expected a bytes-like value, got "${String(error.value)}".`
      );
    }
    throw error;
  }
}
function createHex(value) {
  if (value instanceof Uint8Array && value.length === 0 || typeof value === "string" && value.toLowerCase() === "0x") {
    return "0x";
  }
  try {
    return _superstruct.create.call(void 0, value, HexCoercer);
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(
        `Expected a bytes-like value, got "${String(error.value)}".`
      );
    }
    throw error;
  }
}






exports.createNumber = createNumber; exports.createBigInt = createBigInt; exports.createBytes = createBytes; exports.createHex = createHex;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));

var _chunk6NZW4WK4js = __webpack_require__(/*! ./chunk-6NZW4WK4.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js");

// src/checksum.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var ChecksumStruct = _superstruct.size.call(void 0, 
  _chunk6NZW4WK4js.base64.call(void 0, _superstruct.string.call(void 0, ), { paddingRequired: true }),
  44,
  44
);



exports.ChecksumStruct = ChecksumStruct;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js ***!
  \**********************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-IZC266HS.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-IZC266HS.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));


var _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js");

// src/errors.ts
var _ponycause = __webpack_require__(/*! pony-cause */ "./node_modules/pony-cause/index.js");
function isError(error) {
  return error instanceof Error || _chunkQVEKZRZ2js.isObject.call(void 0, error) && error.constructor.name === "Error";
}
function isErrorWithCode(error) {
  return typeof error === "object" && error !== null && "code" in error;
}
function isErrorWithMessage(error) {
  return typeof error === "object" && error !== null && "message" in error;
}
function isErrorWithStack(error) {
  return typeof error === "object" && error !== null && "stack" in error;
}
function getErrorMessage(error) {
  if (isErrorWithMessage(error) && typeof error.message === "string") {
    return error.message;
  }
  if (_chunkQVEKZRZ2js.isNullOrUndefined.call(void 0, error)) {
    return "";
  }
  return String(error);
}
function wrapError(originalError, message) {
  if (isError(originalError)) {
    let error;
    if (Error.length === 2) {
      error = new Error(message, { cause: originalError });
    } else {
      error = new (0, _ponycause.ErrorWithCause)(message, { cause: originalError });
    }
    if (isErrorWithCode(originalError)) {
      error.code = originalError.code;
    }
    return error;
  }
  if (message.length > 0) {
    return new Error(`${String(originalError)}: ${message}`);
  }
  return new Error(String(originalError));
}







exports.isErrorWithCode = isErrorWithCode; exports.isErrorWithMessage = isErrorWithMessage; exports.isErrorWithStack = isErrorWithStack; exports.getErrorMessage = getErrorMessage; exports.wrapError = wrapError;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js ***!
  \**********************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-OLLG4H35.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-OLLG4H35.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");


var _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js");

// src/json.ts




















var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var object = (schema) => (
  // The type is slightly different from a regular object struct, because we
  // want to make properties with `undefined` in their type optional, but not
  // `undefined` itself. This means that we need a type cast.
  _superstruct.object.call(void 0, schema)
);
function hasOptional({ path, branch }) {
  const field = path[path.length - 1];
  return _chunkQVEKZRZ2js.hasProperty.call(void 0, branch[branch.length - 2], field);
}
function exactOptional(struct) {
  return new (0, _superstruct.Struct)({
    ...struct,
    type: `optional ${struct.type}`,
    validator: (value, context) => !hasOptional(context) || struct.validator(value, context),
    refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context)
  });
}
var finiteNumber = () => _superstruct.define.call(void 0, "finite number", (value) => {
  return _superstruct.is.call(void 0, value, _superstruct.number.call(void 0, )) && Number.isFinite(value);
});
var UnsafeJsonStruct = _superstruct.union.call(void 0, [
  _superstruct.literal.call(void 0, null),
  _superstruct.boolean.call(void 0, ),
  finiteNumber(),
  _superstruct.string.call(void 0, ),
  _superstruct.array.call(void 0, _superstruct.lazy.call(void 0, () => UnsafeJsonStruct)),
  _superstruct.record.call(void 0, 
    _superstruct.string.call(void 0, ),
    _superstruct.lazy.call(void 0, () => UnsafeJsonStruct)
  )
]);
var JsonStruct = _superstruct.coerce.call(void 0, UnsafeJsonStruct, _superstruct.any.call(void 0, ), (value) => {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, UnsafeJsonStruct);
  return JSON.parse(
    JSON.stringify(value, (propKey, propValue) => {
      if (propKey === "__proto__" || propKey === "constructor") {
        return void 0;
      }
      return propValue;
    })
  );
});
function isValidJson(value) {
  try {
    getSafeJson(value);
    return true;
  } catch (e) {
    return false;
  }
}
function getSafeJson(value) {
  return _superstruct.create.call(void 0, value, JsonStruct);
}
function getJsonSize(value) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, JsonStruct, "Invalid JSON value");
  const json = JSON.stringify(value);
  return new TextEncoder().encode(json).byteLength;
}
var jsonrpc2 = "2.0";
var JsonRpcVersionStruct = _superstruct.literal.call(void 0, jsonrpc2);
var JsonRpcIdStruct = _superstruct.nullable.call(void 0, _superstruct.union.call(void 0, [_superstruct.number.call(void 0, ), _superstruct.string.call(void 0, )]));
var JsonRpcErrorStruct = object({
  code: _superstruct.integer.call(void 0, ),
  message: _superstruct.string.call(void 0, ),
  data: exactOptional(JsonStruct),
  stack: exactOptional(_superstruct.string.call(void 0, ))
});
var JsonRpcParamsStruct = _superstruct.union.call(void 0, [_superstruct.record.call(void 0, _superstruct.string.call(void 0, ), JsonStruct), _superstruct.array.call(void 0, JsonStruct)]);
var JsonRpcRequestStruct = object({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  method: _superstruct.string.call(void 0, ),
  params: exactOptional(JsonRpcParamsStruct)
});
var JsonRpcNotificationStruct = object({
  jsonrpc: JsonRpcVersionStruct,
  method: _superstruct.string.call(void 0, ),
  params: exactOptional(JsonRpcParamsStruct)
});
function isJsonRpcNotification(value) {
  return _superstruct.is.call(void 0, value, JsonRpcNotificationStruct);
}
function assertIsJsonRpcNotification(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcNotificationStruct,
    "Invalid JSON-RPC notification",
    ErrorWrapper
  );
}
function isJsonRpcRequest(value) {
  return _superstruct.is.call(void 0, value, JsonRpcRequestStruct);
}
function assertIsJsonRpcRequest(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcRequestStruct,
    "Invalid JSON-RPC request",
    ErrorWrapper
  );
}
var PendingJsonRpcResponseStruct = _superstruct.object.call(void 0, {
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  result: _superstruct.optional.call(void 0, _superstruct.unknown.call(void 0, )),
  error: _superstruct.optional.call(void 0, JsonRpcErrorStruct)
});
var JsonRpcSuccessStruct = object({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  result: JsonStruct
});
var JsonRpcFailureStruct = object({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  error: JsonRpcErrorStruct
});
var JsonRpcResponseStruct = _superstruct.union.call(void 0, [
  JsonRpcSuccessStruct,
  JsonRpcFailureStruct
]);
function isPendingJsonRpcResponse(response) {
  return _superstruct.is.call(void 0, response, PendingJsonRpcResponseStruct);
}
function assertIsPendingJsonRpcResponse(response, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    response,
    PendingJsonRpcResponseStruct,
    "Invalid pending JSON-RPC response",
    ErrorWrapper
  );
}
function isJsonRpcResponse(response) {
  return _superstruct.is.call(void 0, response, JsonRpcResponseStruct);
}
function assertIsJsonRpcResponse(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcResponseStruct,
    "Invalid JSON-RPC response",
    ErrorWrapper
  );
}
function isJsonRpcSuccess(value) {
  return _superstruct.is.call(void 0, value, JsonRpcSuccessStruct);
}
function assertIsJsonRpcSuccess(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcSuccessStruct,
    "Invalid JSON-RPC success response",
    ErrorWrapper
  );
}
function isJsonRpcFailure(value) {
  return _superstruct.is.call(void 0, value, JsonRpcFailureStruct);
}
function assertIsJsonRpcFailure(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcFailureStruct,
    "Invalid JSON-RPC failure response",
    ErrorWrapper
  );
}
function isJsonRpcError(value) {
  return _superstruct.is.call(void 0, value, JsonRpcErrorStruct);
}
function assertIsJsonRpcError(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcErrorStruct,
    "Invalid JSON-RPC error",
    ErrorWrapper
  );
}
function getJsonRpcIdValidator(options) {
  const { permitEmptyString, permitFractions, permitNull } = {
    permitEmptyString: true,
    permitFractions: false,
    permitNull: true,
    ...options
  };
  const isValidJsonRpcId = (id) => {
    return Boolean(
      typeof id === "number" && (permitFractions || Number.isInteger(id)) || typeof id === "string" && (permitEmptyString || id.length > 0) || permitNull && id === null
    );
  };
  return isValidJsonRpcId;
}



































exports.object = object; exports.exactOptional = exactOptional; exports.UnsafeJsonStruct = UnsafeJsonStruct; exports.JsonStruct = JsonStruct; exports.isValidJson = isValidJson; exports.getSafeJson = getSafeJson; exports.getJsonSize = getJsonSize; exports.jsonrpc2 = jsonrpc2; exports.JsonRpcVersionStruct = JsonRpcVersionStruct; exports.JsonRpcIdStruct = JsonRpcIdStruct; exports.JsonRpcErrorStruct = JsonRpcErrorStruct; exports.JsonRpcParamsStruct = JsonRpcParamsStruct; exports.JsonRpcRequestStruct = JsonRpcRequestStruct; exports.JsonRpcNotificationStruct = JsonRpcNotificationStruct; exports.isJsonRpcNotification = isJsonRpcNotification; exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification; exports.isJsonRpcRequest = isJsonRpcRequest; exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest; exports.PendingJsonRpcResponseStruct = PendingJsonRpcResponseStruct; exports.JsonRpcSuccessStruct = JsonRpcSuccessStruct; exports.JsonRpcFailureStruct = JsonRpcFailureStruct; exports.JsonRpcResponseStruct = JsonRpcResponseStruct; exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse; exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse; exports.isJsonRpcResponse = isJsonRpcResponse; exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse; exports.isJsonRpcSuccess = isJsonRpcSuccess; exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess; exports.isJsonRpcFailure = isJsonRpcFailure; exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure; exports.isJsonRpcError = isJsonRpcError; exports.assertIsJsonRpcError = assertIsJsonRpcError; exports.getJsonRpcIdValidator = getJsonRpcIdValidator;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/hex.ts
var _sha3 = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/@noble/hashes/sha3.js");
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");

// src/bytes.ts
var _base = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");
var HEX_MINIMUM_NUMBER_CHARACTER = 48;
var HEX_MAXIMUM_NUMBER_CHARACTER = 58;
var HEX_CHARACTER_OFFSET = 87;
function getPrecomputedHexValuesBuilder() {
  const lookupTable = [];
  return () => {
    if (lookupTable.length === 0) {
      for (let i = 0; i < 256; i++) {
        lookupTable.push(i.toString(16).padStart(2, "0"));
      }
    }
    return lookupTable;
  };
}
var getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
function isBytes(value) {
  return value instanceof Uint8Array;
}
function assertIsBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, isBytes(value), "Value must be a Uint8Array.");
}
function bytesToHex(bytes) {
  assertIsBytes(bytes);
  if (bytes.length === 0) {
    return "0x";
  }
  const lookupTable = getPrecomputedHexValues();
  const hexadecimal = new Array(bytes.length);
  for (let i = 0; i < bytes.length; i++) {
    hexadecimal[i] = lookupTable[bytes[i]];
  }
  return add0x(hexadecimal.join(""));
}
function bytesToBigInt(bytes) {
  assertIsBytes(bytes);
  const hexadecimal = bytesToHex(bytes);
  return BigInt(hexadecimal);
}
function bytesToSignedBigInt(bytes) {
  assertIsBytes(bytes);
  let value = BigInt(0);
  for (const byte of bytes) {
    value = (value << BigInt(8)) + BigInt(byte);
  }
  return BigInt.asIntN(bytes.length * 8, value);
}
function bytesToNumber(bytes) {
  assertIsBytes(bytes);
  const bigint = bytesToBigInt(bytes);
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    bigint <= BigInt(Number.MAX_SAFE_INTEGER),
    "Number is not a safe integer. Use `bytesToBigInt` instead."
  );
  return Number(bigint);
}
function bytesToString(bytes) {
  assertIsBytes(bytes);
  return new TextDecoder().decode(bytes);
}
function bytesToBase64(bytes) {
  assertIsBytes(bytes);
  return _base.base64.encode(bytes);
}
function hexToBytes(value) {
  if (_optionalChain([value, 'optionalAccess', _ => _.toLowerCase, 'optionalCall', _2 => _2()]) === "0x") {
    return new Uint8Array();
  }
  assertIsHexString(value);
  const strippedValue = remove0x(value).toLowerCase();
  const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
  const bytes = new Uint8Array(normalizedValue.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    const c1 = normalizedValue.charCodeAt(i * 2);
    const c2 = normalizedValue.charCodeAt(i * 2 + 1);
    const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
    const n2 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
    bytes[i] = n1 * 16 + n2;
  }
  return bytes;
}
function bigIntToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "bigint", "Value must be a bigint.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= BigInt(0), "Value must be a non-negative bigint.");
  const hexadecimal = value.toString(16);
  return hexToBytes(hexadecimal);
}
function bigIntFits(value, bytes) {
  _chunk6ZDHSOUVjs.assert.call(void 0, bytes > 0);
  const mask = value >> BigInt(31);
  return !((~value & mask) + (value & ~mask) >> BigInt(bytes * 8 + ~0));
}
function signedBigIntToBytes(value, byteLength) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "bigint", "Value must be a bigint.");
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof byteLength === "number", "Byte length must be a number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, byteLength > 0, "Byte length must be greater than 0.");
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    bigIntFits(value, byteLength),
    "Byte length is too small to represent the given value."
  );
  let numberValue = value;
  const bytes = new Uint8Array(byteLength);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = Number(BigInt.asUintN(8, numberValue));
    numberValue >>= BigInt(8);
  }
  return bytes.reverse();
}
function numberToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "number", "Value must be a number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, "Value must be a non-negative number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    Number.isSafeInteger(value),
    "Value is not a safe integer. Use `bigIntToBytes` instead."
  );
  const hexadecimal = value.toString(16);
  return hexToBytes(hexadecimal);
}
function stringToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "string", "Value must be a string.");
  return new TextEncoder().encode(value);
}
function base64ToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "string", "Value must be a string.");
  return _base.base64.decode(value);
}
function valueToBytes(value) {
  if (typeof value === "bigint") {
    return bigIntToBytes(value);
  }
  if (typeof value === "number") {
    return numberToBytes(value);
  }
  if (typeof value === "string") {
    if (value.startsWith("0x")) {
      return hexToBytes(value);
    }
    return stringToBytes(value);
  }
  if (isBytes(value)) {
    return value;
  }
  throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
function concatBytes(values) {
  const normalizedValues = new Array(values.length);
  let byteLength = 0;
  for (let i = 0; i < values.length; i++) {
    const value = valueToBytes(values[i]);
    normalizedValues[i] = value;
    byteLength += value.length;
  }
  const bytes = new Uint8Array(byteLength);
  for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
    bytes.set(normalizedValues[i], offset);
    offset += normalizedValues[i].length;
  }
  return bytes;
}
function createDataView(bytes) {
  if (typeof Buffer !== "undefined" && bytes instanceof Buffer) {
    const buffer = bytes.buffer.slice(
      bytes.byteOffset,
      bytes.byteOffset + bytes.byteLength
    );
    return new DataView(buffer);
  }
  return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}

// src/hex.ts
var HexStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), /^(?:0x)?[0-9a-f]+$/iu);
var StrictHexStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), /^0x[0-9a-f]+$/iu);
var HexAddressStruct = _superstruct.pattern.call(void 0, 
  _superstruct.string.call(void 0, ),
  /^0x[0-9a-f]{40}$/u
);
var HexChecksumAddressStruct = _superstruct.pattern.call(void 0, 
  _superstruct.string.call(void 0, ),
  /^0x[0-9a-fA-F]{40}$/u
);
function isHexString(value) {
  return _superstruct.is.call(void 0, value, HexStruct);
}
function isStrictHexString(value) {
  return _superstruct.is.call(void 0, value, StrictHexStruct);
}
function assertIsHexString(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, isHexString(value), "Value must be a hexadecimal string.");
}
function assertIsStrictHexString(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    isStrictHexString(value),
    'Value must be a hexadecimal string, starting with "0x".'
  );
}
function isValidHexAddress(possibleAddress) {
  return _superstruct.is.call(void 0, possibleAddress, HexAddressStruct) || isValidChecksumAddress(possibleAddress);
}
function getChecksumAddress(address) {
  _chunk6ZDHSOUVjs.assert.call(void 0, _superstruct.is.call(void 0, address, HexChecksumAddressStruct), "Invalid hex address.");
  const unPrefixed = remove0x(address.toLowerCase());
  const unPrefixedHash = remove0x(bytesToHex(_sha3.keccak_256.call(void 0, unPrefixed)));
  return `0x${unPrefixed.split("").map((character, nibbleIndex) => {
    const hashCharacter = unPrefixedHash[nibbleIndex];
    _chunk6ZDHSOUVjs.assert.call(void 0, _superstruct.is.call(void 0, hashCharacter, _superstruct.string.call(void 0, )), "Hash shorter than address.");
    return parseInt(hashCharacter, 16) > 7 ? character.toUpperCase() : character;
  }).join("")}`;
}
function isValidChecksumAddress(possibleChecksum) {
  if (!_superstruct.is.call(void 0, possibleChecksum, HexChecksumAddressStruct)) {
    return false;
  }
  return getChecksumAddress(possibleChecksum) === possibleChecksum;
}
function add0x(hexadecimal) {
  if (hexadecimal.startsWith("0x")) {
    return hexadecimal;
  }
  if (hexadecimal.startsWith("0X")) {
    return `0x${hexadecimal.substring(2)}`;
  }
  return `0x${hexadecimal}`;
}
function remove0x(hexadecimal) {
  if (hexadecimal.startsWith("0x") || hexadecimal.startsWith("0X")) {
    return hexadecimal.substring(2);
  }
  return hexadecimal;
}
































exports.HexStruct = HexStruct; exports.StrictHexStruct = StrictHexStruct; exports.HexAddressStruct = HexAddressStruct; exports.HexChecksumAddressStruct = HexChecksumAddressStruct; exports.isHexString = isHexString; exports.isStrictHexString = isStrictHexString; exports.assertIsHexString = assertIsHexString; exports.assertIsStrictHexString = assertIsStrictHexString; exports.isValidHexAddress = isValidHexAddress; exports.getChecksumAddress = getChecksumAddress; exports.isValidChecksumAddress = isValidChecksumAddress; exports.add0x = add0x; exports.remove0x = remove0x; exports.isBytes = isBytes; exports.assertIsBytes = assertIsBytes; exports.bytesToHex = bytesToHex; exports.bytesToBigInt = bytesToBigInt; exports.bytesToSignedBigInt = bytesToSignedBigInt; exports.bytesToNumber = bytesToNumber; exports.bytesToString = bytesToString; exports.bytesToBase64 = bytesToBase64; exports.hexToBytes = hexToBytes; exports.bigIntToBytes = bigIntToBytes; exports.signedBigIntToBytes = signedBigIntToBytes; exports.numberToBytes = numberToBytes; exports.stringToBytes = stringToBytes; exports.base64ToBytes = base64ToBytes; exports.valueToBytes = valueToBytes; exports.concatBytes = concatBytes; exports.createDataView = createDataView;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }// src/misc.ts
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
function isObject(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
var hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
function getKnownPropertyNames(object) {
  return Object.getOwnPropertyNames(object);
}
var JsonSize = /* @__PURE__ */ ((JsonSize2) => {
  JsonSize2[JsonSize2["Null"] = 4] = "Null";
  JsonSize2[JsonSize2["Comma"] = 1] = "Comma";
  JsonSize2[JsonSize2["Wrapper"] = 1] = "Wrapper";
  JsonSize2[JsonSize2["True"] = 4] = "True";
  JsonSize2[JsonSize2["False"] = 5] = "False";
  JsonSize2[JsonSize2["Quote"] = 1] = "Quote";
  JsonSize2[JsonSize2["Colon"] = 1] = "Colon";
  JsonSize2[JsonSize2["Date"] = 24] = "Date";
  return JsonSize2;
})(JsonSize || {});
var ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  try {
    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
  } catch (_) {
    return false;
  }
}
function isASCII(character) {
  return character.charCodeAt(0) <= 127;
}
function calculateStringSize(value) {
  const size = value.split("").reduce((total, character) => {
    if (isASCII(character)) {
      return total + 1;
    }
    return total + 2;
  }, 0);
  return size + (_nullishCoalesce(value.match(ESCAPE_CHARACTERS_REGEXP), () => ( []))).length;
}
function calculateNumberSize(value) {
  return value.toString().length;
}













exports.isNonEmptyArray = isNonEmptyArray; exports.isNullOrUndefined = isNullOrUndefined; exports.isObject = isObject; exports.hasProperty = hasProperty; exports.getKnownPropertyNames = getKnownPropertyNames; exports.JsonSize = JsonSize; exports.ESCAPE_CHARACTERS_REGEXP = ESCAPE_CHARACTERS_REGEXP; exports.isPlainObject = isPlainObject; exports.isASCII = isASCII; exports.calculateStringSize = calculateStringSize; exports.calculateNumberSize = calculateNumberSize;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js ***!
  \**********************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/caip-types.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var CAIP_CHAIN_ID_REGEX = /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u;
var CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;
var CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u;
var CAIP_ACCOUNT_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u;
var CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;
var CaipChainIdStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_CHAIN_ID_REGEX);
var CaipNamespaceStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_NAMESPACE_REGEX);
var CaipReferenceStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_REFERENCE_REGEX);
var CaipAccountIdStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_ACCOUNT_ID_REGEX);
var CaipAccountAddressStruct = _superstruct.pattern.call(void 0, 
  _superstruct.string.call(void 0, ),
  CAIP_ACCOUNT_ADDRESS_REGEX
);
function isCaipChainId(value) {
  return _superstruct.is.call(void 0, value, CaipChainIdStruct);
}
function isCaipNamespace(value) {
  return _superstruct.is.call(void 0, value, CaipNamespaceStruct);
}
function isCaipReference(value) {
  return _superstruct.is.call(void 0, value, CaipReferenceStruct);
}
function isCaipAccountId(value) {
  return _superstruct.is.call(void 0, value, CaipAccountIdStruct);
}
function isCaipAccountAddress(value) {
  return _superstruct.is.call(void 0, value, CaipAccountAddressStruct);
}
function parseCaipChainId(caipChainId) {
  const match = CAIP_CHAIN_ID_REGEX.exec(caipChainId);
  if (!_optionalChain([match, 'optionalAccess', _ => _.groups])) {
    throw new Error("Invalid CAIP chain ID.");
  }
  return {
    namespace: match.groups.namespace,
    reference: match.groups.reference
  };
}
function parseCaipAccountId(caipAccountId) {
  const match = CAIP_ACCOUNT_ID_REGEX.exec(caipAccountId);
  if (!_optionalChain([match, 'optionalAccess', _2 => _2.groups])) {
    throw new Error("Invalid CAIP account ID.");
  }
  return {
    address: match.groups.accountAddress,
    chainId: match.groups.chainId,
    chain: {
      namespace: match.groups.namespace,
      reference: match.groups.reference
    }
  };
}



















exports.CAIP_CHAIN_ID_REGEX = CAIP_CHAIN_ID_REGEX; exports.CAIP_NAMESPACE_REGEX = CAIP_NAMESPACE_REGEX; exports.CAIP_REFERENCE_REGEX = CAIP_REFERENCE_REGEX; exports.CAIP_ACCOUNT_ID_REGEX = CAIP_ACCOUNT_ID_REGEX; exports.CAIP_ACCOUNT_ADDRESS_REGEX = CAIP_ACCOUNT_ADDRESS_REGEX; exports.CaipChainIdStruct = CaipChainIdStruct; exports.CaipNamespaceStruct = CaipNamespaceStruct; exports.CaipReferenceStruct = CaipReferenceStruct; exports.CaipAccountIdStruct = CaipAccountIdStruct; exports.CaipAccountAddressStruct = CaipAccountAddressStruct; exports.isCaipChainId = isCaipChainId; exports.isCaipNamespace = isCaipNamespace; exports.isCaipReference = isCaipReference; exports.isCaipAccountId = isCaipAccountId; exports.isCaipAccountAddress = isCaipAccountAddress; exports.parseCaipChainId = parseCaipChainId; exports.parseCaipAccountId = parseCaipAccountId;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js ***!
  \**********************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));


var _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js");


var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/number.ts
var numberToHex = (value) => {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "number", "Value must be a number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, "Value must be a non-negative number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    Number.isSafeInteger(value),
    "Value is not a safe integer. Use `bigIntToHex` instead."
  );
  return _chunkQEPVHEP7js.add0x.call(void 0, value.toString(16));
};
var bigIntToHex = (value) => {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "bigint", "Value must be a bigint.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, "Value must be a non-negative bigint.");
  return _chunkQEPVHEP7js.add0x.call(void 0, value.toString(16));
};
var hexToNumber = (value) => {
  _chunkQEPVHEP7js.assertIsHexString.call(void 0, value);
  const numberValue = parseInt(value, 16);
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    Number.isSafeInteger(numberValue),
    "Value is not a safe integer. Use `hexToBigInt` instead."
  );
  return numberValue;
};
var hexToBigInt = (value) => {
  _chunkQEPVHEP7js.assertIsHexString.call(void 0, value);
  return BigInt(_chunkQEPVHEP7js.add0x.call(void 0, value));
};






exports.numberToHex = numberToHex; exports.bigIntToHex = bigIntToHex; exports.hexToNumber = hexToNumber; exports.hexToBigInt = hexToBigInt;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));



var _chunk3W5G4CYIjs = __webpack_require__(/*! ./chunk-3W5G4CYI.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js");

// src/collections.ts
var _map;
var FrozenMap = class {
  constructor(entries) {
    _chunk3W5G4CYIjs.__privateAdd.call(void 0, this, _map, void 0);
    _chunk3W5G4CYIjs.__privateSet.call(void 0, this, _map, new Map(entries));
    Object.freeze(this);
  }
  get size() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).size;
  }
  [Symbol.iterator]() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map)[Symbol.iterator]();
  }
  entries() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).entries();
  }
  forEach(callbackfn, thisArg) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).forEach(
      (value, key, _map2) => callbackfn.call(thisArg, value, key, this)
    );
  }
  get(key) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).get(key);
  }
  has(key) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).has(key);
  }
  keys() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).keys();
  }
  values() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([key, value]) => `${String(key)} => ${String(value)}`).join(", ")} ` : ""}}`;
  }
};
_map = new WeakMap();
var _set;
var FrozenSet = class {
  constructor(values) {
    _chunk3W5G4CYIjs.__privateAdd.call(void 0, this, _set, void 0);
    _chunk3W5G4CYIjs.__privateSet.call(void 0, this, _set, new Set(values));
    Object.freeze(this);
  }
  get size() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).size;
  }
  [Symbol.iterator]() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set)[Symbol.iterator]();
  }
  entries() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).entries();
  }
  forEach(callbackfn, thisArg) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).forEach(
      (value, value2, _set2) => callbackfn.call(thisArg, value, value2, this)
    );
  }
  has(value) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).has(value);
  }
  keys() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).keys();
  }
  values() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((member) => String(member)).join(", ")} ` : ""}}`;
  }
};
_set = new WeakMap();
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);




exports.FrozenMap = FrozenMap; exports.FrozenSet = FrozenSet;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));__webpack_require__(/*! ./chunk-5AVWINSB.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-5AVWINSB.js");





var _chunkVFXTVNXNjs = __webpack_require__(/*! ./chunk-VFXTVNXN.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js");
__webpack_require__(/*! ./chunk-LC2CRSWD.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js");


var _chunk4NIRTM4Mjs = __webpack_require__(/*! ./chunk-4NIRTM4M.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-4NIRTM4M.js");




var _chunk4RMX5YWEjs = __webpack_require__(/*! ./chunk-4RMX5YWE.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js");
__webpack_require__(/*! ./chunk-UOTVU7OQ.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js");










var _chunk4D6XQBHAjs = __webpack_require__(/*! ./chunk-4D6XQBHA.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js");


































var _chunkOLLG4H35js = __webpack_require__(/*! ./chunk-OLLG4H35.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-OLLG4H35.js");
__webpack_require__(/*! ./chunk-RKRGAFXY.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js");



var _chunk2LBGT4GHjs = __webpack_require__(/*! ./chunk-2LBGT4GH.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js");


















var _chunkU7ZUGCE7js = __webpack_require__(/*! ./chunk-U7ZUGCE7.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js");


var _chunkE4C7EW4Rjs = __webpack_require__(/*! ./chunk-E4C7EW4R.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js");


var _chunk6NZW4WK4js = __webpack_require__(/*! ./chunk-6NZW4WK4.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js");





var _chunkDHVKFDHQjs = __webpack_require__(/*! ./chunk-DHVKFDHQ.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js");































var _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js");





var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");






var _chunkIZC266HSjs = __webpack_require__(/*! ./chunk-IZC266HS.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-IZC266HS.js");












var _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js");



var _chunkZ2RGWDD7js = __webpack_require__(/*! ./chunk-Z2RGWDD7.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js");
__webpack_require__(/*! ./chunk-3W5G4CYI.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js");
__webpack_require__(/*! ./chunk-EQMZL4XU.js */ "./node_modules/@metamask/providers/node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js");
































































































































exports.AssertionError = _chunk6ZDHSOUVjs.AssertionError; exports.CAIP_ACCOUNT_ADDRESS_REGEX = _chunkU7ZUGCE7js.CAIP_ACCOUNT_ADDRESS_REGEX; exports.CAIP_ACCOUNT_ID_REGEX = _chunkU7ZUGCE7js.CAIP_ACCOUNT_ID_REGEX; exports.CAIP_CHAIN_ID_REGEX = _chunkU7ZUGCE7js.CAIP_CHAIN_ID_REGEX; exports.CAIP_NAMESPACE_REGEX = _chunkU7ZUGCE7js.CAIP_NAMESPACE_REGEX; exports.CAIP_REFERENCE_REGEX = _chunkU7ZUGCE7js.CAIP_REFERENCE_REGEX; exports.CaipAccountAddressStruct = _chunkU7ZUGCE7js.CaipAccountAddressStruct; exports.CaipAccountIdStruct = _chunkU7ZUGCE7js.CaipAccountIdStruct; exports.CaipChainIdStruct = _chunkU7ZUGCE7js.CaipChainIdStruct; exports.CaipNamespaceStruct = _chunkU7ZUGCE7js.CaipNamespaceStruct; exports.CaipReferenceStruct = _chunkU7ZUGCE7js.CaipReferenceStruct; exports.ChecksumStruct = _chunkE4C7EW4Rjs.ChecksumStruct; exports.Duration = _chunk4RMX5YWEjs.Duration; exports.ESCAPE_CHARACTERS_REGEXP = _chunkQVEKZRZ2js.ESCAPE_CHARACTERS_REGEXP; exports.FrozenMap = _chunkZ2RGWDD7js.FrozenMap; exports.FrozenSet = _chunkZ2RGWDD7js.FrozenSet; exports.HexAddressStruct = _chunkQEPVHEP7js.HexAddressStruct; exports.HexChecksumAddressStruct = _chunkQEPVHEP7js.HexChecksumAddressStruct; exports.HexStruct = _chunkQEPVHEP7js.HexStruct; exports.JsonRpcErrorStruct = _chunkOLLG4H35js.JsonRpcErrorStruct; exports.JsonRpcFailureStruct = _chunkOLLG4H35js.JsonRpcFailureStruct; exports.JsonRpcIdStruct = _chunkOLLG4H35js.JsonRpcIdStruct; exports.JsonRpcNotificationStruct = _chunkOLLG4H35js.JsonRpcNotificationStruct; exports.JsonRpcParamsStruct = _chunkOLLG4H35js.JsonRpcParamsStruct; exports.JsonRpcRequestStruct = _chunkOLLG4H35js.JsonRpcRequestStruct; exports.JsonRpcResponseStruct = _chunkOLLG4H35js.JsonRpcResponseStruct; exports.JsonRpcSuccessStruct = _chunkOLLG4H35js.JsonRpcSuccessStruct; exports.JsonRpcVersionStruct = _chunkOLLG4H35js.JsonRpcVersionStruct; exports.JsonSize = _chunkQVEKZRZ2js.JsonSize; exports.JsonStruct = _chunkOLLG4H35js.JsonStruct; exports.PendingJsonRpcResponseStruct = _chunkOLLG4H35js.PendingJsonRpcResponseStruct; exports.StrictHexStruct = _chunkQEPVHEP7js.StrictHexStruct; exports.UnsafeJsonStruct = _chunkOLLG4H35js.UnsafeJsonStruct; exports.VersionRangeStruct = _chunk4D6XQBHAjs.VersionRangeStruct; exports.VersionStruct = _chunk4D6XQBHAjs.VersionStruct; exports.add0x = _chunkQEPVHEP7js.add0x; exports.assert = _chunk6ZDHSOUVjs.assert; exports.assertExhaustive = _chunk6ZDHSOUVjs.assertExhaustive; exports.assertIsBytes = _chunkQEPVHEP7js.assertIsBytes; exports.assertIsHexString = _chunkQEPVHEP7js.assertIsHexString; exports.assertIsJsonRpcError = _chunkOLLG4H35js.assertIsJsonRpcError; exports.assertIsJsonRpcFailure = _chunkOLLG4H35js.assertIsJsonRpcFailure; exports.assertIsJsonRpcNotification = _chunkOLLG4H35js.assertIsJsonRpcNotification; exports.assertIsJsonRpcRequest = _chunkOLLG4H35js.assertIsJsonRpcRequest; exports.assertIsJsonRpcResponse = _chunkOLLG4H35js.assertIsJsonRpcResponse; exports.assertIsJsonRpcSuccess = _chunkOLLG4H35js.assertIsJsonRpcSuccess; exports.assertIsPendingJsonRpcResponse = _chunkOLLG4H35js.assertIsPendingJsonRpcResponse; exports.assertIsSemVerRange = _chunk4D6XQBHAjs.assertIsSemVerRange; exports.assertIsSemVerVersion = _chunk4D6XQBHAjs.assertIsSemVerVersion; exports.assertIsStrictHexString = _chunkQEPVHEP7js.assertIsStrictHexString; exports.assertStruct = _chunk6ZDHSOUVjs.assertStruct; exports.base64 = _chunk6NZW4WK4js.base64; exports.base64ToBytes = _chunkQEPVHEP7js.base64ToBytes; exports.bigIntToBytes = _chunkQEPVHEP7js.bigIntToBytes; exports.bigIntToHex = _chunkVFXTVNXNjs.bigIntToHex; exports.bytesToBase64 = _chunkQEPVHEP7js.bytesToBase64; exports.bytesToBigInt = _chunkQEPVHEP7js.bytesToBigInt; exports.bytesToHex = _chunkQEPVHEP7js.bytesToHex; exports.bytesToNumber = _chunkQEPVHEP7js.bytesToNumber; exports.bytesToSignedBigInt = _chunkQEPVHEP7js.bytesToSignedBigInt; exports.bytesToString = _chunkQEPVHEP7js.bytesToString; exports.calculateNumberSize = _chunkQVEKZRZ2js.calculateNumberSize; exports.calculateStringSize = _chunkQVEKZRZ2js.calculateStringSize; exports.concatBytes = _chunkQEPVHEP7js.concatBytes; exports.createBigInt = _chunkDHVKFDHQjs.createBigInt; exports.createBytes = _chunkDHVKFDHQjs.createBytes; exports.createDataView = _chunkQEPVHEP7js.createDataView; exports.createDeferredPromise = _chunk4NIRTM4Mjs.createDeferredPromise; exports.createHex = _chunkDHVKFDHQjs.createHex; exports.createModuleLogger = _chunk2LBGT4GHjs.createModuleLogger; exports.createNumber = _chunkDHVKFDHQjs.createNumber; exports.createProjectLogger = _chunk2LBGT4GHjs.createProjectLogger; exports.exactOptional = _chunkOLLG4H35js.exactOptional; exports.getChecksumAddress = _chunkQEPVHEP7js.getChecksumAddress; exports.getErrorMessage = _chunkIZC266HSjs.getErrorMessage; exports.getJsonRpcIdValidator = _chunkOLLG4H35js.getJsonRpcIdValidator; exports.getJsonSize = _chunkOLLG4H35js.getJsonSize; exports.getKnownPropertyNames = _chunkQVEKZRZ2js.getKnownPropertyNames; exports.getSafeJson = _chunkOLLG4H35js.getSafeJson; exports.gtRange = _chunk4D6XQBHAjs.gtRange; exports.gtVersion = _chunk4D6XQBHAjs.gtVersion; exports.hasProperty = _chunkQVEKZRZ2js.hasProperty; exports.hexToBigInt = _chunkVFXTVNXNjs.hexToBigInt; exports.hexToBytes = _chunkQEPVHEP7js.hexToBytes; exports.hexToNumber = _chunkVFXTVNXNjs.hexToNumber; exports.inMilliseconds = _chunk4RMX5YWEjs.inMilliseconds; exports.isASCII = _chunkQVEKZRZ2js.isASCII; exports.isBytes = _chunkQEPVHEP7js.isBytes; exports.isCaipAccountAddress = _chunkU7ZUGCE7js.isCaipAccountAddress; exports.isCaipAccountId = _chunkU7ZUGCE7js.isCaipAccountId; exports.isCaipChainId = _chunkU7ZUGCE7js.isCaipChainId; exports.isCaipNamespace = _chunkU7ZUGCE7js.isCaipNamespace; exports.isCaipReference = _chunkU7ZUGCE7js.isCaipReference; exports.isErrorWithCode = _chunkIZC266HSjs.isErrorWithCode; exports.isErrorWithMessage = _chunkIZC266HSjs.isErrorWithMessage; exports.isErrorWithStack = _chunkIZC266HSjs.isErrorWithStack; exports.isHexString = _chunkQEPVHEP7js.isHexString; exports.isJsonRpcError = _chunkOLLG4H35js.isJsonRpcError; exports.isJsonRpcFailure = _chunkOLLG4H35js.isJsonRpcFailure; exports.isJsonRpcNotification = _chunkOLLG4H35js.isJsonRpcNotification; exports.isJsonRpcRequest = _chunkOLLG4H35js.isJsonRpcRequest; exports.isJsonRpcResponse = _chunkOLLG4H35js.isJsonRpcResponse; exports.isJsonRpcSuccess = _chunkOLLG4H35js.isJsonRpcSuccess; exports.isNonEmptyArray = _chunkQVEKZRZ2js.isNonEmptyArray; exports.isNullOrUndefined = _chunkQVEKZRZ2js.isNullOrUndefined; exports.isObject = _chunkQVEKZRZ2js.isObject; exports.isPendingJsonRpcResponse = _chunkOLLG4H35js.isPendingJsonRpcResponse; exports.isPlainObject = _chunkQVEKZRZ2js.isPlainObject; exports.isStrictHexString = _chunkQEPVHEP7js.isStrictHexString; exports.isValidChecksumAddress = _chunkQEPVHEP7js.isValidChecksumAddress; exports.isValidHexAddress = _chunkQEPVHEP7js.isValidHexAddress; exports.isValidJson = _chunkOLLG4H35js.isValidJson; exports.isValidSemVerRange = _chunk4D6XQBHAjs.isValidSemVerRange; exports.isValidSemVerVersion = _chunk4D6XQBHAjs.isValidSemVerVersion; exports.jsonrpc2 = _chunkOLLG4H35js.jsonrpc2; exports.numberToBytes = _chunkQEPVHEP7js.numberToBytes; exports.numberToHex = _chunkVFXTVNXNjs.numberToHex; exports.object = _chunkOLLG4H35js.object; exports.parseCaipAccountId = _chunkU7ZUGCE7js.parseCaipAccountId; exports.parseCaipChainId = _chunkU7ZUGCE7js.parseCaipChainId; exports.remove0x = _chunkQEPVHEP7js.remove0x; exports.satisfiesVersionRange = _chunk4D6XQBHAjs.satisfiesVersionRange; exports.signedBigIntToBytes = _chunkQEPVHEP7js.signedBigIntToBytes; exports.stringToBytes = _chunkQEPVHEP7js.stringToBytes; exports.timeSince = _chunk4RMX5YWEjs.timeSince; exports.valueToBytes = _chunkQEPVHEP7js.valueToBytes; exports.wrapError = _chunkIZC266HSjs.wrapError;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/detect-browser/es/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/detect-browser/es/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BotInfo: () => (/* binding */ BotInfo),
/* harmony export */   BrowserInfo: () => (/* binding */ BrowserInfo),
/* harmony export */   NodeInfo: () => (/* binding */ NodeInfo),
/* harmony export */   ReactNativeInfo: () => (/* binding */ ReactNativeInfo),
/* harmony export */   SearchBotDeviceInfo: () => (/* binding */ SearchBotDeviceInfo),
/* harmony export */   browserName: () => (/* binding */ browserName),
/* harmony export */   detect: () => (/* binding */ detect),
/* harmony export */   detectOS: () => (/* binding */ detectOS),
/* harmony export */   getNodeVersion: () => (/* binding */ getNodeVersion),
/* harmony export */   parseUserAgent: () => (/* binding */ parseUserAgent)
/* harmony export */ });
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = /** @class */ (function () {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = 'browser';
    }
    return BrowserInfo;
}());

var NodeInfo = /** @class */ (function () {
    function NodeInfo(version) {
        this.version = version;
        this.type = 'node';
        this.name = 'node';
        this.os = process.platform;
    }
    return NodeInfo;
}());

var SearchBotDeviceInfo = /** @class */ (function () {
    function SearchBotDeviceInfo(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = 'bot-device';
    }
    return SearchBotDeviceInfo;
}());

var BotInfo = /** @class */ (function () {
    function BotInfo() {
        this.type = 'bot';
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}());

var ReactNativeInfo = /** @class */ (function () {
    function ReactNativeInfo() {
        this.type = 'react-native';
        this.name = 'react-native';
        this.version = null;
        this.os = null;
    }
    return ReactNativeInfo;
}());

// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /EdgA?\/([0-9\.]+)/],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['pie', /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    ['pie', /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
    ['netfront', /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FB[AS]V\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['curl', /^curl\/([0-9\.]+)$/],
    ['searchbot', SEARCHBOX_UA_REGEX],
];
var operatingSystemRules = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/],
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof document === 'undefined' &&
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative') {
        return new ReactNativeInfo();
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
function matchUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return (ua !== '' &&
        userAgentRules.reduce(function (matched, _a) {
            var browser = _a[0], regex = _a[1];
            if (matched) {
                return matched;
            }
            var uaMatch = regex.exec(ua);
            return !!uaMatch && [browser, uaMatch];
        }, false));
}
function browserName(ua) {
    var data = matchUserAgent(ua);
    return data ? data[0] : null;
}
function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    // Do not use RegExp for split operation as some browser do not support it (See: http://blog.stevenlevithan.com/archives/cross-browser-split)
    var versionParts = match[1] && match[1].split('.').join('_').split('_').slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
        }
    }
    else {
        versionParts = [];
    }
    var version = versionParts.join('.');
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.exec(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
        output.push('0');
    }
    return output;
}


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/extension-port-stream/dist/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/extension-port-stream/dist/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const readable_stream_1 = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");
class PortDuplexStream extends readable_stream_1.Duplex {
    /**
     * @param port - An instance of WebExtensions Runtime.Port. See:
     * {@link https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/Port}
     */
    constructor(port) {
        super({ objectMode: true });
        this._port = port;
        this._port.onMessage.addListener((msg) => this._onMessage(msg));
        this._port.onDisconnect.addListener(() => this._onDisconnect());
        this._log = () => null;
    }
    /**
     * Callback triggered when a message is received from
     * the remote Port associated with this Stream.
     *
     * @param msg - Payload from the onMessage listener of the port
     */
    _onMessage(msg) {
        if (Buffer.isBuffer(msg)) {
            const data = Buffer.from(msg);
            this._log(data, false);
            this.push(data);
        }
        else {
            this._log(msg, false);
            this.push(msg);
        }
    }
    /**
     * Callback triggered when the remote Port associated with this Stream
     * disconnects.
     */
    _onDisconnect() {
        this.destroy();
    }
    /**
     * Explicitly sets read operations to a no-op.
     */
    _read() {
        return undefined;
    }
    /**
     * Called internally when data should be written to this writable stream.
     *
     * @param msg - Arbitrary object to write
     * @param encoding - Encoding to use when writing payload
     * @param cb - Called when writing is complete or an error occurs
     */
    _write(msg, _encoding, cb) {
        try {
            if (Buffer.isBuffer(msg)) {
                const data = msg.toJSON();
                data._isBuffer = true;
                this._log(data, true);
                this._port.postMessage(data);
            }
            else {
                this._log(msg, true);
                this._port.postMessage(msg);
            }
        }
        catch (error) {
            return cb(new Error('PortDuplexStream - disconnected'));
        }
        return cb();
    }
    /**
     * Call to set a custom logger for incoming/outgoing messages
     *
     * @param log - the logger function
     */
    _setLogger(log) {
        this._log = log;
    }
}
exports["default"] = PortDuplexStream;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/json-rpc-middleware-stream/dist/createEngineStream.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/json-rpc-middleware-stream/dist/createEngineStream.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const readable_stream_1 = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");
/**
 * Takes a JsonRpcEngine and returns a Duplex stream wrapping it.
 *
 * @param opts - Options bag.
 * @param opts.engine - The JsonRpcEngine to wrap in a stream.
 * @returns The stream wrapping the engine.
 */
function createEngineStream(opts) {
    if (!(opts === null || opts === void 0 ? void 0 : opts.engine)) {
        throw new Error('Missing engine parameter!');
    }
    const { engine } = opts;
    const stream = new readable_stream_1.Duplex({ objectMode: true, read: () => undefined, write });
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            stream.push(message);
        });
    }
    return stream;
    /**
     * Write a JSON-RPC request to the stream.
     *
     * @param req - The JSON-rpc request.
     * @param _encoding - The stream encoding, not used.
     * @param streamWriteCallback - The stream write callback.
     */
    function write(req, _encoding, streamWriteCallback) {
        engine.handle(req, (_err, res) => {
            stream.push(res);
        });
        streamWriteCallback();
    }
}
exports["default"] = createEngineStream;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/json-rpc-middleware-stream/dist/createStreamMiddleware.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/json-rpc-middleware-stream/dist/createStreamMiddleware.js ***!
  \*****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const safe_event_emitter_1 = __importDefault(__webpack_require__(/*! @metamask/safe-event-emitter */ "./node_modules/@metamask/providers/node_modules/@metamask/safe-event-emitter/index.js"));
const readable_stream_1 = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");
/**
 * Creates a JsonRpcEngine middleware with an associated Duplex stream and
 * EventEmitter. The middleware, and by extension stream, assume that middleware
 * parameters are properly formatted. No runtime type checking or validation is
 * performed.
 *
 * @param options - Configuration options for middleware.
 * @returns The event emitter, middleware, and stream.
 */
function createStreamMiddleware(options = {}) {
    const idMap = {}; // TODO: replace with actual Map
    const stream = new readable_stream_1.Duplex({
        objectMode: true,
        read: () => undefined,
        write: processMessage,
    });
    const events = new safe_event_emitter_1.default();
    const middleware = (req, res, next, end) => {
        // register request on id map *before* sending it to the stream, to avoid race issues
        idMap[req.id] = { req, res, next, end };
        // write req to stream
        sendToStream(req);
    };
    return { events, middleware, stream };
    /**
     * Forwards JSON-RPC request to the stream.
     *
     * @param req - The JSON-RPC request object.
     */
    function sendToStream(req) {
        // TODO: limiting retries could be implemented here
        stream.push(req);
    }
    /**
     * Writes a JSON-RPC object to the stream.
     *
     * @param res - The JSON-RPC response object.
     * @param _encoding - The stream encoding, not used.
     * @param streamWriteCallback - The stream write callback.
     */
    function processMessage(res, _encoding, streamWriteCallback) {
        let errorObj = null;
        try {
            const isNotification = !res.id;
            if (isNotification) {
                processNotification(res);
            }
            else {
                processResponse(res);
            }
        }
        catch (_err) {
            errorObj = _err;
        }
        // continue processing stream
        streamWriteCallback(errorObj);
    }
    /**
     * Processes a JSON-RPC response.
     *
     * @param res - The response to process.
     */
    function processResponse(res) {
        const responseId = res.id;
        const context = idMap[responseId];
        if (!context) {
            console.warn(`StreamMiddleware - Unknown response id "${responseId}"`);
            return;
        }
        delete idMap[responseId];
        // copy whole res onto original res
        Object.assign(context.res, res);
        // run callback on empty stack,
        // prevent internal stream-handler from catching errors
        setTimeout(context.end);
    }
    /**
     * Processes a JSON-RPC notification.
     *
     * @param notif - The notification to process.
     */
    function processNotification(notif) {
        if ((options === null || options === void 0 ? void 0 : options.retryOnMessage) && notif.method === options.retryOnMessage) {
            retryStuckRequests();
        }
        events.emit('notification', notif);
    }
    /**
     * Retry pending requests.
     */
    function retryStuckRequests() {
        Object.values(idMap).forEach(({ req, retryCount = 0 }) => {
            // Avoid retrying requests without an id - they cannot have matching responses so retry logic doesn't apply
            // Check for retry count below ensure that a request is not retried more than 3 times
            if (!req.id) {
                return;
            }
            if (retryCount >= 3) {
                throw new Error(`StreamMiddleware - Retry limit exceeded for request id "${req.id}"`);
            }
            idMap[req.id].retryCount = retryCount + 1;
            sendToStream(req);
        });
    }
}
exports["default"] = createStreamMiddleware;


/***/ }),

/***/ "./node_modules/@metamask/providers/node_modules/json-rpc-middleware-stream/dist/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/node_modules/json-rpc-middleware-stream/dist/index.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createStreamMiddleware = exports.createEngineStream = void 0;
const createEngineStream_1 = __importDefault(__webpack_require__(/*! ./createEngineStream */ "./node_modules/@metamask/providers/node_modules/json-rpc-middleware-stream/dist/createEngineStream.js"));
exports.createEngineStream = createEngineStream_1.default;
const createStreamMiddleware_1 = __importDefault(__webpack_require__(/*! ./createStreamMiddleware */ "./node_modules/@metamask/providers/node_modules/json-rpc-middleware-stream/dist/createStreamMiddleware.js"));
exports.createStreamMiddleware = createStreamMiddleware_1.default;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/dist/classes.js":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/classes.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EthereumProviderError = exports.JsonRpcError = void 0;
const utils_1 = __webpack_require__(/*! @metamask/utils */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/index.js");
const fast_safe_stringify_1 = __importDefault(__webpack_require__(/*! fast-safe-stringify */ "./node_modules/fast-safe-stringify/index.js"));
const utils_2 = __webpack_require__(/*! ./utils */ "./node_modules/@metamask/rpc-errors/dist/utils.js");
/**
 * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors
 * per EIP-1474.
 *
 * Permits any integer error code.
 */
class JsonRpcError extends Error {
    constructor(code, message, data) {
        if (!Number.isInteger(code)) {
            throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== 'string') {
            throw new Error('"message" must be a non-empty string.');
        }
        super(message);
        this.code = code;
        if (data !== undefined) {
            this.data = data;
        }
    }
    /**
     * Get the error as JSON-serializable object.
     *
     * @returns A plain object with all public class properties.
     */
    serialize() {
        const serialized = {
            code: this.code,
            message: this.message,
        };
        if (this.data !== undefined) {
            // `this.data` is not guaranteed to be a plain object, but this simplifies
            // the type guard below. We can safely cast it because we know it's a
            // JSON-serializable value.
            serialized.data = this.data;
            if ((0, utils_1.isPlainObject)(this.data)) {
                serialized.data.cause = (0, utils_2.serializeCause)(this.data.cause);
            }
        }
        if (this.stack) {
            serialized.stack = this.stack;
        }
        return serialized;
    }
    /**
     * Get a string representation of the serialized error, omitting any circular
     * references.
     *
     * @returns A string representation of the serialized error.
     */
    toString() {
        return (0, fast_safe_stringify_1.default)(this.serialize(), stringifyReplacer, 2);
    }
}
exports.JsonRpcError = JsonRpcError;
/**
 * Error subclass implementing Ethereum Provider errors per EIP-1193.
 * Permits integer error codes in the [ 1000 <= 4999 ] range.
 */
class EthereumProviderError extends JsonRpcError {
    /**
     * Create an Ethereum Provider JSON-RPC error.
     *
     * @param code - The JSON-RPC error code. Must be an integer in the
     * `1000 <= n <= 4999` range.
     * @param message - The JSON-RPC error message.
     * @param data - Optional data to include in the error.
     */
    constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
            throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
    }
}
exports.EthereumProviderError = EthereumProviderError;
/**
 * Check if the given code is a valid JSON-RPC error code.
 *
 * @param code - The code to check.
 * @returns Whether the code is valid.
 */
function isValidEthProviderCode(code) {
    return Number.isInteger(code) && code >= 1000 && code <= 4999;
}
/**
 * A JSON replacer function that omits circular references.
 *
 * @param _ - The key being replaced.
 * @param value - The value being replaced.
 * @returns The value to use in place of the original value.
 */
function stringifyReplacer(_, value) {
    if (value === '[Circular]') {
        return undefined;
    }
    return value;
}


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/dist/error-constants.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/error-constants.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorValues = exports.errorCodes = void 0;
exports.errorCodes = {
    rpc: {
        invalidInput: -32000,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603,
    },
    provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901,
    },
};
/* eslint-disable @typescript-eslint/naming-convention */
exports.errorValues = {
    '-32700': {
        standard: 'JSON RPC 2.0',
        message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
    },
    '-32600': {
        standard: 'JSON RPC 2.0',
        message: 'The JSON sent is not a valid Request object.',
    },
    '-32601': {
        standard: 'JSON RPC 2.0',
        message: 'The method does not exist / is not available.',
    },
    '-32602': {
        standard: 'JSON RPC 2.0',
        message: 'Invalid method parameter(s).',
    },
    '-32603': {
        standard: 'JSON RPC 2.0',
        message: 'Internal JSON-RPC error.',
    },
    '-32000': {
        standard: 'EIP-1474',
        message: 'Invalid input.',
    },
    '-32001': {
        standard: 'EIP-1474',
        message: 'Resource not found.',
    },
    '-32002': {
        standard: 'EIP-1474',
        message: 'Resource unavailable.',
    },
    '-32003': {
        standard: 'EIP-1474',
        message: 'Transaction rejected.',
    },
    '-32004': {
        standard: 'EIP-1474',
        message: 'Method not supported.',
    },
    '-32005': {
        standard: 'EIP-1474',
        message: 'Request limit exceeded.',
    },
    '4001': {
        standard: 'EIP-1193',
        message: 'User rejected the request.',
    },
    '4100': {
        standard: 'EIP-1193',
        message: 'The requested account and/or method has not been authorized by the user.',
    },
    '4200': {
        standard: 'EIP-1193',
        message: 'The requested method is not supported by this Ethereum provider.',
    },
    '4900': {
        standard: 'EIP-1193',
        message: 'The provider is disconnected from all chains.',
    },
    '4901': {
        standard: 'EIP-1193',
        message: 'The provider is disconnected from the specified chain.',
    },
};
/* eslint-enable @typescript-eslint/naming-convention */


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/dist/errors.js":
/*!**********************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.providerErrors = exports.rpcErrors = void 0;
const classes_1 = __webpack_require__(/*! ./classes */ "./node_modules/@metamask/rpc-errors/dist/classes.js");
const error_constants_1 = __webpack_require__(/*! ./error-constants */ "./node_modules/@metamask/rpc-errors/dist/error-constants.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@metamask/rpc-errors/dist/utils.js");
exports.rpcErrors = {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    parse: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    invalidRequest: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    invalidParams: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    methodNotFound: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    internal: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     *
     * @param opts - The error options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    server: (opts) => {
        if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
            throw new Error('Ethereum RPC Server errors must provide single object argument.');
        }
        const { code } = opts;
        if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
        }
        return getJsonRpcError(code, opts);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    invalidInput: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    resourceNotFound: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    resourceUnavailable: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    transactionRejected: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    methodNotSupported: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */
    limitExceeded: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg),
};
exports.providerErrors = {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */
    userRejectedRequest: (arg) => {
        return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
    },
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */
    unauthorized: (arg) => {
        return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
    },
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */
    unsupportedMethod: (arg) => {
        return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
    },
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */
    disconnected: (arg) => {
        return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
    },
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */
    chainDisconnected: (arg) => {
        return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
    },
    /**
     * Get a custom Ethereum Provider error.
     *
     * @param opts - The error options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */
    custom: (opts) => {
        if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
            throw new Error('Ethereum Provider custom errors must provide single object argument.');
        }
        const { code, message, data } = opts;
        if (!message || typeof message !== 'string') {
            throw new Error('"message" must be a nonempty string');
        }
        return new classes_1.EthereumProviderError(code, message, data);
    },
};
/**
 * Get a generic JSON-RPC error class instance.
 *
 * @param code - The error code.
 * @param arg - The error message or options bag.
 * @returns An instance of the {@link JsonRpcError} class.
 */
function getJsonRpcError(code, arg) {
    const [message, data] = parseOpts(arg);
    return new classes_1.JsonRpcError(code, message ?? (0, utils_1.getMessageFromCode)(code), data);
}
/**
 * Get an Ethereum Provider error class instance.
 *
 * @param code - The error code.
 * @param arg - The error message or options bag.
 * @returns An instance of the {@link EthereumProviderError} class.
 */
function getEthProviderError(code, arg) {
    const [message, data] = parseOpts(arg);
    return new classes_1.EthereumProviderError(code, message ?? (0, utils_1.getMessageFromCode)(code), data);
}
/**
 * Get an error message and optional data from an options bag.
 *
 * @param arg - The error message or options bag.
 * @returns A tuple containing the error message and optional data.
 */
function parseOpts(arg) {
    if (arg) {
        if (typeof arg === 'string') {
            return [arg];
        }
        else if (typeof arg === 'object' && !Array.isArray(arg)) {
            const { message, data } = arg;
            if (message && typeof message !== 'string') {
                throw new Error('Must specify string message.');
            }
            return [message ?? undefined, data];
        }
    }
    return [];
}


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCodes = exports.providerErrors = exports.rpcErrors = exports.getMessageFromCode = exports.serializeError = exports.serializeCause = exports.EthereumProviderError = exports.JsonRpcError = void 0;
var classes_1 = __webpack_require__(/*! ./classes */ "./node_modules/@metamask/rpc-errors/dist/classes.js");
Object.defineProperty(exports, "JsonRpcError", ({ enumerable: true, get: function () { return classes_1.JsonRpcError; } }));
Object.defineProperty(exports, "EthereumProviderError", ({ enumerable: true, get: function () { return classes_1.EthereumProviderError; } }));
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@metamask/rpc-errors/dist/utils.js");
Object.defineProperty(exports, "serializeCause", ({ enumerable: true, get: function () { return utils_1.serializeCause; } }));
Object.defineProperty(exports, "serializeError", ({ enumerable: true, get: function () { return utils_1.serializeError; } }));
Object.defineProperty(exports, "getMessageFromCode", ({ enumerable: true, get: function () { return utils_1.getMessageFromCode; } }));
var errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@metamask/rpc-errors/dist/errors.js");
Object.defineProperty(exports, "rpcErrors", ({ enumerable: true, get: function () { return errors_1.rpcErrors; } }));
Object.defineProperty(exports, "providerErrors", ({ enumerable: true, get: function () { return errors_1.providerErrors; } }));
var error_constants_1 = __webpack_require__(/*! ./error-constants */ "./node_modules/@metamask/rpc-errors/dist/error-constants.js");
Object.defineProperty(exports, "errorCodes", ({ enumerable: true, get: function () { return error_constants_1.errorCodes; } }));


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/dist/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeCause = exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
const utils_1 = __webpack_require__(/*! @metamask/utils */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/index.js");
const error_constants_1 = __webpack_require__(/*! ./error-constants */ "./node_modules/@metamask/rpc-errors/dist/error-constants.js");
const FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
const FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';
const FALLBACK_ERROR = {
    code: FALLBACK_ERROR_CODE,
    message: getMessageFromCode(FALLBACK_ERROR_CODE),
};
exports.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';
/**
 * Gets the message for a given code, or a fallback message if the code has
 * no corresponding message.
 *
 * @param code - The error code.
 * @param fallbackMessage - The fallback message to use if the code has no
 * corresponding message.
 * @returns The message for the given code, or the fallback message if the code
 * has no corresponding message.
 */
function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
    if (isValidCode(code)) {
        const codeString = code.toString();
        if ((0, utils_1.hasProperty)(error_constants_1.errorValues, codeString)) {
            return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
            return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
    }
    return fallbackMessage;
}
exports.getMessageFromCode = getMessageFromCode;
/**
 * Returns whether the given code is valid.
 * A code is valid if it is an integer.
 *
 * @param code - The error code.
 * @returns Whether the given code is valid.
 */
function isValidCode(code) {
    return Number.isInteger(code);
}
exports.isValidCode = isValidCode;
/**
 * Serializes the given error to an Ethereum JSON RPC-compatible error object.
 * If the given error is not fully compatible, it will be preserved on the
 * returned object's data.cause property.
 *
 * @param error - The error to serialize.
 * @param options - Options bag.
 * @param options.fallbackError - The error to return if the given error is
 * not compatible. Should be a JSON serializable value.
 * @param options.shouldIncludeStack - Whether to include the error's stack
 * on the returned object.
 * @returns The serialized error.
 */
function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true } = {}) {
    if (!(0, utils_1.isJsonRpcError)(fallbackError)) {
        throw new Error('Must provide fallback error with integer number code and string message.');
    }
    const serialized = buildError(error, fallbackError);
    if (!shouldIncludeStack) {
        delete serialized.stack;
    }
    return serialized;
}
exports.serializeError = serializeError;
/**
 * Construct a JSON-serializable object given an error and a JSON serializable `fallbackError`
 *
 * @param error - The error in question.
 * @param fallbackError - A JSON serializable fallback error.
 * @returns A JSON serializable error object.
 */
function buildError(error, fallbackError) {
    // If an error specifies a `serialize` function, we call it and return the result.
    if (error &&
        typeof error === 'object' &&
        'serialize' in error &&
        typeof error.serialize === 'function') {
        return error.serialize();
    }
    if ((0, utils_1.isJsonRpcError)(error)) {
        return error;
    }
    // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.
    const cause = serializeCause(error);
    const fallbackWithCause = {
        ...fallbackError,
        data: { cause },
    };
    return fallbackWithCause;
}
/**
 * Check if the given code is a valid JSON-RPC server error code.
 *
 * @param code - The error code.
 * @returns Whether the given code is a valid JSON-RPC server error code.
 */
function isJsonRpcServerError(code) {
    return code >= -32099 && code <= -32000;
}
/**
 * Serializes an unknown error to be used as the `cause` in a fallback error.
 *
 * @param error - The unknown error.
 * @returns A JSON-serializable object containing as much information about the original error as possible.
 */
function serializeCause(error) {
    if (Array.isArray(error)) {
        return error.map((entry) => {
            if ((0, utils_1.isValidJson)(entry)) {
                return entry;
            }
            else if ((0, utils_1.isObject)(entry)) {
                return serializeObject(entry);
            }
            return null;
        });
    }
    else if ((0, utils_1.isObject)(error)) {
        return serializeObject(error);
    }
    if ((0, utils_1.isValidJson)(error)) {
        return error;
    }
    return null;
}
exports.serializeCause = serializeCause;
/**
 * Extracts all JSON-serializable properties from an object.
 *
 * @param object - The object in question.
 * @returns An object containing all the JSON-serializable properties.
 */
function serializeObject(object) {
    return Object.getOwnPropertyNames(object).reduce((acc, key) => {
        const value = object[key];
        if ((0, utils_1.isValidJson)(value)) {
            acc[key] = value;
        }
        return acc;
    }, {});
}


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/logging.ts
var _debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"); var _debug2 = _interopRequireDefault(_debug);
var globalLogger = _debug2.default.call(void 0, "metamask");
function createProjectLogger(projectName) {
  return globalLogger.extend(projectName);
}
function createModuleLogger(projectLogger, moduleName) {
  return projectLogger.extend(moduleName);
}




exports.createProjectLogger = createProjectLogger; exports.createModuleLogger = createModuleLogger;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};





exports.__privateGet = __privateGet; exports.__privateAdd = __privateAdd; exports.__privateSet = __privateSet;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/versions.ts






var _semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var VersionStruct = _superstruct.refine.call(void 0, 
  _superstruct.string.call(void 0, ),
  "Version",
  (value) => {
    if (_semver.valid.call(void 0, value) === null) {
      return `Expected SemVer version, got "${value}"`;
    }
    return true;
  }
);
var VersionRangeStruct = _superstruct.refine.call(void 0, 
  _superstruct.string.call(void 0, ),
  "Version range",
  (value) => {
    if (_semver.validRange.call(void 0, value) === null) {
      return `Expected SemVer range, got "${value}"`;
    }
    return true;
  }
);
function isValidSemVerVersion(version) {
  return _superstruct.is.call(void 0, version, VersionStruct);
}
function isValidSemVerRange(versionRange) {
  return _superstruct.is.call(void 0, versionRange, VersionRangeStruct);
}
function assertIsSemVerVersion(version) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, version, VersionStruct);
}
function assertIsSemVerRange(range) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, range, VersionRangeStruct);
}
function gtVersion(version1, version2) {
  return _semver.gt.call(void 0, version1, version2);
}
function gtRange(version, range) {
  return _semver.gtr.call(void 0, version, range);
}
function satisfiesVersionRange(version, versionRange) {
  return _semver.satisfies.call(void 0, version, versionRange, {
    includePrerelease: true
  });
}











exports.VersionStruct = VersionStruct; exports.VersionRangeStruct = VersionRangeStruct; exports.isValidSemVerVersion = isValidSemVerVersion; exports.isValidSemVerRange = isValidSemVerRange; exports.assertIsSemVerVersion = assertIsSemVerVersion; exports.assertIsSemVerRange = assertIsSemVerRange; exports.gtVersion = gtVersion; exports.gtRange = gtRange; exports.satisfiesVersionRange = satisfiesVersionRange;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-4NIRTM4M.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-4NIRTM4M.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));// src/promise.ts
function createDeferredPromise({
  suppressUnhandledRejection = false
} = {}) {
  let resolve;
  let reject;
  const promise = new Promise(
    (innerResolve, innerReject) => {
      resolve = innerResolve;
      reject = innerReject;
    }
  );
  if (suppressUnhandledRejection) {
    promise.catch((_error) => {
    });
  }
  return { promise, resolve, reject };
}



exports.createDeferredPromise = createDeferredPromise;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));// src/time.ts
var Duration = /* @__PURE__ */ ((Duration2) => {
  Duration2[Duration2["Millisecond"] = 1] = "Millisecond";
  Duration2[Duration2["Second"] = 1e3] = "Second";
  Duration2[Duration2["Minute"] = 6e4] = "Minute";
  Duration2[Duration2["Hour"] = 36e5] = "Hour";
  Duration2[Duration2["Day"] = 864e5] = "Day";
  Duration2[Duration2["Week"] = 6048e5] = "Week";
  Duration2[Duration2["Year"] = 31536e6] = "Year";
  return Duration2;
})(Duration || {});
var isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
var assertIsNonNegativeInteger = (number, name) => {
  if (!isNonNegativeInteger(number)) {
    throw new Error(
      `"${name}" must be a non-negative integer. Received: "${number}".`
    );
  }
};
function inMilliseconds(count, duration) {
  assertIsNonNegativeInteger(count, "count");
  return count * duration;
}
function timeSince(timestamp) {
  assertIsNonNegativeInteger(timestamp, "timestamp");
  return Date.now() - timestamp;
}





exports.Duration = Duration; exports.inMilliseconds = inMilliseconds; exports.timeSince = timeSince;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-5AVWINSB.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-5AVWINSB.js ***!
  \***********************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/base64.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var base64 = (struct, options = {}) => {
  const paddingRequired = _nullishCoalesce(options.paddingRequired, () => ( false));
  const characterSet = _nullishCoalesce(options.characterSet, () => ( "base64"));
  let letters;
  if (characterSet === "base64") {
    letters = String.raw`[A-Za-z0-9+\/]`;
  } else {
    _chunk6ZDHSOUVjs.assert.call(void 0, characterSet === "base64url");
    letters = String.raw`[-_A-Za-z0-9]`;
  }
  let re;
  if (paddingRequired) {
    re = new RegExp(
      `^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`,
      "u"
    );
  } else {
    re = new RegExp(
      `^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`,
      "u"
    );
  }
  return _superstruct.pattern.call(void 0, struct, re);
};



exports.base64 = base64;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkIZC266HSjs = __webpack_require__(/*! ./chunk-IZC266HS.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-IZC266HS.js");

// src/assert.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
function isConstructable(fn) {
  return Boolean(typeof _optionalChain([fn, 'optionalAccess', _ => _.prototype, 'optionalAccess', _2 => _2.constructor, 'optionalAccess', _3 => _3.name]) === "string");
}
function getErrorMessageWithoutTrailingPeriod(error) {
  return _chunkIZC266HSjs.getErrorMessage.call(void 0, error).replace(/\.$/u, "");
}
function getError(ErrorWrapper, message) {
  if (isConstructable(ErrorWrapper)) {
    return new ErrorWrapper({
      message
    });
  }
  return ErrorWrapper({
    message
  });
}
var AssertionError = class extends Error {
  constructor(options) {
    super(options.message);
    this.code = "ERR_ASSERTION";
  }
};
function assert(value, message = "Assertion failed.", ErrorWrapper = AssertionError) {
  if (!value) {
    if (message instanceof Error) {
      throw message;
    }
    throw getError(ErrorWrapper, message);
  }
}
function assertStruct(value, struct, errorPrefix = "Assertion failed", ErrorWrapper = AssertionError) {
  try {
    _superstruct.assert.call(void 0, value, struct);
  } catch (error) {
    throw getError(
      ErrorWrapper,
      `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`
    );
  }
}
function assertExhaustive(_object) {
  throw new Error(
    "Invalid branch reached. Should be detected during compilation."
  );
}






exports.AssertionError = AssertionError; exports.assert = assert; exports.assertStruct = assertStruct; exports.assertExhaustive = assertExhaustive;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));



var _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js");


var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/coercers.ts









var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var NumberLikeStruct = _superstruct.union.call(void 0, [_superstruct.number.call(void 0, ), _superstruct.bigint.call(void 0, ), _superstruct.string.call(void 0, ), _chunkQEPVHEP7js.StrictHexStruct]);
var NumberCoercer = _superstruct.coerce.call(void 0, _superstruct.number.call(void 0, ), NumberLikeStruct, Number);
var BigIntCoercer = _superstruct.coerce.call(void 0, _superstruct.bigint.call(void 0, ), NumberLikeStruct, BigInt);
var BytesLikeStruct = _superstruct.union.call(void 0, [_chunkQEPVHEP7js.StrictHexStruct, _superstruct.instance.call(void 0, Uint8Array)]);
var BytesCoercer = _superstruct.coerce.call(void 0, 
  _superstruct.instance.call(void 0, Uint8Array),
  _superstruct.union.call(void 0, [_chunkQEPVHEP7js.StrictHexStruct]),
  _chunkQEPVHEP7js.hexToBytes
);
var HexCoercer = _superstruct.coerce.call(void 0, _chunkQEPVHEP7js.StrictHexStruct, _superstruct.instance.call(void 0, Uint8Array), _chunkQEPVHEP7js.bytesToHex);
function createNumber(value) {
  try {
    const result = _superstruct.create.call(void 0, value, NumberCoercer);
    _chunk6ZDHSOUVjs.assert.call(void 0, 
      Number.isFinite(result),
      `Expected a number-like value, got "${value}".`
    );
    return result;
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(`Expected a number-like value, got "${value}".`);
    }
    throw error;
  }
}
function createBigInt(value) {
  try {
    return _superstruct.create.call(void 0, value, BigIntCoercer);
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(
        `Expected a number-like value, got "${String(error.value)}".`
      );
    }
    throw error;
  }
}
function createBytes(value) {
  if (typeof value === "string" && value.toLowerCase() === "0x") {
    return new Uint8Array();
  }
  try {
    return _superstruct.create.call(void 0, value, BytesCoercer);
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(
        `Expected a bytes-like value, got "${String(error.value)}".`
      );
    }
    throw error;
  }
}
function createHex(value) {
  if (value instanceof Uint8Array && value.length === 0 || typeof value === "string" && value.toLowerCase() === "0x") {
    return "0x";
  }
  try {
    return _superstruct.create.call(void 0, value, HexCoercer);
  } catch (error) {
    if (error instanceof _superstruct.StructError) {
      throw new Error(
        `Expected a bytes-like value, got "${String(error.value)}".`
      );
    }
    throw error;
  }
}






exports.createNumber = createNumber; exports.createBigInt = createBigInt; exports.createBytes = createBytes; exports.createHex = createHex;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));

var _chunk6NZW4WK4js = __webpack_require__(/*! ./chunk-6NZW4WK4.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js");

// src/checksum.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var ChecksumStruct = _superstruct.size.call(void 0, 
  _chunk6NZW4WK4js.base64.call(void 0, _superstruct.string.call(void 0, ), { paddingRequired: true }),
  44,
  44
);



exports.ChecksumStruct = ChecksumStruct;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js ***!
  \***********************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-IZC266HS.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-IZC266HS.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));


var _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js");

// src/errors.ts
var _ponycause = __webpack_require__(/*! pony-cause */ "./node_modules/pony-cause/index.js");
function isError(error) {
  return error instanceof Error || _chunkQVEKZRZ2js.isObject.call(void 0, error) && error.constructor.name === "Error";
}
function isErrorWithCode(error) {
  return typeof error === "object" && error !== null && "code" in error;
}
function isErrorWithMessage(error) {
  return typeof error === "object" && error !== null && "message" in error;
}
function isErrorWithStack(error) {
  return typeof error === "object" && error !== null && "stack" in error;
}
function getErrorMessage(error) {
  if (isErrorWithMessage(error) && typeof error.message === "string") {
    return error.message;
  }
  if (_chunkQVEKZRZ2js.isNullOrUndefined.call(void 0, error)) {
    return "";
  }
  return String(error);
}
function wrapError(originalError, message) {
  if (isError(originalError)) {
    let error;
    if (Error.length === 2) {
      error = new Error(message, { cause: originalError });
    } else {
      error = new (0, _ponycause.ErrorWithCause)(message, { cause: originalError });
    }
    if (isErrorWithCode(originalError)) {
      error.code = originalError.code;
    }
    return error;
  }
  if (message.length > 0) {
    return new Error(`${String(originalError)}: ${message}`);
  }
  return new Error(String(originalError));
}







exports.isErrorWithCode = isErrorWithCode; exports.isErrorWithMessage = isErrorWithMessage; exports.isErrorWithStack = isErrorWithStack; exports.getErrorMessage = getErrorMessage; exports.wrapError = wrapError;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js ***!
  \***********************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-OLLG4H35.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-OLLG4H35.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");


var _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js");

// src/json.ts




















var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var object = (schema) => (
  // The type is slightly different from a regular object struct, because we
  // want to make properties with `undefined` in their type optional, but not
  // `undefined` itself. This means that we need a type cast.
  _superstruct.object.call(void 0, schema)
);
function hasOptional({ path, branch }) {
  const field = path[path.length - 1];
  return _chunkQVEKZRZ2js.hasProperty.call(void 0, branch[branch.length - 2], field);
}
function exactOptional(struct) {
  return new (0, _superstruct.Struct)({
    ...struct,
    type: `optional ${struct.type}`,
    validator: (value, context) => !hasOptional(context) || struct.validator(value, context),
    refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context)
  });
}
var finiteNumber = () => _superstruct.define.call(void 0, "finite number", (value) => {
  return _superstruct.is.call(void 0, value, _superstruct.number.call(void 0, )) && Number.isFinite(value);
});
var UnsafeJsonStruct = _superstruct.union.call(void 0, [
  _superstruct.literal.call(void 0, null),
  _superstruct.boolean.call(void 0, ),
  finiteNumber(),
  _superstruct.string.call(void 0, ),
  _superstruct.array.call(void 0, _superstruct.lazy.call(void 0, () => UnsafeJsonStruct)),
  _superstruct.record.call(void 0, 
    _superstruct.string.call(void 0, ),
    _superstruct.lazy.call(void 0, () => UnsafeJsonStruct)
  )
]);
var JsonStruct = _superstruct.coerce.call(void 0, UnsafeJsonStruct, _superstruct.any.call(void 0, ), (value) => {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, UnsafeJsonStruct);
  return JSON.parse(
    JSON.stringify(value, (propKey, propValue) => {
      if (propKey === "__proto__" || propKey === "constructor") {
        return void 0;
      }
      return propValue;
    })
  );
});
function isValidJson(value) {
  try {
    getSafeJson(value);
    return true;
  } catch (e) {
    return false;
  }
}
function getSafeJson(value) {
  return _superstruct.create.call(void 0, value, JsonStruct);
}
function getJsonSize(value) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, JsonStruct, "Invalid JSON value");
  const json = JSON.stringify(value);
  return new TextEncoder().encode(json).byteLength;
}
var jsonrpc2 = "2.0";
var JsonRpcVersionStruct = _superstruct.literal.call(void 0, jsonrpc2);
var JsonRpcIdStruct = _superstruct.nullable.call(void 0, _superstruct.union.call(void 0, [_superstruct.number.call(void 0, ), _superstruct.string.call(void 0, )]));
var JsonRpcErrorStruct = object({
  code: _superstruct.integer.call(void 0, ),
  message: _superstruct.string.call(void 0, ),
  data: exactOptional(JsonStruct),
  stack: exactOptional(_superstruct.string.call(void 0, ))
});
var JsonRpcParamsStruct = _superstruct.union.call(void 0, [_superstruct.record.call(void 0, _superstruct.string.call(void 0, ), JsonStruct), _superstruct.array.call(void 0, JsonStruct)]);
var JsonRpcRequestStruct = object({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  method: _superstruct.string.call(void 0, ),
  params: exactOptional(JsonRpcParamsStruct)
});
var JsonRpcNotificationStruct = object({
  jsonrpc: JsonRpcVersionStruct,
  method: _superstruct.string.call(void 0, ),
  params: exactOptional(JsonRpcParamsStruct)
});
function isJsonRpcNotification(value) {
  return _superstruct.is.call(void 0, value, JsonRpcNotificationStruct);
}
function assertIsJsonRpcNotification(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcNotificationStruct,
    "Invalid JSON-RPC notification",
    ErrorWrapper
  );
}
function isJsonRpcRequest(value) {
  return _superstruct.is.call(void 0, value, JsonRpcRequestStruct);
}
function assertIsJsonRpcRequest(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcRequestStruct,
    "Invalid JSON-RPC request",
    ErrorWrapper
  );
}
var PendingJsonRpcResponseStruct = _superstruct.object.call(void 0, {
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  result: _superstruct.optional.call(void 0, _superstruct.unknown.call(void 0, )),
  error: _superstruct.optional.call(void 0, JsonRpcErrorStruct)
});
var JsonRpcSuccessStruct = object({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  result: JsonStruct
});
var JsonRpcFailureStruct = object({
  id: JsonRpcIdStruct,
  jsonrpc: JsonRpcVersionStruct,
  error: JsonRpcErrorStruct
});
var JsonRpcResponseStruct = _superstruct.union.call(void 0, [
  JsonRpcSuccessStruct,
  JsonRpcFailureStruct
]);
function isPendingJsonRpcResponse(response) {
  return _superstruct.is.call(void 0, response, PendingJsonRpcResponseStruct);
}
function assertIsPendingJsonRpcResponse(response, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    response,
    PendingJsonRpcResponseStruct,
    "Invalid pending JSON-RPC response",
    ErrorWrapper
  );
}
function isJsonRpcResponse(response) {
  return _superstruct.is.call(void 0, response, JsonRpcResponseStruct);
}
function assertIsJsonRpcResponse(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcResponseStruct,
    "Invalid JSON-RPC response",
    ErrorWrapper
  );
}
function isJsonRpcSuccess(value) {
  return _superstruct.is.call(void 0, value, JsonRpcSuccessStruct);
}
function assertIsJsonRpcSuccess(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcSuccessStruct,
    "Invalid JSON-RPC success response",
    ErrorWrapper
  );
}
function isJsonRpcFailure(value) {
  return _superstruct.is.call(void 0, value, JsonRpcFailureStruct);
}
function assertIsJsonRpcFailure(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcFailureStruct,
    "Invalid JSON-RPC failure response",
    ErrorWrapper
  );
}
function isJsonRpcError(value) {
  return _superstruct.is.call(void 0, value, JsonRpcErrorStruct);
}
function assertIsJsonRpcError(value, ErrorWrapper) {
  _chunk6ZDHSOUVjs.assertStruct.call(void 0, 
    value,
    JsonRpcErrorStruct,
    "Invalid JSON-RPC error",
    ErrorWrapper
  );
}
function getJsonRpcIdValidator(options) {
  const { permitEmptyString, permitFractions, permitNull } = {
    permitEmptyString: true,
    permitFractions: false,
    permitNull: true,
    ...options
  };
  const isValidJsonRpcId = (id) => {
    return Boolean(
      typeof id === "number" && (permitFractions || Number.isInteger(id)) || typeof id === "string" && (permitEmptyString || id.length > 0) || permitNull && id === null
    );
  };
  return isValidJsonRpcId;
}



































exports.object = object; exports.exactOptional = exactOptional; exports.UnsafeJsonStruct = UnsafeJsonStruct; exports.JsonStruct = JsonStruct; exports.isValidJson = isValidJson; exports.getSafeJson = getSafeJson; exports.getJsonSize = getJsonSize; exports.jsonrpc2 = jsonrpc2; exports.JsonRpcVersionStruct = JsonRpcVersionStruct; exports.JsonRpcIdStruct = JsonRpcIdStruct; exports.JsonRpcErrorStruct = JsonRpcErrorStruct; exports.JsonRpcParamsStruct = JsonRpcParamsStruct; exports.JsonRpcRequestStruct = JsonRpcRequestStruct; exports.JsonRpcNotificationStruct = JsonRpcNotificationStruct; exports.isJsonRpcNotification = isJsonRpcNotification; exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification; exports.isJsonRpcRequest = isJsonRpcRequest; exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest; exports.PendingJsonRpcResponseStruct = PendingJsonRpcResponseStruct; exports.JsonRpcSuccessStruct = JsonRpcSuccessStruct; exports.JsonRpcFailureStruct = JsonRpcFailureStruct; exports.JsonRpcResponseStruct = JsonRpcResponseStruct; exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse; exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse; exports.isJsonRpcResponse = isJsonRpcResponse; exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse; exports.isJsonRpcSuccess = isJsonRpcSuccess; exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess; exports.isJsonRpcFailure = isJsonRpcFailure; exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure; exports.isJsonRpcError = isJsonRpcError; exports.assertIsJsonRpcError = assertIsJsonRpcError; exports.getJsonRpcIdValidator = getJsonRpcIdValidator;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/hex.ts
var _sha3 = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/@noble/hashes/sha3.js");
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");

// src/bytes.ts
var _base = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");
var HEX_MINIMUM_NUMBER_CHARACTER = 48;
var HEX_MAXIMUM_NUMBER_CHARACTER = 58;
var HEX_CHARACTER_OFFSET = 87;
function getPrecomputedHexValuesBuilder() {
  const lookupTable = [];
  return () => {
    if (lookupTable.length === 0) {
      for (let i = 0; i < 256; i++) {
        lookupTable.push(i.toString(16).padStart(2, "0"));
      }
    }
    return lookupTable;
  };
}
var getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
function isBytes(value) {
  return value instanceof Uint8Array;
}
function assertIsBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, isBytes(value), "Value must be a Uint8Array.");
}
function bytesToHex(bytes) {
  assertIsBytes(bytes);
  if (bytes.length === 0) {
    return "0x";
  }
  const lookupTable = getPrecomputedHexValues();
  const hexadecimal = new Array(bytes.length);
  for (let i = 0; i < bytes.length; i++) {
    hexadecimal[i] = lookupTable[bytes[i]];
  }
  return add0x(hexadecimal.join(""));
}
function bytesToBigInt(bytes) {
  assertIsBytes(bytes);
  const hexadecimal = bytesToHex(bytes);
  return BigInt(hexadecimal);
}
function bytesToSignedBigInt(bytes) {
  assertIsBytes(bytes);
  let value = BigInt(0);
  for (const byte of bytes) {
    value = (value << BigInt(8)) + BigInt(byte);
  }
  return BigInt.asIntN(bytes.length * 8, value);
}
function bytesToNumber(bytes) {
  assertIsBytes(bytes);
  const bigint = bytesToBigInt(bytes);
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    bigint <= BigInt(Number.MAX_SAFE_INTEGER),
    "Number is not a safe integer. Use `bytesToBigInt` instead."
  );
  return Number(bigint);
}
function bytesToString(bytes) {
  assertIsBytes(bytes);
  return new TextDecoder().decode(bytes);
}
function bytesToBase64(bytes) {
  assertIsBytes(bytes);
  return _base.base64.encode(bytes);
}
function hexToBytes(value) {
  if (_optionalChain([value, 'optionalAccess', _ => _.toLowerCase, 'optionalCall', _2 => _2()]) === "0x") {
    return new Uint8Array();
  }
  assertIsHexString(value);
  const strippedValue = remove0x(value).toLowerCase();
  const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
  const bytes = new Uint8Array(normalizedValue.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    const c1 = normalizedValue.charCodeAt(i * 2);
    const c2 = normalizedValue.charCodeAt(i * 2 + 1);
    const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
    const n2 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
    bytes[i] = n1 * 16 + n2;
  }
  return bytes;
}
function bigIntToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "bigint", "Value must be a bigint.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= BigInt(0), "Value must be a non-negative bigint.");
  const hexadecimal = value.toString(16);
  return hexToBytes(hexadecimal);
}
function bigIntFits(value, bytes) {
  _chunk6ZDHSOUVjs.assert.call(void 0, bytes > 0);
  const mask = value >> BigInt(31);
  return !((~value & mask) + (value & ~mask) >> BigInt(bytes * 8 + ~0));
}
function signedBigIntToBytes(value, byteLength) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "bigint", "Value must be a bigint.");
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof byteLength === "number", "Byte length must be a number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, byteLength > 0, "Byte length must be greater than 0.");
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    bigIntFits(value, byteLength),
    "Byte length is too small to represent the given value."
  );
  let numberValue = value;
  const bytes = new Uint8Array(byteLength);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = Number(BigInt.asUintN(8, numberValue));
    numberValue >>= BigInt(8);
  }
  return bytes.reverse();
}
function numberToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "number", "Value must be a number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, "Value must be a non-negative number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    Number.isSafeInteger(value),
    "Value is not a safe integer. Use `bigIntToBytes` instead."
  );
  const hexadecimal = value.toString(16);
  return hexToBytes(hexadecimal);
}
function stringToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "string", "Value must be a string.");
  return new TextEncoder().encode(value);
}
function base64ToBytes(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "string", "Value must be a string.");
  return _base.base64.decode(value);
}
function valueToBytes(value) {
  if (typeof value === "bigint") {
    return bigIntToBytes(value);
  }
  if (typeof value === "number") {
    return numberToBytes(value);
  }
  if (typeof value === "string") {
    if (value.startsWith("0x")) {
      return hexToBytes(value);
    }
    return stringToBytes(value);
  }
  if (isBytes(value)) {
    return value;
  }
  throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
function concatBytes(values) {
  const normalizedValues = new Array(values.length);
  let byteLength = 0;
  for (let i = 0; i < values.length; i++) {
    const value = valueToBytes(values[i]);
    normalizedValues[i] = value;
    byteLength += value.length;
  }
  const bytes = new Uint8Array(byteLength);
  for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
    bytes.set(normalizedValues[i], offset);
    offset += normalizedValues[i].length;
  }
  return bytes;
}
function createDataView(bytes) {
  if (typeof Buffer !== "undefined" && bytes instanceof Buffer) {
    const buffer = bytes.buffer.slice(
      bytes.byteOffset,
      bytes.byteOffset + bytes.byteLength
    );
    return new DataView(buffer);
  }
  return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}

// src/hex.ts
var HexStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), /^(?:0x)?[0-9a-f]+$/iu);
var StrictHexStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), /^0x[0-9a-f]+$/iu);
var HexAddressStruct = _superstruct.pattern.call(void 0, 
  _superstruct.string.call(void 0, ),
  /^0x[0-9a-f]{40}$/u
);
var HexChecksumAddressStruct = _superstruct.pattern.call(void 0, 
  _superstruct.string.call(void 0, ),
  /^0x[0-9a-fA-F]{40}$/u
);
function isHexString(value) {
  return _superstruct.is.call(void 0, value, HexStruct);
}
function isStrictHexString(value) {
  return _superstruct.is.call(void 0, value, StrictHexStruct);
}
function assertIsHexString(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, isHexString(value), "Value must be a hexadecimal string.");
}
function assertIsStrictHexString(value) {
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    isStrictHexString(value),
    'Value must be a hexadecimal string, starting with "0x".'
  );
}
function isValidHexAddress(possibleAddress) {
  return _superstruct.is.call(void 0, possibleAddress, HexAddressStruct) || isValidChecksumAddress(possibleAddress);
}
function getChecksumAddress(address) {
  _chunk6ZDHSOUVjs.assert.call(void 0, _superstruct.is.call(void 0, address, HexChecksumAddressStruct), "Invalid hex address.");
  const unPrefixed = remove0x(address.toLowerCase());
  const unPrefixedHash = remove0x(bytesToHex(_sha3.keccak_256.call(void 0, unPrefixed)));
  return `0x${unPrefixed.split("").map((character, nibbleIndex) => {
    const hashCharacter = unPrefixedHash[nibbleIndex];
    _chunk6ZDHSOUVjs.assert.call(void 0, _superstruct.is.call(void 0, hashCharacter, _superstruct.string.call(void 0, )), "Hash shorter than address.");
    return parseInt(hashCharacter, 16) > 7 ? character.toUpperCase() : character;
  }).join("")}`;
}
function isValidChecksumAddress(possibleChecksum) {
  if (!_superstruct.is.call(void 0, possibleChecksum, HexChecksumAddressStruct)) {
    return false;
  }
  return getChecksumAddress(possibleChecksum) === possibleChecksum;
}
function add0x(hexadecimal) {
  if (hexadecimal.startsWith("0x")) {
    return hexadecimal;
  }
  if (hexadecimal.startsWith("0X")) {
    return `0x${hexadecimal.substring(2)}`;
  }
  return `0x${hexadecimal}`;
}
function remove0x(hexadecimal) {
  if (hexadecimal.startsWith("0x") || hexadecimal.startsWith("0X")) {
    return hexadecimal.substring(2);
  }
  return hexadecimal;
}
































exports.HexStruct = HexStruct; exports.StrictHexStruct = StrictHexStruct; exports.HexAddressStruct = HexAddressStruct; exports.HexChecksumAddressStruct = HexChecksumAddressStruct; exports.isHexString = isHexString; exports.isStrictHexString = isStrictHexString; exports.assertIsHexString = assertIsHexString; exports.assertIsStrictHexString = assertIsStrictHexString; exports.isValidHexAddress = isValidHexAddress; exports.getChecksumAddress = getChecksumAddress; exports.isValidChecksumAddress = isValidChecksumAddress; exports.add0x = add0x; exports.remove0x = remove0x; exports.isBytes = isBytes; exports.assertIsBytes = assertIsBytes; exports.bytesToHex = bytesToHex; exports.bytesToBigInt = bytesToBigInt; exports.bytesToSignedBigInt = bytesToSignedBigInt; exports.bytesToNumber = bytesToNumber; exports.bytesToString = bytesToString; exports.bytesToBase64 = bytesToBase64; exports.hexToBytes = hexToBytes; exports.bigIntToBytes = bigIntToBytes; exports.signedBigIntToBytes = signedBigIntToBytes; exports.numberToBytes = numberToBytes; exports.stringToBytes = stringToBytes; exports.base64ToBytes = base64ToBytes; exports.valueToBytes = valueToBytes; exports.concatBytes = concatBytes; exports.createDataView = createDataView;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }// src/misc.ts
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
function isObject(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
var hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
function getKnownPropertyNames(object) {
  return Object.getOwnPropertyNames(object);
}
var JsonSize = /* @__PURE__ */ ((JsonSize2) => {
  JsonSize2[JsonSize2["Null"] = 4] = "Null";
  JsonSize2[JsonSize2["Comma"] = 1] = "Comma";
  JsonSize2[JsonSize2["Wrapper"] = 1] = "Wrapper";
  JsonSize2[JsonSize2["True"] = 4] = "True";
  JsonSize2[JsonSize2["False"] = 5] = "False";
  JsonSize2[JsonSize2["Quote"] = 1] = "Quote";
  JsonSize2[JsonSize2["Colon"] = 1] = "Colon";
  JsonSize2[JsonSize2["Date"] = 24] = "Date";
  return JsonSize2;
})(JsonSize || {});
var ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  try {
    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
  } catch (_) {
    return false;
  }
}
function isASCII(character) {
  return character.charCodeAt(0) <= 127;
}
function calculateStringSize(value) {
  const size = value.split("").reduce((total, character) => {
    if (isASCII(character)) {
      return total + 1;
    }
    return total + 2;
  }, 0);
  return size + (_nullishCoalesce(value.match(ESCAPE_CHARACTERS_REGEXP), () => ( []))).length;
}
function calculateNumberSize(value) {
  return value.toString().length;
}













exports.isNonEmptyArray = isNonEmptyArray; exports.isNullOrUndefined = isNullOrUndefined; exports.isObject = isObject; exports.hasProperty = hasProperty; exports.getKnownPropertyNames = getKnownPropertyNames; exports.JsonSize = JsonSize; exports.ESCAPE_CHARACTERS_REGEXP = ESCAPE_CHARACTERS_REGEXP; exports.isPlainObject = isPlainObject; exports.isASCII = isASCII; exports.calculateStringSize = calculateStringSize; exports.calculateNumberSize = calculateNumberSize;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js ***!
  \***********************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true})); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/caip-types.ts
var _superstruct = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
var CAIP_CHAIN_ID_REGEX = /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u;
var CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;
var CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u;
var CAIP_ACCOUNT_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u;
var CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;
var CaipChainIdStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_CHAIN_ID_REGEX);
var CaipNamespaceStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_NAMESPACE_REGEX);
var CaipReferenceStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_REFERENCE_REGEX);
var CaipAccountIdStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0, ), CAIP_ACCOUNT_ID_REGEX);
var CaipAccountAddressStruct = _superstruct.pattern.call(void 0, 
  _superstruct.string.call(void 0, ),
  CAIP_ACCOUNT_ADDRESS_REGEX
);
function isCaipChainId(value) {
  return _superstruct.is.call(void 0, value, CaipChainIdStruct);
}
function isCaipNamespace(value) {
  return _superstruct.is.call(void 0, value, CaipNamespaceStruct);
}
function isCaipReference(value) {
  return _superstruct.is.call(void 0, value, CaipReferenceStruct);
}
function isCaipAccountId(value) {
  return _superstruct.is.call(void 0, value, CaipAccountIdStruct);
}
function isCaipAccountAddress(value) {
  return _superstruct.is.call(void 0, value, CaipAccountAddressStruct);
}
function parseCaipChainId(caipChainId) {
  const match = CAIP_CHAIN_ID_REGEX.exec(caipChainId);
  if (!_optionalChain([match, 'optionalAccess', _ => _.groups])) {
    throw new Error("Invalid CAIP chain ID.");
  }
  return {
    namespace: match.groups.namespace,
    reference: match.groups.reference
  };
}
function parseCaipAccountId(caipAccountId) {
  const match = CAIP_ACCOUNT_ID_REGEX.exec(caipAccountId);
  if (!_optionalChain([match, 'optionalAccess', _2 => _2.groups])) {
    throw new Error("Invalid CAIP account ID.");
  }
  return {
    address: match.groups.accountAddress,
    chainId: match.groups.chainId,
    chain: {
      namespace: match.groups.namespace,
      reference: match.groups.reference
    }
  };
}



















exports.CAIP_CHAIN_ID_REGEX = CAIP_CHAIN_ID_REGEX; exports.CAIP_NAMESPACE_REGEX = CAIP_NAMESPACE_REGEX; exports.CAIP_REFERENCE_REGEX = CAIP_REFERENCE_REGEX; exports.CAIP_ACCOUNT_ID_REGEX = CAIP_ACCOUNT_ID_REGEX; exports.CAIP_ACCOUNT_ADDRESS_REGEX = CAIP_ACCOUNT_ADDRESS_REGEX; exports.CaipChainIdStruct = CaipChainIdStruct; exports.CaipNamespaceStruct = CaipNamespaceStruct; exports.CaipReferenceStruct = CaipReferenceStruct; exports.CaipAccountIdStruct = CaipAccountIdStruct; exports.CaipAccountAddressStruct = CaipAccountAddressStruct; exports.isCaipChainId = isCaipChainId; exports.isCaipNamespace = isCaipNamespace; exports.isCaipReference = isCaipReference; exports.isCaipAccountId = isCaipAccountId; exports.isCaipAccountAddress = isCaipAccountAddress; exports.parseCaipChainId = parseCaipChainId; exports.parseCaipAccountId = parseCaipAccountId;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js ***!
  \***********************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));


var _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js");


var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");

// src/number.ts
var numberToHex = (value) => {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "number", "Value must be a number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, "Value must be a non-negative number.");
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    Number.isSafeInteger(value),
    "Value is not a safe integer. Use `bigIntToHex` instead."
  );
  return _chunkQEPVHEP7js.add0x.call(void 0, value.toString(16));
};
var bigIntToHex = (value) => {
  _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === "bigint", "Value must be a bigint.");
  _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, "Value must be a non-negative bigint.");
  return _chunkQEPVHEP7js.add0x.call(void 0, value.toString(16));
};
var hexToNumber = (value) => {
  _chunkQEPVHEP7js.assertIsHexString.call(void 0, value);
  const numberValue = parseInt(value, 16);
  _chunk6ZDHSOUVjs.assert.call(void 0, 
    Number.isSafeInteger(numberValue),
    "Value is not a safe integer. Use `hexToBigInt` instead."
  );
  return numberValue;
};
var hexToBigInt = (value) => {
  _chunkQEPVHEP7js.assertIsHexString.call(void 0, value);
  return BigInt(_chunkQEPVHEP7js.add0x.call(void 0, value));
};






exports.numberToHex = numberToHex; exports.bigIntToHex = bigIntToHex; exports.hexToNumber = hexToNumber; exports.hexToBigInt = hexToBigInt;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));



var _chunk3W5G4CYIjs = __webpack_require__(/*! ./chunk-3W5G4CYI.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js");

// src/collections.ts
var _map;
var FrozenMap = class {
  constructor(entries) {
    _chunk3W5G4CYIjs.__privateAdd.call(void 0, this, _map, void 0);
    _chunk3W5G4CYIjs.__privateSet.call(void 0, this, _map, new Map(entries));
    Object.freeze(this);
  }
  get size() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).size;
  }
  [Symbol.iterator]() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map)[Symbol.iterator]();
  }
  entries() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).entries();
  }
  forEach(callbackfn, thisArg) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).forEach(
      (value, key, _map2) => callbackfn.call(thisArg, value, key, this)
    );
  }
  get(key) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).get(key);
  }
  has(key) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).has(key);
  }
  keys() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).keys();
  }
  values() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([key, value]) => `${String(key)} => ${String(value)}`).join(", ")} ` : ""}}`;
  }
};
_map = new WeakMap();
var _set;
var FrozenSet = class {
  constructor(values) {
    _chunk3W5G4CYIjs.__privateAdd.call(void 0, this, _set, void 0);
    _chunk3W5G4CYIjs.__privateSet.call(void 0, this, _set, new Set(values));
    Object.freeze(this);
  }
  get size() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).size;
  }
  [Symbol.iterator]() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set)[Symbol.iterator]();
  }
  entries() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).entries();
  }
  forEach(callbackfn, thisArg) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).forEach(
      (value, value2, _set2) => callbackfn.call(thisArg, value, value2, this)
    );
  }
  has(value) {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).has(value);
  }
  keys() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).keys();
  }
  values() {
    return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((member) => String(member)).join(", ")} ` : ""}}`;
  }
};
_set = new WeakMap();
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);




exports.FrozenMap = FrozenMap; exports.FrozenSet = FrozenSet;


/***/ }),

/***/ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value: true}));__webpack_require__(/*! ./chunk-5AVWINSB.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-5AVWINSB.js");





var _chunkVFXTVNXNjs = __webpack_require__(/*! ./chunk-VFXTVNXN.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js");
__webpack_require__(/*! ./chunk-LC2CRSWD.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js");


var _chunk4NIRTM4Mjs = __webpack_require__(/*! ./chunk-4NIRTM4M.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-4NIRTM4M.js");




var _chunk4RMX5YWEjs = __webpack_require__(/*! ./chunk-4RMX5YWE.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js");
__webpack_require__(/*! ./chunk-UOTVU7OQ.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js");










var _chunk4D6XQBHAjs = __webpack_require__(/*! ./chunk-4D6XQBHA.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js");


































var _chunkOLLG4H35js = __webpack_require__(/*! ./chunk-OLLG4H35.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-OLLG4H35.js");
__webpack_require__(/*! ./chunk-RKRGAFXY.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js");



var _chunk2LBGT4GHjs = __webpack_require__(/*! ./chunk-2LBGT4GH.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js");


















var _chunkU7ZUGCE7js = __webpack_require__(/*! ./chunk-U7ZUGCE7.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js");


var _chunkE4C7EW4Rjs = __webpack_require__(/*! ./chunk-E4C7EW4R.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js");


var _chunk6NZW4WK4js = __webpack_require__(/*! ./chunk-6NZW4WK4.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js");





var _chunkDHVKFDHQjs = __webpack_require__(/*! ./chunk-DHVKFDHQ.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js");































var _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js");





var _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js");






var _chunkIZC266HSjs = __webpack_require__(/*! ./chunk-IZC266HS.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-IZC266HS.js");












var _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js");



var _chunkZ2RGWDD7js = __webpack_require__(/*! ./chunk-Z2RGWDD7.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js");
__webpack_require__(/*! ./chunk-3W5G4CYI.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js");
__webpack_require__(/*! ./chunk-EQMZL4XU.js */ "./node_modules/@metamask/rpc-errors/node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js");
































































































































exports.AssertionError = _chunk6ZDHSOUVjs.AssertionError; exports.CAIP_ACCOUNT_ADDRESS_REGEX = _chunkU7ZUGCE7js.CAIP_ACCOUNT_ADDRESS_REGEX; exports.CAIP_ACCOUNT_ID_REGEX = _chunkU7ZUGCE7js.CAIP_ACCOUNT_ID_REGEX; exports.CAIP_CHAIN_ID_REGEX = _chunkU7ZUGCE7js.CAIP_CHAIN_ID_REGEX; exports.CAIP_NAMESPACE_REGEX = _chunkU7ZUGCE7js.CAIP_NAMESPACE_REGEX; exports.CAIP_REFERENCE_REGEX = _chunkU7ZUGCE7js.CAIP_REFERENCE_REGEX; exports.CaipAccountAddressStruct = _chunkU7ZUGCE7js.CaipAccountAddressStruct; exports.CaipAccountIdStruct = _chunkU7ZUGCE7js.CaipAccountIdStruct; exports.CaipChainIdStruct = _chunkU7ZUGCE7js.CaipChainIdStruct; exports.CaipNamespaceStruct = _chunkU7ZUGCE7js.CaipNamespaceStruct; exports.CaipReferenceStruct = _chunkU7ZUGCE7js.CaipReferenceStruct; exports.ChecksumStruct = _chunkE4C7EW4Rjs.ChecksumStruct; exports.Duration = _chunk4RMX5YWEjs.Duration; exports.ESCAPE_CHARACTERS_REGEXP = _chunkQVEKZRZ2js.ESCAPE_CHARACTERS_REGEXP; exports.FrozenMap = _chunkZ2RGWDD7js.FrozenMap; exports.FrozenSet = _chunkZ2RGWDD7js.FrozenSet; exports.HexAddressStruct = _chunkQEPVHEP7js.HexAddressStruct; exports.HexChecksumAddressStruct = _chunkQEPVHEP7js.HexChecksumAddressStruct; exports.HexStruct = _chunkQEPVHEP7js.HexStruct; exports.JsonRpcErrorStruct = _chunkOLLG4H35js.JsonRpcErrorStruct; exports.JsonRpcFailureStruct = _chunkOLLG4H35js.JsonRpcFailureStruct; exports.JsonRpcIdStruct = _chunkOLLG4H35js.JsonRpcIdStruct; exports.JsonRpcNotificationStruct = _chunkOLLG4H35js.JsonRpcNotificationStruct; exports.JsonRpcParamsStruct = _chunkOLLG4H35js.JsonRpcParamsStruct; exports.JsonRpcRequestStruct = _chunkOLLG4H35js.JsonRpcRequestStruct; exports.JsonRpcResponseStruct = _chunkOLLG4H35js.JsonRpcResponseStruct; exports.JsonRpcSuccessStruct = _chunkOLLG4H35js.JsonRpcSuccessStruct; exports.JsonRpcVersionStruct = _chunkOLLG4H35js.JsonRpcVersionStruct; exports.JsonSize = _chunkQVEKZRZ2js.JsonSize; exports.JsonStruct = _chunkOLLG4H35js.JsonStruct; exports.PendingJsonRpcResponseStruct = _chunkOLLG4H35js.PendingJsonRpcResponseStruct; exports.StrictHexStruct = _chunkQEPVHEP7js.StrictHexStruct; exports.UnsafeJsonStruct = _chunkOLLG4H35js.UnsafeJsonStruct; exports.VersionRangeStruct = _chunk4D6XQBHAjs.VersionRangeStruct; exports.VersionStruct = _chunk4D6XQBHAjs.VersionStruct; exports.add0x = _chunkQEPVHEP7js.add0x; exports.assert = _chunk6ZDHSOUVjs.assert; exports.assertExhaustive = _chunk6ZDHSOUVjs.assertExhaustive; exports.assertIsBytes = _chunkQEPVHEP7js.assertIsBytes; exports.assertIsHexString = _chunkQEPVHEP7js.assertIsHexString; exports.assertIsJsonRpcError = _chunkOLLG4H35js.assertIsJsonRpcError; exports.assertIsJsonRpcFailure = _chunkOLLG4H35js.assertIsJsonRpcFailure; exports.assertIsJsonRpcNotification = _chunkOLLG4H35js.assertIsJsonRpcNotification; exports.assertIsJsonRpcRequest = _chunkOLLG4H35js.assertIsJsonRpcRequest; exports.assertIsJsonRpcResponse = _chunkOLLG4H35js.assertIsJsonRpcResponse; exports.assertIsJsonRpcSuccess = _chunkOLLG4H35js.assertIsJsonRpcSuccess; exports.assertIsPendingJsonRpcResponse = _chunkOLLG4H35js.assertIsPendingJsonRpcResponse; exports.assertIsSemVerRange = _chunk4D6XQBHAjs.assertIsSemVerRange; exports.assertIsSemVerVersion = _chunk4D6XQBHAjs.assertIsSemVerVersion; exports.assertIsStrictHexString = _chunkQEPVHEP7js.assertIsStrictHexString; exports.assertStruct = _chunk6ZDHSOUVjs.assertStruct; exports.base64 = _chunk6NZW4WK4js.base64; exports.base64ToBytes = _chunkQEPVHEP7js.base64ToBytes; exports.bigIntToBytes = _chunkQEPVHEP7js.bigIntToBytes; exports.bigIntToHex = _chunkVFXTVNXNjs.bigIntToHex; exports.bytesToBase64 = _chunkQEPVHEP7js.bytesToBase64; exports.bytesToBigInt = _chunkQEPVHEP7js.bytesToBigInt; exports.bytesToHex = _chunkQEPVHEP7js.bytesToHex; exports.bytesToNumber = _chunkQEPVHEP7js.bytesToNumber; exports.bytesToSignedBigInt = _chunkQEPVHEP7js.bytesToSignedBigInt; exports.bytesToString = _chunkQEPVHEP7js.bytesToString; exports.calculateNumberSize = _chunkQVEKZRZ2js.calculateNumberSize; exports.calculateStringSize = _chunkQVEKZRZ2js.calculateStringSize; exports.concatBytes = _chunkQEPVHEP7js.concatBytes; exports.createBigInt = _chunkDHVKFDHQjs.createBigInt; exports.createBytes = _chunkDHVKFDHQjs.createBytes; exports.createDataView = _chunkQEPVHEP7js.createDataView; exports.createDeferredPromise = _chunk4NIRTM4Mjs.createDeferredPromise; exports.createHex = _chunkDHVKFDHQjs.createHex; exports.createModuleLogger = _chunk2LBGT4GHjs.createModuleLogger; exports.createNumber = _chunkDHVKFDHQjs.createNumber; exports.createProjectLogger = _chunk2LBGT4GHjs.createProjectLogger; exports.exactOptional = _chunkOLLG4H35js.exactOptional; exports.getChecksumAddress = _chunkQEPVHEP7js.getChecksumAddress; exports.getErrorMessage = _chunkIZC266HSjs.getErrorMessage; exports.getJsonRpcIdValidator = _chunkOLLG4H35js.getJsonRpcIdValidator; exports.getJsonSize = _chunkOLLG4H35js.getJsonSize; exports.getKnownPropertyNames = _chunkQVEKZRZ2js.getKnownPropertyNames; exports.getSafeJson = _chunkOLLG4H35js.getSafeJson; exports.gtRange = _chunk4D6XQBHAjs.gtRange; exports.gtVersion = _chunk4D6XQBHAjs.gtVersion; exports.hasProperty = _chunkQVEKZRZ2js.hasProperty; exports.hexToBigInt = _chunkVFXTVNXNjs.hexToBigInt; exports.hexToBytes = _chunkQEPVHEP7js.hexToBytes; exports.hexToNumber = _chunkVFXTVNXNjs.hexToNumber; exports.inMilliseconds = _chunk4RMX5YWEjs.inMilliseconds; exports.isASCII = _chunkQVEKZRZ2js.isASCII; exports.isBytes = _chunkQEPVHEP7js.isBytes; exports.isCaipAccountAddress = _chunkU7ZUGCE7js.isCaipAccountAddress; exports.isCaipAccountId = _chunkU7ZUGCE7js.isCaipAccountId; exports.isCaipChainId = _chunkU7ZUGCE7js.isCaipChainId; exports.isCaipNamespace = _chunkU7ZUGCE7js.isCaipNamespace; exports.isCaipReference = _chunkU7ZUGCE7js.isCaipReference; exports.isErrorWithCode = _chunkIZC266HSjs.isErrorWithCode; exports.isErrorWithMessage = _chunkIZC266HSjs.isErrorWithMessage; exports.isErrorWithStack = _chunkIZC266HSjs.isErrorWithStack; exports.isHexString = _chunkQEPVHEP7js.isHexString; exports.isJsonRpcError = _chunkOLLG4H35js.isJsonRpcError; exports.isJsonRpcFailure = _chunkOLLG4H35js.isJsonRpcFailure; exports.isJsonRpcNotification = _chunkOLLG4H35js.isJsonRpcNotification; exports.isJsonRpcRequest = _chunkOLLG4H35js.isJsonRpcRequest; exports.isJsonRpcResponse = _chunkOLLG4H35js.isJsonRpcResponse; exports.isJsonRpcSuccess = _chunkOLLG4H35js.isJsonRpcSuccess; exports.isNonEmptyArray = _chunkQVEKZRZ2js.isNonEmptyArray; exports.isNullOrUndefined = _chunkQVEKZRZ2js.isNullOrUndefined; exports.isObject = _chunkQVEKZRZ2js.isObject; exports.isPendingJsonRpcResponse = _chunkOLLG4H35js.isPendingJsonRpcResponse; exports.isPlainObject = _chunkQVEKZRZ2js.isPlainObject; exports.isStrictHexString = _chunkQEPVHEP7js.isStrictHexString; exports.isValidChecksumAddress = _chunkQEPVHEP7js.isValidChecksumAddress; exports.isValidHexAddress = _chunkQEPVHEP7js.isValidHexAddress; exports.isValidJson = _chunkOLLG4H35js.isValidJson; exports.isValidSemVerRange = _chunk4D6XQBHAjs.isValidSemVerRange; exports.isValidSemVerVersion = _chunk4D6XQBHAjs.isValidSemVerVersion; exports.jsonrpc2 = _chunkOLLG4H35js.jsonrpc2; exports.numberToBytes = _chunkQEPVHEP7js.numberToBytes; exports.numberToHex = _chunkVFXTVNXNjs.numberToHex; exports.object = _chunkOLLG4H35js.object; exports.parseCaipAccountId = _chunkU7ZUGCE7js.parseCaipAccountId; exports.parseCaipChainId = _chunkU7ZUGCE7js.parseCaipChainId; exports.remove0x = _chunkQEPVHEP7js.remove0x; exports.satisfiesVersionRange = _chunk4D6XQBHAjs.satisfiesVersionRange; exports.signedBigIntToBytes = _chunkQEPVHEP7js.signedBigIntToBytes; exports.stringToBytes = _chunkQEPVHEP7js.stringToBytes; exports.timeSince = _chunk4RMX5YWEjs.timeSince; exports.valueToBytes = _chunkQEPVHEP7js.valueToBytes; exports.wrapError = _chunkIZC266HSjs.wrapError;


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/assert.js":
/*!*****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/assert.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;
const superstruct_1 = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
/**
 * Type guard for determining whether the given value is an error object with a
 * `message` property, such as an instance of Error.
 *
 * @param error - The object to check.
 * @returns True or false, depending on the result.
 */
function isErrorWithMessage(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
/**
 * Check if a value is a constructor, i.e., a function that can be called with
 * the `new` keyword.
 *
 * @param fn - The value to check.
 * @returns `true` if the value is a constructor, or `false` otherwise.
 */
function isConstructable(fn) {
    var _a, _b;
    /* istanbul ignore next */
    return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');
}
/**
 * Get the error message from an unknown error object. If the error object has
 * a `message` property, that property is returned. Otherwise, the stringified
 * error object is returned.
 *
 * @param error - The error object to get the message from.
 * @returns The error message.
 */
function getErrorMessage(error) {
    const message = isErrorWithMessage(error) ? error.message : String(error);
    // If the error ends with a period, remove it, as we'll add our own period.
    if (message.endsWith('.')) {
        return message.slice(0, -1);
    }
    return message;
}
/**
 * Initialise an {@link AssertionErrorConstructor} error.
 *
 * @param ErrorWrapper - The error class to use.
 * @param message - The error message.
 * @returns The error object.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getError(ErrorWrapper, message) {
    if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
            message,
        });
    }
    return ErrorWrapper({
        message,
    });
}
/**
 * The default error class that is thrown if an assertion fails.
 */
class AssertionError extends Error {
    constructor(options) {
        super(options.message);
        this.code = 'ERR_ASSERTION';
    }
}
exports.AssertionError = AssertionError;
/**
 * Same as Node.js assert.
 * If the value is falsy, throws an error, does nothing otherwise.
 *
 * @throws {@link AssertionError} If value is falsy.
 * @param value - The test that should be truthy to pass.
 * @param message - Message to be passed to {@link AssertionError} or an
 * {@link Error} instance to throw.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}. If a custom error class is provided for
 * the `message` argument, this argument is ignored.
 */
function assert(value, message = 'Assertion failed.', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    if (!value) {
        if (message instanceof Error) {
            throw message;
        }
        throw getError(ErrorWrapper, message);
    }
}
exports.assert = assert;
/**
 * Assert a value against a Superstruct struct.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @param errorPrefix - A prefix to add to the error message. Defaults to
 * "Assertion failed".
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the value is not valid.
 */
function assertStruct(value, struct, errorPrefix = 'Assertion failed', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    try {
        (0, superstruct_1.assert)(value, struct);
    }
    catch (error) {
        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
    }
}
exports.assertStruct = assertStruct;
/**
 * Use in the default case of a switch that you want to be fully exhaustive.
 * Using this function forces the compiler to enforce exhaustivity during
 * compile-time.
 *
 * @example
 * ```
 * const number = 1;
 * switch (number) {
 *   case 0:
 *     ...
 *   case 1:
 *     ...
 *   default:
 *     assertExhaustive(snapPrefix);
 * }
 * ```
 * @param _object - The object on which the switch is being operated.
 */
function assertExhaustive(_object) {
    throw new Error('Invalid branch reached. Should be detected during compilation.');
}
exports.assertExhaustive = assertExhaustive;


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/base64.js":
/*!*****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/base64.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.base64 = void 0;
const superstruct_1 = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
const assert_1 = __webpack_require__(/*! ./assert */ "./node_modules/@metamask/utils/dist/assert.js");
/**
 * Ensure that a provided string-based struct is valid base64.
 *
 * @param struct - The string based struct.
 * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.
 * @returns A superstruct validating base64.
 */
const base64 = (struct, options = {}) => {
    var _a, _b;
    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;
    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : 'base64';
    let letters;
    if (characterSet === 'base64') {
        letters = String.raw `[A-Za-z0-9+\/]`;
    }
    else {
        (0, assert_1.assert)(characterSet === 'base64url');
        letters = String.raw `[-_A-Za-z0-9]`;
    }
    let re;
    if (paddingRequired) {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    else {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    return (0, superstruct_1.pattern)(struct, re);
};
exports.base64 = base64;


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/bytes.js":
/*!****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/bytes.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;
const assert_1 = __webpack_require__(/*! ./assert */ "./node_modules/@metamask/utils/dist/assert.js");
const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@metamask/utils/dist/hex.js");
// '0'.charCodeAt(0) === 48
const HEX_MINIMUM_NUMBER_CHARACTER = 48;
// '9'.charCodeAt(0) === 57
const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
const HEX_CHARACTER_OFFSET = 87;
/**
 * Memoized function that returns an array to be used as a lookup table for
 * converting bytes to hexadecimal values.
 *
 * The array is created lazily and then cached for future use. The benefit of
 * this approach is that the performance of converting bytes to hex is much
 * better than if we were to call `toString(16)` on each byte.
 *
 * The downside is that the array is created once and then never garbage
 * collected. This is not a problem in practice because the array is only 256
 * elements long.
 *
 * @returns A function that returns the lookup table.
 */
function getPrecomputedHexValuesBuilder() {
    // To avoid issues with tree shaking, we need to use a function to return the
    // array. This is because the array is only used in the `bytesToHex` function
    // and if we were to use a global variable, the array might be removed by the
    // tree shaker.
    const lookupTable = [];
    return () => {
        if (lookupTable.length === 0) {
            for (let i = 0; i < 256; i++) {
                lookupTable.push(i.toString(16).padStart(2, '0'));
            }
        }
        return lookupTable;
    };
}
/**
 * Function implementation of the {@link getPrecomputedHexValuesBuilder}
 * function.
 */
const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
/**
 * Check if a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @returns Whether the value is a `Uint8Array`.
 */
function isBytes(value) {
    return value instanceof Uint8Array;
}
exports.isBytes = isBytes;
/**
 * Assert that a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @throws If the value is not a `Uint8Array`.
 */
function assertIsBytes(value) {
    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');
}
exports.assertIsBytes = assertIsBytes;
/**
 * Convert a `Uint8Array` to a hexadecimal string.
 *
 * @param bytes - The bytes to convert to a hexadecimal string.
 * @returns The hexadecimal string.
 */
function bytesToHex(bytes) {
    assertIsBytes(bytes);
    if (bytes.length === 0) {
        return '0x';
    }
    const lookupTable = getPrecomputedHexValues();
    const hexadecimal = new Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        hexadecimal[i] = lookupTable[bytes[i]];
    }
    return (0, hex_1.add0x)(hexadecimal.join(''));
}
exports.bytesToHex = bytesToHex;
/**
 * Convert a `Uint8Array` to a `bigint`.
 *
 * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.
 * To convert a two's complement encoded `Uint8Array` to a `bigint`, use
 * {@link bytesToSignedBigInt}.
 *
 * @param bytes - The bytes to convert to a `bigint`.
 * @returns The `bigint`.
 */
function bytesToBigInt(bytes) {
    assertIsBytes(bytes);
    const hexadecimal = bytesToHex(bytes);
    return BigInt(hexadecimal);
}
exports.bytesToBigInt = bytesToBigInt;
/**
 * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are
 * encoded in two's complement.
 *
 * To convert a `Uint8Array` to an unsigned `bigint` instead, use
 * {@link bytesToBigInt}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param bytes - The bytes to convert to a signed `bigint`.
 * @returns The signed `bigint`.
 */
function bytesToSignedBigInt(bytes) {
    assertIsBytes(bytes);
    let value = BigInt(0);
    for (const byte of bytes) {
        // eslint-disable-next-line no-bitwise
        value = (value << BigInt(8)) + BigInt(byte);
    }
    return BigInt.asIntN(bytes.length * 8, value);
}
exports.bytesToSignedBigInt = bytesToSignedBigInt;
/**
 * Convert a `Uint8Array` to a `number`.
 *
 * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.
 *
 * @param bytes - The bytes to convert to a number.
 * @returns The number.
 * @throws If the resulting number is not a safe integer.
 */
function bytesToNumber(bytes) {
    assertIsBytes(bytes);
    const bigint = bytesToBigInt(bytes);
    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');
    return Number(bigint);
}
exports.bytesToNumber = bytesToNumber;
/**
 * Convert a UTF-8 encoded `Uint8Array` to a `string`.
 *
 * @param bytes - The bytes to convert to a string.
 * @returns The string.
 */
function bytesToString(bytes) {
    assertIsBytes(bytes);
    return new TextDecoder().decode(bytes);
}
exports.bytesToString = bytesToString;
/**
 * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be
 * prefixed with `0x`. It accepts even and odd length strings.
 *
 * If the value is "0x", an empty `Uint8Array` is returned.
 *
 * @param value - The hexadecimal string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function hexToBytes(value) {
    var _a;
    // "0x" is often used as empty byte array.
    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {
        return new Uint8Array();
    }
    (0, hex_1.assertIsHexString)(value);
    // Remove the `0x` prefix if it exists, and pad the string to have an even
    // number of characters.
    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();
    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
    const bytes = new Uint8Array(normalizedValue.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        // While this is not the prettiest way to convert a hexadecimal string to a
        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each
        // character.
        const c1 = normalizedValue.charCodeAt(i * 2);
        const c2 = normalizedValue.charCodeAt(i * 2 + 1);
        const n1 = c1 -
            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        const n2 = c2 -
            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        bytes[i] = n1 * 16 + n2;
    }
    return bytes;
}
exports.hexToBytes = hexToBytes;
/**
 * Convert a `bigint` to a `Uint8Array`.
 *
 * This assumes that the `bigint` is an unsigned integer. To convert a signed
 * `bigint` instead, use {@link signedBigIntToBytes}.
 *
 * @param value - The bigint to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function bigIntToBytes(value) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.bigIntToBytes = bigIntToBytes;
/**
 * Check if a `bigint` fits in a certain number of bytes.
 *
 * @param value - The `bigint` to check.
 * @param bytes - The number of bytes.
 * @returns Whether the `bigint` fits in the number of bytes.
 */
function bigIntFits(value, bytes) {
    (0, assert_1.assert)(bytes > 0);
    /* eslint-disable no-bitwise */
    const mask = value >> BigInt(31);
    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));
    /* eslint-enable no-bitwise */
}
/**
 * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement
 * encoding to represent negative numbers.
 *
 * To convert an unsigned `bigint` to a `Uint8Array` instead, use
 * {@link bigIntToBytes}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param value - The number to convert to bytes.
 * @param byteLength - The length of the resulting `Uint8Array`. If the number
 * is larger than the maximum value that can be represented by the given length,
 * an error is thrown.
 * @returns The bytes as `Uint8Array`.
 */
function signedBigIntToBytes(value, byteLength) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');
    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');
    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');
    // ESLint doesn't like mutating function parameters, so to avoid having to
    // disable the rule, we create a new variable.
    let numberValue = value;
    const bytes = new Uint8Array(byteLength);
    for (let i = 0; i < bytes.length; i++) {
        bytes[i] = Number(BigInt.asUintN(8, numberValue));
        // eslint-disable-next-line no-bitwise
        numberValue >>= BigInt(8);
    }
    return bytes.reverse();
}
exports.signedBigIntToBytes = signedBigIntToBytes;
/**
 * Convert a `number` to a `Uint8Array`.
 *
 * @param value - The number to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 * @throws If the number is not a safe integer.
 */
function numberToBytes(value) {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.numberToBytes = numberToBytes;
/**
 * Convert a `string` to a UTF-8 encoded `Uint8Array`.
 *
 * @param value - The string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function stringToBytes(value) {
    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');
    return new TextEncoder().encode(value);
}
exports.stringToBytes = stringToBytes;
/**
 * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,
 * a `bigint`, a `number`, or a `string`.
 *
 * This will attempt to guess the type of the value based on its type and
 * contents. For more control over the conversion, use the more specific
 * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.
 *
 * If the value is a `string`, and it is prefixed with `0x`, it will be
 * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a
 * UTF-8 string. To convert a hexadecimal string to bytes without interpreting
 * it as a UTF-8 string, use {@link hexToBytes} instead.
 *
 * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed
 * `bigint` to bytes, use {@link signedBigIntToBytes} instead.
 *
 * If the value is a `Uint8Array`, it will be returned as-is.
 *
 * @param value - The value to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function valueToBytes(value) {
    if (typeof value === 'bigint') {
        return bigIntToBytes(value);
    }
    if (typeof value === 'number') {
        return numberToBytes(value);
    }
    if (typeof value === 'string') {
        if (value.startsWith('0x')) {
            return hexToBytes(value);
        }
        return stringToBytes(value);
    }
    if (isBytes(value)) {
        return value;
    }
    throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
exports.valueToBytes = valueToBytes;
/**
 * Concatenate multiple byte-like values into a single `Uint8Array`. The values
 * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses
 * {@link valueToBytes} under the hood to convert each value to bytes. Refer to
 * the documentation of that function for more information.
 *
 * @param values - The values to concatenate.
 * @returns The concatenated bytes as `Uint8Array`.
 */
function concatBytes(values) {
    const normalizedValues = new Array(values.length);
    let byteLength = 0;
    for (let i = 0; i < values.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const value = valueToBytes(values[i]);
        normalizedValues[i] = value;
        byteLength += value.length;
    }
    const bytes = new Uint8Array(byteLength);
    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
        // While we could simply spread the values into an array and use
        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.
        bytes.set(normalizedValues[i], offset);
        offset += normalizedValues[i].length;
    }
    return bytes;
}
exports.concatBytes = concatBytes;
/**
 * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience
 * function that avoids having to create a {@link DataView} manually, which
 * requires passing the `byteOffset` and `byteLength` parameters every time.
 *
 * Not passing the `byteOffset` and `byteLength` parameters can result in
 * unexpected behavior when the {@link Uint8Array} is a view of a larger
 * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.
 *
 * This function also supports Node.js {@link Buffer}s.
 *
 * @example
 * ```typescript
 * const bytes = new Uint8Array([1, 2, 3]);
 *
 * // This is equivalent to:
 * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
 * const dataView = createDataView(bytes);
 * ```
 * @param bytes - The bytes to create the {@link DataView} from.
 * @returns The {@link DataView}.
 */
function createDataView(bytes) {
    // To maintain compatibility with Node.js, we need to check if the bytes are
    // a Buffer. If so, we need to slice the buffer to get the underlying
    // ArrayBuffer.
    // eslint-disable-next-line no-restricted-globals
    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {
        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
        return new DataView(buffer);
    }
    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}
exports.createDataView = createDataView;


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/checksum.js":
/*!*******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/checksum.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChecksumStruct = void 0;
const superstruct_1 = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
const base64_1 = __webpack_require__(/*! ./base64 */ "./node_modules/@metamask/utils/dist/base64.js");
exports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/coercers.js":
/*!*******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/coercers.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;
const superstruct_1 = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
const assert_1 = __webpack_require__(/*! ./assert */ "./node_modules/@metamask/utils/dist/assert.js");
const bytes_1 = __webpack_require__(/*! ./bytes */ "./node_modules/@metamask/utils/dist/bytes.js");
const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@metamask/utils/dist/hex.js");
const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);
const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
const BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);
const HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
/**
 * Create a number from a number-like value.
 *
 * - If the value is a number, it is returned as-is.
 * - If the value is a `bigint`, it is converted to a number.
 * - If the value is a string, it is interpreted as a decimal number.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number.
 *
 * This validates that the value is a number-like value, and that the resulting
 * number is not `NaN` or `Infinity`.
 *
 * @example
 * ```typescript
 * const value = createNumber('0x010203');
 * console.log(value); // 66051
 *
 * const otherValue = createNumber(123n);
 * console.log(otherValue); // 123
 * ```
 * @param value - The value to create the number from.
 * @returns The created number.
 * @throws If the value is not a number-like value, or if the resulting number
 * is `NaN` or `Infinity`.
 */
function createNumber(value) {
    try {
        const result = (0, superstruct_1.create)(value, NumberCoercer);
        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
        return result;
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${value}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createNumber = createNumber;
/**
 * Create a `bigint` from a number-like value.
 *
 * - If the value is a number, it is converted to a `bigint`.
 * - If the value is a `bigint`, it is returned as-is.
 * - If the value is a string, it is interpreted as a decimal number and
 * converted to a `bigint`.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number and converted to a `bigint`.
 *
 * @example
 * ```typescript
 * const value = createBigInt('0x010203');
 * console.log(value); // 16909060n
 *
 * const otherValue = createBigInt(123);
 * console.log(otherValue); // 123n
 * ```
 * @param value - The value to create the bigint from.
 * @returns The created bigint.
 * @throws If the value is not a number-like value.
 */
function createBigInt(value) {
    try {
        // The `BigInt` constructor throws if the value is not a number-like value.
        // There is no need to validate the value manually.
        return (0, superstruct_1.create)(value, BigIntCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBigInt = createBigInt;
/**
 * Create a byte array from a bytes-like value.
 *
 * - If the value is a byte array, it is returned as-is.
 * - If the value is a hex string (i.e., it starts with "0x"), it is interpreted
 * as a hexadecimal number and converted to a byte array.
 *
 * @example
 * ```typescript
 * const value = createBytes('0x010203');
 * console.log(value); // Uint8Array [ 1, 2, 3 ]
 *
 * const otherValue = createBytes('0x010203');
 * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]
 * ```
 * @param value - The value to create the byte array from.
 * @returns The created byte array.
 * @throws If the value is not a bytes-like value.
 */
function createBytes(value) {
    if (typeof value === 'string' && value.toLowerCase() === '0x') {
        return new Uint8Array();
    }
    try {
        return (0, superstruct_1.create)(value, BytesCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBytes = createBytes;
/**
 * Create a hexadecimal string from a bytes-like value.
 *
 * - If the value is a hex string (i.e., it starts with "0x"), it is returned
 * as-is.
 * - If the value is a `Uint8Array`, it is converted to a hex string.
 *
 * @example
 * ```typescript
 * const value = createHex(new Uint8Array([1, 2, 3]));
 * console.log(value); // '0x010203'
 *
 * const otherValue = createHex('0x010203');
 * console.log(otherValue); // '0x010203'
 * ```
 * @param value - The value to create the hex string from.
 * @returns The created hex string.
 * @throws If the value is not a bytes-like value.
 */
function createHex(value) {
    if ((value instanceof Uint8Array && value.length === 0) ||
        (typeof value === 'string' && value.toLowerCase() === '0x')) {
        return '0x';
    }
    try {
        return (0, superstruct_1.create)(value, HexCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createHex = createHex;


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/collections.js":
/*!**********************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/collections.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FrozenMap_map, _FrozenSet_set;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrozenSet = exports.FrozenMap = void 0;
/**
 * A {@link ReadonlyMap} that cannot be modified after instantiation.
 * The implementation uses an inner map hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this map.
 */
class FrozenMap {
    constructor(entries) {
        _FrozenMap_map.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
    }
    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner map.
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
    }
    get(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key);
    }
    has(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
    }
    toString() {
        return `FrozenMap(${this.size}) {${this.size > 0
            ? ` ${[...this.entries()]
                .map(([key, value]) => `${String(key)} => ${String(value)}`)
                .join(', ')} `
            : ''}}`;
    }
}
exports.FrozenMap = FrozenMap;
/**
 * A {@link ReadonlySet} that cannot be modified after instantiation.
 * The implementation uses an inner set hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this set.
 */
class FrozenSet {
    constructor(values) {
        _FrozenSet_set.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
    }
    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner set.
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
    }
    has(value) {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
    }
    toString() {
        return `FrozenSet(${this.size}) {${this.size > 0
            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `
            : ''}}`;
    }
}
exports.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/encryption-types.js":
/*!***************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/encryption-types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/hex.js":
/*!**************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/hex.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
const superstruct_1 = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
const assert_1 = __webpack_require__(/*! ./assert */ "./node_modules/@metamask/utils/dist/assert.js");
exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
/**
 * Check if a string is a valid hex string.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isHexString(value) {
    return (0, superstruct_1.is)(value, exports.HexStruct);
}
exports.isHexString = isHexString;
/**
 * Strictly check if a string is a valid hex string. A valid hex string must
 * start with the "0x"-prefix.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isStrictHexString(value) {
    return (0, superstruct_1.is)(value, exports.StrictHexStruct);
}
exports.isStrictHexString = isStrictHexString;
/**
 * Assert that a value is a valid hex string.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsHexString(value) {
    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');
}
exports.assertIsHexString = assertIsHexString;
/**
 * Assert that a value is a valid hex string. A valid hex string must start with
 * the "0x"-prefix.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsStrictHexString(value) {
    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
}
exports.assertIsStrictHexString = assertIsStrictHexString;
/**
 * Add the `0x`-prefix to a hexadecimal string. If the string already has the
 * prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to add the prefix to.
 * @returns The prefixed hexadecimal string.
 */
function add0x(hexadecimal) {
    if (hexadecimal.startsWith('0x')) {
        return hexadecimal;
    }
    if (hexadecimal.startsWith('0X')) {
        return `0x${hexadecimal.substring(2)}`;
    }
    return `0x${hexadecimal}`;
}
exports.add0x = add0x;
/**
 * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have
 * the prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to remove the prefix from.
 * @returns The un-prefixed hexadecimal string.
 */
function remove0x(hexadecimal) {
    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {
        return hexadecimal.substring(2);
    }
    return hexadecimal;
}
exports.remove0x = remove0x;


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./assert */ "./node_modules/@metamask/utils/dist/assert.js"), exports);
__exportStar(__webpack_require__(/*! ./base64 */ "./node_modules/@metamask/utils/dist/base64.js"), exports);
__exportStar(__webpack_require__(/*! ./bytes */ "./node_modules/@metamask/utils/dist/bytes.js"), exports);
__exportStar(__webpack_require__(/*! ./checksum */ "./node_modules/@metamask/utils/dist/checksum.js"), exports);
__exportStar(__webpack_require__(/*! ./coercers */ "./node_modules/@metamask/utils/dist/coercers.js"), exports);
__exportStar(__webpack_require__(/*! ./collections */ "./node_modules/@metamask/utils/dist/collections.js"), exports);
__exportStar(__webpack_require__(/*! ./encryption-types */ "./node_modules/@metamask/utils/dist/encryption-types.js"), exports);
__exportStar(__webpack_require__(/*! ./hex */ "./node_modules/@metamask/utils/dist/hex.js"), exports);
__exportStar(__webpack_require__(/*! ./json */ "./node_modules/@metamask/utils/dist/json.js"), exports);
__exportStar(__webpack_require__(/*! ./keyring */ "./node_modules/@metamask/utils/dist/keyring.js"), exports);
__exportStar(__webpack_require__(/*! ./logging */ "./node_modules/@metamask/utils/dist/logging.js"), exports);
__exportStar(__webpack_require__(/*! ./misc */ "./node_modules/@metamask/utils/dist/misc.js"), exports);
__exportStar(__webpack_require__(/*! ./number */ "./node_modules/@metamask/utils/dist/number.js"), exports);
__exportStar(__webpack_require__(/*! ./opaque */ "./node_modules/@metamask/utils/dist/opaque.js"), exports);
__exportStar(__webpack_require__(/*! ./time */ "./node_modules/@metamask/utils/dist/time.js"), exports);
__exportStar(__webpack_require__(/*! ./transaction-types */ "./node_modules/@metamask/utils/dist/transaction-types.js"), exports);
__exportStar(__webpack_require__(/*! ./versions */ "./node_modules/@metamask/utils/dist/versions.js"), exports);


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/json.js":
/*!***************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/json.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.getJsonSize = exports.isValidJson = exports.JsonStruct = exports.UnsafeJsonStruct = void 0;
const superstruct_1 = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
const assert_1 = __webpack_require__(/*! ./assert */ "./node_modules/@metamask/utils/dist/assert.js");
/**
 * A struct to check if the given value is finite number. Superstruct's
 * `number()` struct does not check if the value is finite.
 *
 * @returns A struct to check if the given value is finite number.
 */
const finiteNumber = () => (0, superstruct_1.define)('finite number', (value) => {
    return (0, superstruct_1.is)(value, (0, superstruct_1.number)()) && Number.isFinite(value);
});
/**
 * A struct to check if the given value is a valid JSON-serializable value.
 *
 * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.
 */
// We cannot infer the type of the struct, because it is recursive.
exports.UnsafeJsonStruct = (0, superstruct_1.union)([
    (0, superstruct_1.literal)(null),
    (0, superstruct_1.boolean)(),
    finiteNumber(),
    (0, superstruct_1.string)(),
    (0, superstruct_1.array)((0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct)),
    (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct)),
]);
/**
 * A struct to check if the given value is a valid JSON-serializable value.
 *
 * This struct sanitizes the value before validating it, so that it is safe to
 * use with untrusted input.
 */
exports.JsonStruct = (0, superstruct_1.define)('Json', (value, context) => {
    /**
     * Helper function that runs the given struct validator and returns the
     * validation errors, if any. If the value is valid, it returns `true`.
     *
     * @param innerValue - The value to validate.
     * @param struct - The struct to use for validation.
     * @returns The validation errors, or `true` if the value is valid.
     */
    function checkStruct(innerValue, struct) {
        const iterator = struct.validator(innerValue, context);
        const errors = [...iterator];
        if (errors.length > 0) {
            return errors;
        }
        return true;
    }
    try {
        // The plain value must be a valid JSON value, but it may be altered in the
        // process of JSON serialization, so we need to validate it again after
        // serialization. This has the added benefit that the returned error messages
        // will be more helpful, as they will point to the exact location of the
        // invalid value.
        //
        // This seems overcomplicated, but without checking the plain value first,
        // there are some cases where the validation passes, even though the value is
        // not valid JSON. For example, `undefined` is not valid JSON, but serializing
        // it will remove it from the object, so the validation will pass.
        const unsafeResult = checkStruct(value, exports.UnsafeJsonStruct);
        if (unsafeResult !== true) {
            return unsafeResult;
        }
        // JavaScript engines are highly optimized for this specific use case of
        // JSON parsing and stringifying, so there should be no performance impact.
        return checkStruct(JSON.parse(JSON.stringify(value)), exports.UnsafeJsonStruct);
    }
    catch (error) {
        if (error instanceof RangeError) {
            return 'Circular reference detected';
        }
        return false;
    }
});
/**
 * Check if the given value is a valid {@link Json} value, i.e., a value that is
 * serializable to JSON.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid {@link Json} value.
 */
function isValidJson(value) {
    return (0, superstruct_1.is)(value, exports.JsonStruct);
}
exports.isValidJson = isValidJson;
/**
 * Get the size of a JSON value in bytes. This also validates the value.
 *
 * @param value - The JSON value to get the size of.
 * @returns The size of the JSON value in bytes.
 */
function getJsonSize(value) {
    (0, assert_1.assertStruct)(value, exports.JsonStruct, 'Invalid JSON value');
    const json = JSON.stringify(value);
    return new TextEncoder().encode(json).byteLength;
}
exports.getJsonSize = getJsonSize;
/**
 * The string '2.0'.
 */
exports.jsonrpc2 = '2.0';
exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
    code: (0, superstruct_1.integer)(),
    message: (0, superstruct_1.string)(),
    data: (0, superstruct_1.optional)(exports.JsonStruct),
    stack: (0, superstruct_1.optional)((0, superstruct_1.string)()),
});
exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    method: (0, superstruct_1.string)(),
    params: exports.JsonRpcParamsStruct,
});
exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);
/**
 * Check if the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcNotification}
 * object.
 */
function isJsonRpcNotification(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
}
exports.isJsonRpcNotification = isJsonRpcNotification;
/**
 * Assert that the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcNotification} object.
 */
function assertIsJsonRpcNotification(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
}
exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
/**
 * Check if the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcRequest} object.
 */
function isJsonRpcRequest(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
}
exports.isJsonRpcRequest = isJsonRpcRequest;
/**
 * Assert that the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The JSON-RPC request or notification to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcRequest} object.
 */
function assertIsJsonRpcRequest(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
}
exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),
});
exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: exports.JsonStruct,
});
exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    error: exports.JsonRpcErrorStruct,
});
exports.JsonRpcResponseStruct = (0, superstruct_1.union)([
    exports.JsonRpcSuccessStruct,
    exports.JsonRpcFailureStruct,
]);
/**
 * Type guard to check whether specified JSON-RPC response is a
 * {@link PendingJsonRpcResponse}.
 *
 * @param response - The JSON-RPC response to check.
 * @returns Whether the specified JSON-RPC response is pending.
 */
function isPendingJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
}
exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.
 *
 * @param response - The JSON-RPC response to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link PendingJsonRpcResponse}
 * object.
 */
function assertIsPendingJsonRpcResponse(response, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
}
exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
/**
 * Type guard to check if a value is a {@link JsonRpcResponse}.
 *
 * @param response - The object to check.
 * @returns Whether the object is a JsonRpcResponse.
 */
function isJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
}
exports.isJsonRpcResponse = isJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link JsonRpcResponse} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcResponse} object.
 */
function assertIsJsonRpcResponse(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
}
exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
/**
 * Check if the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.
 */
function isJsonRpcSuccess(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
}
exports.isJsonRpcSuccess = isJsonRpcSuccess;
/**
 * Assert that the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcSuccess} object.
 */
function assertIsJsonRpcSuccess(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
}
exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
/**
 * Check if the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcFailure} object.
 */
function isJsonRpcFailure(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
}
exports.isJsonRpcFailure = isJsonRpcFailure;
/**
 * Assert that the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcFailure} object.
 */
function assertIsJsonRpcFailure(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
}
exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
/**
 * Check if the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcError} object.
 */
function isJsonRpcError(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
}
exports.isJsonRpcError = isJsonRpcError;
/**
 * Assert that the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcError} object.
 */
function assertIsJsonRpcError(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
}
exports.assertIsJsonRpcError = assertIsJsonRpcError;
/**
 * Gets a function for validating JSON-RPC request / response `id` values.
 *
 * By manipulating the options of this factory, you can control the behavior
 * of the resulting validator for some edge cases. This is useful because e.g.
 * `null` should sometimes but not always be permitted.
 *
 * Note that the empty string (`''`) is always permitted by the JSON-RPC
 * specification, but that kind of sucks and you may want to forbid it in some
 * instances anyway.
 *
 * For more details, see the
 * [JSON-RPC Specification](https://www.jsonrpc.org/specification).
 *
 * @param options - An options object.
 * @param options.permitEmptyString - Whether the empty string (i.e. `''`)
 * should be treated as a valid ID. Default: `true`
 * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)
 * should be treated as valid IDs. Default: `false`
 * @param options.permitNull - Whether `null` should be treated as a valid ID.
 * Default: `true`
 * @returns The JSON-RPC ID validator function.
 */
function getJsonRpcIdValidator(options) {
    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
    /**
     * Type guard for {@link JsonRpcId}.
     *
     * @param id - The JSON-RPC ID value to check.
     * @returns Whether the given ID is valid per the options given to the
     * factory.
     */
    const isValidJsonRpcId = (id) => {
        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||
            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||
            (permitNull && id === null));
    };
    return isValidJsonRpcId;
}
exports.getJsonRpcIdValidator = getJsonRpcIdValidator;


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/keyring.js":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/keyring.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/logging.js":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/logging.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createModuleLogger = exports.createProjectLogger = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const globalLogger = (0, debug_1.default)('metamask');
/**
 * Creates a logger via the `debug` library whose log messages will be tagged
 * using the name of your project. By default, such messages will be
 * suppressed, but you can reveal them by setting the `DEBUG` environment
 * variable to `metamask:<projectName>`. You can also set this variable to
 * `metamask:*` if you want to see log messages from all MetaMask projects that
 * are also using this function to create their loggers.
 *
 * @param projectName - The name of your project. This should be the name of
 * your NPM package if you're developing one.
 * @returns An instance of `debug`.
 */
function createProjectLogger(projectName) {
    return globalLogger.extend(projectName);
}
exports.createProjectLogger = createProjectLogger;
/**
 * Creates a logger via the `debug` library which is derived from the logger for
 * the whole project whose log messages will be tagged using the name of your
 * module. By default, such messages will be suppressed, but you can reveal them
 * by setting the `DEBUG` environment variable to
 * `metamask:<projectName>:<moduleName>`. You can also set this variable to
 * `metamask:<projectName>:*` if you want to see log messages from the project,
 * or `metamask:*` if you want to see log messages from all MetaMask projects.
 *
 * @param projectLogger - The logger created via {@link createProjectLogger}.
 * @param moduleName - The name of your module. You could use the name of the
 * file where you're using this logger or some other name.
 * @returns An instance of `debug`.
 */
function createModuleLogger(projectLogger, moduleName) {
    return projectLogger.extend(moduleName);
}
exports.createModuleLogger = createModuleLogger;


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/misc.js":
/*!***************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/misc.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
// Types
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
//
// Type Guards
//
/**
 * A {@link NonEmptyArray} type guard.
 *
 * @template Element - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * Type guard for "nullishness".
 *
 * @param value - Any value.
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * A type guard for {@link RuntimeObject}.
 *
 * @param value - The value to check.
 * @returns Whether the specified value has a runtime type of `object` and is
 * neither `null` nor an `Array`.
 */
function isObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isObject = isObject;
//
// Other utility functions
//
/**
 * A type guard for ensuring an object has a property.
 *
 * @param objectToCheck - The object to check.
 * @param name - The property name to check for.
 * @returns Whether the specified object has an own property with the specified
 * name, regardless of whether it is enumerable or not.
 */
const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
exports.hasProperty = hasProperty;
/**
 * Predefined sizes (in Bytes) of specific parts of JSON structure.
 */
var JsonSize;
(function (JsonSize) {
    JsonSize[JsonSize["Null"] = 4] = "Null";
    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    JsonSize[JsonSize["True"] = 4] = "True";
    JsonSize[JsonSize["False"] = 5] = "False";
    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    // eslint-disable-next-line @typescript-eslint/no-shadow
    JsonSize[JsonSize["Date"] = 24] = "Date";
})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));
/**
 * Regular expression with pattern matching for (special) escaped characters.
 */
exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
/**
 * Check if the value is plain object.
 *
 * @param value - Value to be checked.
 * @returns True if an object is the plain JavaScript object,
 * false if the object is not plain (e.g. function).
 */
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    try {
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    }
    catch (_) {
        return false;
    }
}
exports.isPlainObject = isPlainObject;
/**
 * Check if character is ASCII.
 *
 * @param character - Character.
 * @returns True if a character code is ASCII, false if not.
 */
function isASCII(character) {
    return character.charCodeAt(0) <= 127;
}
exports.isASCII = isASCII;
/**
 * Calculate string size.
 *
 * @param value - String value to calculate size.
 * @returns Number of bytes used to store whole string value.
 */
function calculateStringSize(value) {
    var _a;
    const size = value.split('').reduce((total, character) => {
        if (isASCII(character)) {
            return total + 1;
        }
        return total + 2;
    }, 0);
    // Also detect characters that need backslash escape
    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
}
exports.calculateStringSize = calculateStringSize;
/**
 * Calculate size of a number ofter JSON serialization.
 *
 * @param value - Number value to calculate size.
 * @returns Number of bytes used to store whole number in JSON.
 */
function calculateNumberSize(value) {
    return value.toString().length;
}
exports.calculateNumberSize = calculateNumberSize;


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/number.js":
/*!*****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/number.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;
const assert_1 = __webpack_require__(/*! ./assert */ "./node_modules/@metamask/utils/dist/assert.js");
const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@metamask/utils/dist/hex.js");
/**
 * Convert a number to a hexadecimal string. This verifies that the number is a
 * non-negative safe integer.
 *
 * To convert a `bigint` to a hexadecimal string instead, use
 * {@link bigIntToHex}.
 *
 * @example
 * ```typescript
 * numberToHex(0); // '0x0'
 * numberToHex(1); // '0x1'
 * numberToHex(16); // '0x10'
 * ```
 * @param value - The number to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the number is not a non-negative safe integer.
 */
const numberToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.numberToHex = numberToHex;
/**
 * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`
 * is a non-negative integer.
 *
 * To convert a number to a hexadecimal string instead, use {@link numberToHex}.
 *
 * @example
 * ```typescript
 * bigIntToHex(0n); // '0x0'
 * bigIntToHex(1n); // '0x1'
 * bigIntToHex(16n); // '0x10'
 * ```
 * @param value - The `bigint` to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the `bigint` is not a non-negative integer.
 */
const bigIntToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.bigIntToHex = bigIntToHex;
/**
 * Convert a hexadecimal string to a number. This verifies that the string is a
 * valid hex string, and that the resulting number is a safe integer. Both
 * "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a `bigint` instead, use
 * {@link hexToBigInt}.
 *
 * @example
 * ```typescript
 * hexToNumber('0x0'); // 0
 * hexToNumber('0x1'); // 1
 * hexToNumber('0x10'); // 16
 * ```
 * @param value - The hexadecimal string to convert to a number.
 * @returns The number.
 * @throws If the value is not a valid hexadecimal string, or if the resulting
 * number is not a safe integer.
 */
const hexToNumber = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // `parseInt` accepts values without the "0x"-prefix, whereas `Number` does
    // not. Using this is slightly faster than `Number(add0x(value))`.
    const numberValue = parseInt(value, 16);
    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
    return numberValue;
};
exports.hexToNumber = hexToNumber;
/**
 * Convert a hexadecimal string to a `bigint`. This verifies that the string is
 * a valid hex string. Both "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.
 *
 * @example
 * ```typescript
 * hexToBigInt('0x0'); // 0n
 * hexToBigInt('0x1'); // 1n
 * hexToBigInt('0x10'); // 16n
 * ```
 * @param value - The hexadecimal string to convert to a `bigint`.
 * @returns The `bigint`.
 * @throws If the value is not a valid hexadecimal string.
 */
const hexToBigInt = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // The `BigInt` constructor requires the "0x"-prefix to parse a hex string.
    return BigInt((0, hex_1.add0x)(value));
};
exports.hexToBigInt = hexToBigInt;


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/opaque.js":
/*!*****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/opaque.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/time.js":
/*!***************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/time.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
/**
 * Common duration constants, in milliseconds.
 */
var Duration;
(function (Duration) {
    /**
     * A millisecond.
     */
    Duration[Duration["Millisecond"] = 1] = "Millisecond";
    /**
     * A second, in milliseconds.
     */
    Duration[Duration["Second"] = 1000] = "Second";
    /**
     * A minute, in milliseconds.
     */
    Duration[Duration["Minute"] = 60000] = "Minute";
    /**
     * An hour, in milliseconds.
     */
    Duration[Duration["Hour"] = 3600000] = "Hour";
    /**
     * A day, in milliseconds.
     */
    Duration[Duration["Day"] = 86400000] = "Day";
    /**
     * A week, in milliseconds.
     */
    Duration[Duration["Week"] = 604800000] = "Week";
    /**
     * A year, in milliseconds.
     */
    Duration[Duration["Year"] = 31536000000] = "Year";
})(Duration = exports.Duration || (exports.Duration = {}));
const isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
const assertIsNonNegativeInteger = (number, name) => {
    if (!isNonNegativeInteger(number)) {
        throw new Error(`"${name}" must be a non-negative integer. Received: "${number}".`);
    }
};
/**
 * Calculates the millisecond value of the specified number of units of time.
 *
 * @param count - The number of units of time.
 * @param duration - The unit of time to count.
 * @returns The count multiplied by the specified duration.
 */
function inMilliseconds(count, duration) {
    assertIsNonNegativeInteger(count, 'count');
    return count * duration;
}
exports.inMilliseconds = inMilliseconds;
/**
 * Gets the milliseconds since a particular Unix epoch timestamp.
 *
 * @param timestamp - A Unix millisecond timestamp.
 * @returns The number of milliseconds elapsed since the specified timestamp.
 */
function timeSince(timestamp) {
    assertIsNonNegativeInteger(timestamp, 'timestamp');
    return Date.now() - timestamp;
}
exports.timeSince = timeSince;


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/transaction-types.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/transaction-types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/@metamask/utils/dist/versions.js":
/*!*******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/versions.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;
const semver_1 = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const superstruct_1 = __webpack_require__(/*! superstruct */ "./node_modules/superstruct/dist/index.mjs");
const assert_1 = __webpack_require__(/*! ./assert */ "./node_modules/@metamask/utils/dist/assert.js");
/**
 * A struct for validating a version string.
 */
exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {
    if ((0, semver_1.valid)(value) === null) {
        return `Expected SemVer version, got "${value}"`;
    }
    return true;
});
exports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {
    if ((0, semver_1.validRange)(value) === null) {
        return `Expected SemVer range, got "${value}"`;
    }
    return true;
});
/**
 * Checks whether a SemVer version is valid.
 *
 * @param version - A potential version.
 * @returns `true` if the version is valid, and `false` otherwise.
 */
function isValidSemVerVersion(version) {
    return (0, superstruct_1.is)(version, exports.VersionStruct);
}
exports.isValidSemVerVersion = isValidSemVerVersion;
/**
 * Checks whether a SemVer version range is valid.
 *
 * @param versionRange - A potential version range.
 * @returns `true` if the version range is valid, and `false` otherwise.
 */
function isValidSemVerRange(versionRange) {
    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);
}
exports.isValidSemVerRange = isValidSemVerRange;
/**
 * Asserts that a value is a valid concrete SemVer version.
 *
 * @param version - A potential SemVer concrete version.
 */
function assertIsSemVerVersion(version) {
    (0, assert_1.assertStruct)(version, exports.VersionStruct);
}
exports.assertIsSemVerVersion = assertIsSemVerVersion;
/**
 * Asserts that a value is a valid SemVer range.
 *
 * @param range - A potential SemVer range.
 */
function assertIsSemVerRange(range) {
    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);
}
exports.assertIsSemVerRange = assertIsSemVerRange;
/**
 * Checks whether a SemVer version is greater than another.
 *
 * @param version1 - The left-hand version.
 * @param version2 - The right-hand version.
 * @returns `version1 > version2`.
 */
function gtVersion(version1, version2) {
    return (0, semver_1.gt)(version1, version2);
}
exports.gtVersion = gtVersion;
/**
 * Checks whether a SemVer version is greater than all possibilities in a range.
 *
 * @param version - A SemvVer version.
 * @param range - The range to check against.
 * @returns `version > range`.
 */
function gtRange(version, range) {
    return (0, semver_1.gtr)(version, range);
}
exports.gtRange = gtRange;
/**
 * Returns whether a SemVer version satisfies a SemVer range.
 *
 * @param version - The SemVer version to check.
 * @param versionRange - The SemVer version range to check against.
 * @returns Whether the version satisfied the version range.
 */
function satisfiesVersionRange(version, versionRange) {
    return (0, semver_1.satisfies)(version, versionRange, {
        includePrerelease: true,
    });
}
exports.satisfiesVersionRange = satisfiesVersionRange;


/***/ }),

/***/ "./node_modules/@noble/hashes/_assert.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/_assert.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
exports["default"] = assert;


/***/ }),

/***/ "./node_modules/@noble/hashes/_u64.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/_u64.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig: exports.toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;


/***/ }),

/***/ "./node_modules/@noble/hashes/crypto.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/crypto.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;


/***/ }),

/***/ "./node_modules/@noble/hashes/sha3.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/sha3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = __webpack_require__(/*! ./_assert.js */ "./node_modules/@noble/hashes/_assert.js");
const _u64_js_1 = __webpack_require__(/*! ./_u64.js */ "./node_modules/@noble/hashes/_u64.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        _assert_js_1.default.number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);


/***/ }),

/***/ "./node_modules/@noble/hashes/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/hashes/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
const crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ "./node_modules/@noble/hashes/crypto.js");
const u8a = (a) => a instanceof Uint8Array;
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;


/***/ }),

/***/ "./node_modules/@scure/base/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@scure/base/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
// Utilities
/**
 * @__NO_SIDE_EFFECTS__
 */
function assertNumber(n) {
    if (!Number.isSafeInteger(n))
        throw new Error(`Wrong integer: ${n}`);
}
exports.assertNumber = assertNumber;
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function chain(...args) {
    const id = (a) => a;
    // Wrap call in closure so JIT can inline calls
    const wrap = (a, b) => (c) => a(b(c));
    // Construct chain of args[-1].encode(args[-2].encode([...]))
    const encode = args.map((x) => x.encode).reduceRight(wrap, id);
    // Construct chain of args[0].decode(args[1].decode(...))
    const decode = args.map((x) => x.decode).reduce(wrap, id);
    return { encode, decode };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back
 * @__NO_SIDE_EFFECTS__
 */
function alphabet(alphabet) {
    return {
        encode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('alphabet.encode input should be an array of numbers');
            return digits.map((i) => {
                assertNumber(i);
                if (i < 0 || i >= alphabet.length)
                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);
                return alphabet[i];
            });
        },
        decode: (input) => {
            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))
                throw new Error('alphabet.decode input should be array of strings');
            return input.map((letter) => {
                if (typeof letter !== 'string')
                    throw new Error(`alphabet.decode: not string element=${letter}`);
                const index = alphabet.indexOf(letter);
                if (index === -1)
                    throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet}`);
                return index;
            });
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function join(separator = '') {
    if (typeof separator !== 'string')
        throw new Error('join separator should be string');
    return {
        encode: (from) => {
            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))
                throw new Error('join.encode input should be array of strings');
            for (let i of from)
                if (typeof i !== 'string')
                    throw new Error(`join.encode: non-string input=${i}`);
            return from.join(separator);
        },
        decode: (to) => {
            if (typeof to !== 'string')
                throw new Error('join.decode input should be string');
            return to.split(separator);
        },
    };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */
function padding(bits, chr = '=') {
    assertNumber(bits);
    if (typeof chr !== 'string')
        throw new Error('padding chr should be string');
    return {
        encode(data) {
            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))
                throw new Error('padding.encode input should be array of strings');
            for (let i of data)
                if (typeof i !== 'string')
                    throw new Error(`padding.encode: non-string input=${i}`);
            while ((data.length * bits) % 8)
                data.push(chr);
            return data;
        },
        decode(input) {
            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))
                throw new Error('padding.encode input should be array of strings');
            for (let i of input)
                if (typeof i !== 'string')
                    throw new Error(`padding.decode: non-string input=${i}`);
            let end = input.length;
            if ((end * bits) % 8)
                throw new Error('Invalid padding: string should have whole number of bytes');
            for (; end > 0 && input[end - 1] === chr; end--) {
                if (!(((end - 1) * bits) % 8))
                    throw new Error('Invalid padding: string has too much padding');
            }
            return input.slice(0, end);
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function normalize(fn) {
    if (typeof fn !== 'function')
        throw new Error('normalize fn should be function');
    return { encode: (from) => from, decode: (to) => fn(to) };
}
/**
 * Slow: O(n^2) time complexity
 * @__NO_SIDE_EFFECTS__
 */
function convertRadix(data, from, to) {
    // base 1 is impossible
    if (from < 2)
        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
    if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
    if (!Array.isArray(data))
        throw new Error('convertRadix: data should be array');
    if (!data.length)
        return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data);
    digits.forEach((d) => {
        assertNumber(d);
        if (d < 0 || d >= from)
            throw new Error(`Wrong integer: ${d}`);
    });
    while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < digits.length; i++) {
            const digit = digits[i];
            const digitBase = from * carry + digit;
            if (!Number.isSafeInteger(digitBase) ||
                (from * carry) / from !== carry ||
                digitBase - digit !== from * carry) {
                throw new Error('convertRadix: carry overflow');
            }
            carry = digitBase % to;
            const rounded = Math.floor(digitBase / to);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
                throw new Error('convertRadix: carry overflow');
            if (!done)
                continue;
            else if (!rounded)
                pos = i;
            else
                done = false;
        }
        res.push(carry);
        if (done)
            break;
    }
    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
    return res.reverse();
}
const gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));
const radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
/**
 * Implemented with numbers, because BigInt is 5x slower
 * @__NO_SIDE_EFFECTS__
 */
function convertRadix2(data, from, to, padding) {
    if (!Array.isArray(data))
        throw new Error('convertRadix2: data should be array');
    if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0; // bitwise position in current element
    const mask = 2 ** to - 1;
    const res = [];
    for (const n of data) {
        assertNumber(n);
        if (n >= 2 ** from)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = (carry << from) | n;
        if (pos + from > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
            res.push(((carry >> (pos - to)) & mask) >>> 0);
        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow
    }
    carry = (carry << (to - pos)) & mask;
    if (!padding && pos >= from)
        throw new Error('Excess padding');
    if (!padding && carry)
        throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0)
        res.push(carry >>> 0);
    return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function radix(num) {
    assertNumber(num);
    return {
        encode: (bytes) => {
            if (!isBytes(bytes))
                throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), 2 ** 8, num);
        },
        decode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('radix.decode input should be array of numbers');
            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
        },
    };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */
function radix2(bits, revPadding = false) {
    assertNumber(bits);
    if (bits <= 0 || bits > 32)
        throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error('radix2: carry overflow');
    return {
        encode: (bytes) => {
            if (!isBytes(bytes))
                throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('radix2.decode input should be array of numbers');
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function unsafeWrapper(fn) {
    if (typeof fn !== 'function')
        throw new Error('unsafeWrapper fn should be function');
    return function (...args) {
        try {
            return fn.apply(null, args);
        }
        catch (e) { }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function checksum(len, fn) {
    assertNumber(len);
    if (typeof fn !== 'function')
        throw new Error('checksum fn should be function');
    return {
        encode(data) {
            if (!isBytes(data))
                throw new Error('checksum.encode: input should be Uint8Array');
            const checksum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(checksum, data.length);
            return res;
        },
        decode(data) {
            if (!isBytes(data))
                throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const newChecksum = fn(payload).slice(0, len);
            const oldChecksum = data.slice(-len);
            for (let i = 0; i < len; i++)
                if (newChecksum[i] !== oldChecksum[i])
                    throw new Error('Invalid checksum');
            return payload;
        },
    };
}
// prettier-ignore
exports.utils = {
    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,
};
// RFC 4648 aka RFC 3548
// ---------------------
exports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
exports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
exports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
exports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
exports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
exports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
exports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));
exports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
exports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
exports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.
// Block encoding significantly reduces quadratic complexity of base58.
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
exports.base58xmr = {
    encode(data) {
        let res = '';
        for (let i = 0; i < data.length; i += 8) {
            const block = data.subarray(i, i + 8);
            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = exports.base58.decode(slice);
            for (let j = 0; j < block.length - blockLen; j++) {
                if (block[j] !== 0)
                    throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    },
};
const createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);
exports.createBase58check = createBase58check;
// legacy export, bad name
exports.base58check = exports.createBase58check;
const BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
/**
 * @__NO_SIDE_EFFECTS__
 */
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if (((b >> i) & 1) === 1)
            chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ (c >> 5);
    }
    chk = bech32Polymod(chk);
    for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);
    for (let v of words)
        chk = bech32Polymod(chk) ^ v;
    for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        if (typeof prefix !== 'string')
            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))
            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode(str, limit = 90) {
        if (typeof str !== 'string')
            throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || (limit !== false && str.length > limit))
            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        // don't allow mixed case
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words = str.slice(sepIndex + 1);
        if (_words.length < 6)
            throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(_words).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!_words.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
    }
    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
exports.bech32 = genBech32('bech32');
exports.bech32m = genBech32('bech32m');
exports.utf8 = {
    encode: (data) => new TextDecoder().decode(data),
    decode: (str) => new TextEncoder().encode(str),
};
exports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {
    if (typeof s !== 'string' || s.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
}));
// prettier-ignore
const CODERS = {
    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
const bytesToString = (type, bytes) => {
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (!isBytes(bytes))
        throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
exports.bytesToString = bytesToString;
exports.str = exports.bytesToString; // as in python, but for bytes only
const stringToBytes = (type, str) => {
    if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (typeof str !== 'string')
        throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
exports.stringToBytes = stringToBytes;
exports.bytes = exports.stringToBytes;


/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ "./node_modules/fast-safe-stringify/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-safe-stringify/index.js ***!
  \***************************************************/
/***/ ((module) => {

module.exports = stringify
stringify.default = stringify
stringify.stable = deterministicStringify
stringify.stableStringify = deterministicStringify

var LIMIT_REPLACE_NODE = '[...]'
var CIRCULAR_REPLACE_NODE = '[Circular]'

var arr = []
var replacerStack = []

function defaultOptions () {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  }
}

// Regular stringify
function stringify (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions()
  }

  decirc(obj, '', 0, [], undefined, 0, options)
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer)
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}

function setReplace (replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)
  if (propertyDescriptor.get !== undefined) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace })
      arr.push([parent, k, val, propertyDescriptor])
    } else {
      replacerStack.push([val, k, replace])
    }
  } else {
    parent[k] = replace
    arr.push([parent, k, val])
  }
}

function decirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)
        return
      }
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options)
      }
    } else {
      var keys = Object.keys(val)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        decirc(val[key], key, i, stack, val, depth, options)
      }
    }
    stack.pop()
  }
}

// Stable-stringify
function compareFunction (a, b) {
  if (a < b) {
    return -1
  }
  if (a > b) {
    return 1
  }
  return 0
}

function deterministicStringify (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions()
  }

  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer)
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    // Ensure that we restore the object as it was.
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}

function deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)
        return
      }
    }
    try {
      if (typeof val.toJSON === 'function') {
        return
      }
    } catch (_) {
      return
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options)
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {}
      var keys = Object.keys(val).sort(compareFunction)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        deterministicDecirc(val[key], key, i, stack, val, depth, options)
        tmp[key] = val[key]
      }
      if (typeof parent !== 'undefined') {
        arr.push([parent, k, val])
        parent[k] = tmp
      } else {
        return tmp
      }
    }
    stack.pop()
  }
}

// wraps replacer function to handle values we couldn't replace
// and mark them as replaced value
function replaceGetterValues (replacer) {
  replacer =
    typeof replacer !== 'undefined'
      ? replacer
      : function (k, v) {
        return v
      }
  return function (key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i]
        if (part[1] === key && part[0] === val) {
          val = part[2]
          replacerStack.splice(i, 1)
          break
        }
      }
    }
    return replacer.call(this, key, val)
  }
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/is-stream/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-stream/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


const isStream = stream =>
	stream !== null &&
	typeof stream === 'object' &&
	typeof stream.pipe === 'function';

isStream.writable = stream =>
	isStream(stream) &&
	stream.writable !== false &&
	typeof stream._write === 'function' &&
	typeof stream._writableState === 'object';

isStream.readable = stream =>
	isStream(stream) &&
	stream.readable !== false &&
	typeof stream._read === 'function' &&
	typeof stream._readableState === 'object';

isStream.duplex = stream =>
	isStream.writable(stream) &&
	isStream.readable(stream);

isStream.transform = stream =>
	isStream.duplex(stream) &&
	typeof stream._transform === 'function';

module.exports = isStream;


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/once/once.js":
/*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(/*! wrappy */ "./node_modules/wrappy/wrappy.js")
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ "./node_modules/pony-cause/index.js":
/*!******************************************!*\
  !*** ./node_modules/pony-cause/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ErrorWithCause } = __webpack_require__(/*! ./lib/error-with-cause */ "./node_modules/pony-cause/lib/error-with-cause.js"); // linemod-replace-with: export { ErrorWithCause } from './lib/error-with-cause.mjs';

const { // linemod-replace-with: export {
  findCauseByReference,
  getErrorCause,
  messageWithCauses,
  stackWithCauses,
} = __webpack_require__(/*! ./lib/helpers */ "./node_modules/pony-cause/lib/helpers.js"); // linemod-replace-with: } from './lib/helpers.mjs';

module.exports = {      // linemod-remove
  ErrorWithCause,       // linemod-remove
  findCauseByReference, // linemod-remove
  getErrorCause,        // linemod-remove
  stackWithCauses,      // linemod-remove
  messageWithCauses,    // linemod-remove
};                      // linemod-remove


/***/ }),

/***/ "./node_modules/pony-cause/lib/error-with-cause.js":
/*!*********************************************************!*\
  !*** ./node_modules/pony-cause/lib/error-with-cause.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/** @template [T=undefined] */
class ErrorWithCause extends Error { // linemod-prefix-with: export
  /**
   * @param {string} message
   * @param {{ cause?: T }} options
   */
  constructor (message, { cause } = {}) {
    super(message);

    /** @type {string} */
    this.name = ErrorWithCause.name;
    if (cause) {
      /** @type {T} */
      this.cause = cause;
    }
    /** @type {string} */
    this.message = message;
  }
}

module.exports = {      // linemod-remove
  ErrorWithCause,       // linemod-remove
};                      // linemod-remove


/***/ }),

/***/ "./node_modules/pony-cause/lib/helpers.js":
/*!************************************************!*\
  !*** ./node_modules/pony-cause/lib/helpers.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


/**
 * @template {Error} T
 * @param {unknown} err
 * @param {new(...args: any[]) => T} reference
 * @returns {T|undefined}
 */
const findCauseByReference = (err, reference) => { // linemod-prefix-with: export
  if (!err || !reference) return;
  if (!(err instanceof Error)) return;
  if (
    !(reference.prototype instanceof Error) &&
    // @ts-ignore
    reference !== Error
  ) return;

  /**
   * Ensures we don't go circular
   *
   * @type {Set<Error>}
   */
  const seen = new Set();

  /** @type {Error|undefined} */
  let currentErr = err;

  while (currentErr && !seen.has(currentErr)) {
    seen.add(currentErr);

    if (currentErr instanceof reference) {
      return currentErr;
    }

    currentErr = getErrorCause(currentErr);
  }
};

/**
 * @param {Error|{ cause?: unknown|(()=>err)}} err
 * @returns {Error|undefined}
 */
const getErrorCause = (err) => { // linemod-prefix-with: export
  if (!err || typeof err !== 'object' || !('cause' in err)) {
    return;
  }

  // VError / NError style causes
  if (typeof err.cause === 'function') {
    const causeResult = err.cause();

    return causeResult instanceof Error
      ? causeResult
      : undefined;
  } else {
    return err.cause instanceof Error
      ? err.cause
      : undefined;
  }
};

/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @returns {string}
 */
const _stackWithCauses = (err, seen) => {
  if (!(err instanceof Error)) return '';

  const stack = err.stack || '';

  // Ensure we don't go circular or crazily deep
  if (seen.has(err)) {
    return stack + '\ncauses have become circular...';
  }

  const cause = getErrorCause(err);

  // TODO: Follow up in https://github.com/nodejs/node/issues/38725#issuecomment-920309092 on how to log stuff

  if (cause) {
    seen.add(err);
    return (stack + '\ncaused by: ' + _stackWithCauses(cause, seen));
  } else {
    return stack;
  }
};

/**
 * @param {Error} err
 * @returns {string}
 */
const stackWithCauses = (err) => _stackWithCauses(err, new Set()); // linemod-prefix-with: export

/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @param {boolean} [skip]
 * @returns {string}
 */
const _messageWithCauses = (err, seen, skip) => {
  if (!(err instanceof Error)) return '';

  const message = skip ? '' : (err.message || '');

  // Ensure we don't go circular or crazily deep
  if (seen.has(err)) {
    return message + ': ...';
  }

  const cause = getErrorCause(err);

  if (cause) {
    seen.add(err);

    const skipIfVErrorStyleCause = 'cause' in err && typeof err.cause === 'function';

    return (message +
      (skipIfVErrorStyleCause ? '' : ': ') +
      _messageWithCauses(cause, seen, skipIfVErrorStyleCause));
  } else {
    return message;
  }
};

/**
 * @param {Error} err
 * @returns {string}
 */
const messageWithCauses = (err) => _messageWithCauses(err, new Set()); // linemod-prefix-with: export

module.exports = {      // linemod-remove
  findCauseByReference, // linemod-remove
  getErrorCause,        // linemod-remove
  stackWithCauses,      // linemod-remove
  messageWithCauses,    // linemod-remove
};                      // linemod-remove


/***/ }),

/***/ "./node_modules/readable-stream/errors-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/errors-browser.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");
__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;
var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");
__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

var Buffer = (__webpack_require__(/*! buffer */ "../../node_modules/buffer/index.js").Buffer);
var OurUint8Array = (typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ "?d17e");
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ "./node_modules/readable-stream/lib/internal/streams/buffer_list.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");
var _require = __webpack_require__(/*! ./internal/streams/state */ "./node_modules/readable-stream/lib/internal/streams/state.js"),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ "./node_modules/readable-stream/lib/internal/streams/async_iterator.js");
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(/*! ./internal/streams/from */ "./node_modules/readable-stream/lib/internal/streams/from-browser.js");
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;
var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

var Buffer = (__webpack_require__(/*! buffer */ "../../node_modules/buffer/index.js").Buffer);
var OurUint8Array = (typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");
var _require = __webpack_require__(/*! ./internal/streams/state */ "./node_modules/readable-stream/lib/internal/streams/state.js"),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var finished = __webpack_require__(/*! ./end-of-stream */ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!**************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(/*! buffer */ "../../node_modules/buffer/index.js"),
  Buffer = _require.Buffer;
var _require2 = __webpack_require__(/*! util */ "?ed1b"),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).



var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ "./node_modules/readable-stream/errors-browser.js").codes).ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};


/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).



var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = (__webpack_require__(/*! ../../../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/state.js":
/*!********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/state.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ "./node_modules/readable-stream/errors-browser.js").codes).ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;


/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");
exports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
exports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ "./node_modules/readable-stream/lib/internal/streams/pipeline.js");


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "../../node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/semver/classes/comparator.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/classes/comparator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    comp = comp.trim().split(/\s+/).join(' ')
    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    options = parseOptions(options)

    // Special cases where nothing can possibly be lower
    if (options.includePrerelease &&
      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
      return false
    }
    if (!options.includePrerelease &&
      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
      return false
    }

    // Same direction increasing (> or >=)
    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
      return true
    }
    // Same direction decreasing (< or <=)
    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
      return true
    }
    // same SemVer and both sides are inclusive (<= or >=)
    if (
      (this.semver.version === comp.semver.version) &&
      this.operator.includes('=') && comp.operator.includes('=')) {
      return true
    }
    // opposite directions less than
    if (cmp(this.semver, '<', comp.semver, options) &&
      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
      return true
    }
    // opposite directions greater than
    if (cmp(this.semver, '>', comp.semver, options) &&
      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
      return true
    }
    return false
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")
const cmp = __webpack_require__(/*! ../functions/cmp */ "./node_modules/semver/functions/cmp.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ./range */ "./node_modules/semver/classes/range.js")


/***/ }),

/***/ "./node_modules/semver/classes/range.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/classes/range.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First reduce all whitespace as much as possible so we do not have to rely
    // on potentially slow regexes like \s*. This is then stored and used for
    // future error messages as well.
    this.raw = range
      .trim()
      .split(/\s+/)
      .join(' ')

    // First, split on ||
    this.set = this.raw
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => comps.join(' ').trim())
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts =
      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
      (this.options.loose && FLAG_LOOSE)
    const memoKey = memoOpts + ':' + range
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)

    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)
    debug('tilde trim', range)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)
    debug('caret trim', range)

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}

module.exports = Range

const LRU = __webpack_require__(/*! lru-cache */ "./node_modules/semver/node_modules/lru-cache/index.js")
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const Comparator = __webpack_require__(/*! ./comparator */ "./node_modules/semver/classes/comparator.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js")
const {
  safeRe: re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js")

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceTilde(c, options))
    .join(' ')
}

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceCaret(c, options))
    .join(' ')
}

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp
    .split(/\s+/)
    .map((c) => replaceXRange(c, options))
    .join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp
    .trim()
    .replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp
    .trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return `${from} ${to}`.trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ "./node_modules/semver/classes/semver.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/classes/semver.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js")
const { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ "./node_modules/semver/internal/identifiers.js")
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier, identifierBase)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier, identifierBase)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier, identifierBase)
        this.inc('pre', identifier, identifierBase)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase)
        }
        this.inc('pre', identifier, identifierBase)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0

        if (!identifier && identifierBase === false) {
          throw new Error('invalid increment argument: identifier is empty')
        }

        if (this.prerelease.length === 0) {
          this.prerelease = [base]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base]
          if (identifierBase === false) {
            prerelease = [identifier]
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease
            }
          } else {
            this.prerelease = prerelease
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.raw = this.format()
    if (this.build.length) {
      this.raw += `+${this.build.join('.')}`
    }
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ "./node_modules/semver/functions/clean.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/clean.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ "./node_modules/semver/functions/cmp.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/cmp.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./neq */ "./node_modules/semver/functions/neq.js")
const gt = __webpack_require__(/*! ./gt */ "./node_modules/semver/functions/gt.js")
const gte = __webpack_require__(/*! ./gte */ "./node_modules/semver/functions/gte.js")
const lt = __webpack_require__(/*! ./lt */ "./node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ./lte */ "./node_modules/semver/functions/lte.js")

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ "./node_modules/semver/functions/coerce.js":
/*!*************************************************!*\
  !*** ./node_modules/semver/functions/coerce.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),

/***/ "./node_modules/semver/functions/compare-build.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-build.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ "./node_modules/semver/functions/compare-loose.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-loose.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ "./node_modules/semver/functions/compare.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/functions/compare.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ "./node_modules/semver/functions/diff.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/diff.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse.js */ "./node_modules/semver/functions/parse.js")

const diff = (version1, version2) => {
  const v1 = parse(version1, null, true)
  const v2 = parse(version2, null, true)
  const comparison = v1.compare(v2)

  if (comparison === 0) {
    return null
  }

  const v1Higher = comparison > 0
  const highVersion = v1Higher ? v1 : v2
  const lowVersion = v1Higher ? v2 : v1
  const highHasPre = !!highVersion.prerelease.length
  const lowHasPre = !!lowVersion.prerelease.length

  if (lowHasPre && !highHasPre) {
    // Going from prerelease -> no prerelease requires some special casing

    // If the low version has only a major, then it will always be a major
    // Some examples:
    // 1.0.0-1 -> 1.0.0
    // 1.0.0-1 -> 1.1.1
    // 1.0.0-1 -> 2.0.0
    if (!lowVersion.patch && !lowVersion.minor) {
      return 'major'
    }

    // Otherwise it can be determined by checking the high version

    if (highVersion.patch) {
      // anything higher than a patch bump would result in the wrong version
      return 'patch'
    }

    if (highVersion.minor) {
      // anything higher than a minor bump would result in the wrong version
      return 'minor'
    }

    // bumping major/minor/patch all have same result
    return 'major'
  }

  // add the `pre` prefix if we are going to a prerelease version
  const prefix = highHasPre ? 'pre' : ''

  if (v1.major !== v2.major) {
    return prefix + 'major'
  }

  if (v1.minor !== v2.minor) {
    return prefix + 'minor'
  }

  if (v1.patch !== v2.patch) {
    return prefix + 'patch'
  }

  // high and low are preleases
  return 'prerelease'
}

module.exports = diff


/***/ }),

/***/ "./node_modules/semver/functions/eq.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/eq.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ "./node_modules/semver/functions/gt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/gt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ "./node_modules/semver/functions/gte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/gte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ "./node_modules/semver/functions/inc.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/inc.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")

const inc = (version, release, options, identifier, identifierBase) => {
  if (typeof (options) === 'string') {
    identifierBase = identifier
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(
      version instanceof SemVer ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ "./node_modules/semver/functions/lt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/lt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ "./node_modules/semver/functions/lte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/lte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ "./node_modules/semver/functions/major.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/major.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ "./node_modules/semver/functions/minor.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/minor.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ "./node_modules/semver/functions/neq.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/neq.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ "./node_modules/semver/functions/parse.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/parse.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const parse = (version, options, throwErrors = false) => {
  if (version instanceof SemVer) {
    return version
  }
  try {
    return new SemVer(version, options)
  } catch (er) {
    if (!throwErrors) {
      return null
    }
    throw er
  }
}

module.exports = parse


/***/ }),

/***/ "./node_modules/semver/functions/patch.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/patch.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ "./node_modules/semver/functions/prerelease.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/functions/prerelease.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ "./node_modules/semver/functions/rcompare.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/functions/rcompare.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ "./node_modules/semver/functions/rsort.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/rsort.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js")
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ "./node_modules/semver/functions/satisfies.js":
/*!****************************************************!*\
  !*** ./node_modules/semver/functions/satisfies.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ "./node_modules/semver/functions/sort.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/sort.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js")
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ "./node_modules/semver/functions/valid.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/valid.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ "./node_modules/semver/index.js":
/*!**************************************!*\
  !*** ./node_modules/semver/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(/*! ./internal/re */ "./node_modules/semver/internal/re.js")
const constants = __webpack_require__(/*! ./internal/constants */ "./node_modules/semver/internal/constants.js")
const SemVer = __webpack_require__(/*! ./classes/semver */ "./node_modules/semver/classes/semver.js")
const identifiers = __webpack_require__(/*! ./internal/identifiers */ "./node_modules/semver/internal/identifiers.js")
const parse = __webpack_require__(/*! ./functions/parse */ "./node_modules/semver/functions/parse.js")
const valid = __webpack_require__(/*! ./functions/valid */ "./node_modules/semver/functions/valid.js")
const clean = __webpack_require__(/*! ./functions/clean */ "./node_modules/semver/functions/clean.js")
const inc = __webpack_require__(/*! ./functions/inc */ "./node_modules/semver/functions/inc.js")
const diff = __webpack_require__(/*! ./functions/diff */ "./node_modules/semver/functions/diff.js")
const major = __webpack_require__(/*! ./functions/major */ "./node_modules/semver/functions/major.js")
const minor = __webpack_require__(/*! ./functions/minor */ "./node_modules/semver/functions/minor.js")
const patch = __webpack_require__(/*! ./functions/patch */ "./node_modules/semver/functions/patch.js")
const prerelease = __webpack_require__(/*! ./functions/prerelease */ "./node_modules/semver/functions/prerelease.js")
const compare = __webpack_require__(/*! ./functions/compare */ "./node_modules/semver/functions/compare.js")
const rcompare = __webpack_require__(/*! ./functions/rcompare */ "./node_modules/semver/functions/rcompare.js")
const compareLoose = __webpack_require__(/*! ./functions/compare-loose */ "./node_modules/semver/functions/compare-loose.js")
const compareBuild = __webpack_require__(/*! ./functions/compare-build */ "./node_modules/semver/functions/compare-build.js")
const sort = __webpack_require__(/*! ./functions/sort */ "./node_modules/semver/functions/sort.js")
const rsort = __webpack_require__(/*! ./functions/rsort */ "./node_modules/semver/functions/rsort.js")
const gt = __webpack_require__(/*! ./functions/gt */ "./node_modules/semver/functions/gt.js")
const lt = __webpack_require__(/*! ./functions/lt */ "./node_modules/semver/functions/lt.js")
const eq = __webpack_require__(/*! ./functions/eq */ "./node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./functions/neq */ "./node_modules/semver/functions/neq.js")
const gte = __webpack_require__(/*! ./functions/gte */ "./node_modules/semver/functions/gte.js")
const lte = __webpack_require__(/*! ./functions/lte */ "./node_modules/semver/functions/lte.js")
const cmp = __webpack_require__(/*! ./functions/cmp */ "./node_modules/semver/functions/cmp.js")
const coerce = __webpack_require__(/*! ./functions/coerce */ "./node_modules/semver/functions/coerce.js")
const Comparator = __webpack_require__(/*! ./classes/comparator */ "./node_modules/semver/classes/comparator.js")
const Range = __webpack_require__(/*! ./classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = __webpack_require__(/*! ./functions/satisfies */ "./node_modules/semver/functions/satisfies.js")
const toComparators = __webpack_require__(/*! ./ranges/to-comparators */ "./node_modules/semver/ranges/to-comparators.js")
const maxSatisfying = __webpack_require__(/*! ./ranges/max-satisfying */ "./node_modules/semver/ranges/max-satisfying.js")
const minSatisfying = __webpack_require__(/*! ./ranges/min-satisfying */ "./node_modules/semver/ranges/min-satisfying.js")
const minVersion = __webpack_require__(/*! ./ranges/min-version */ "./node_modules/semver/ranges/min-version.js")
const validRange = __webpack_require__(/*! ./ranges/valid */ "./node_modules/semver/ranges/valid.js")
const outside = __webpack_require__(/*! ./ranges/outside */ "./node_modules/semver/ranges/outside.js")
const gtr = __webpack_require__(/*! ./ranges/gtr */ "./node_modules/semver/ranges/gtr.js")
const ltr = __webpack_require__(/*! ./ranges/ltr */ "./node_modules/semver/ranges/ltr.js")
const intersects = __webpack_require__(/*! ./ranges/intersects */ "./node_modules/semver/ranges/intersects.js")
const simplifyRange = __webpack_require__(/*! ./ranges/simplify */ "./node_modules/semver/ranges/simplify.js")
const subset = __webpack_require__(/*! ./ranges/subset */ "./node_modules/semver/ranges/subset.js")
module.exports = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
}


/***/ }),

/***/ "./node_modules/semver/internal/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/internal/constants.js ***!
  \***************************************************/
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
]

module.exports = {
  MAX_LENGTH,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
}


/***/ }),

/***/ "./node_modules/semver/internal/debug.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/internal/debug.js ***!
  \***********************************************/
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ "./node_modules/semver/internal/identifiers.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/internal/identifiers.js ***!
  \*****************************************************/
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}


/***/ }),

/***/ "./node_modules/semver/internal/parse-options.js":
/*!*******************************************************!*\
  !*** ./node_modules/semver/internal/parse-options.js ***!
  \*******************************************************/
/***/ ((module) => {

// parse out just the options we care about
const looseOption = Object.freeze({ loose: true })
const emptyOpts = Object.freeze({ })
const parseOptions = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
}
module.exports = parseOptions


/***/ }),

/***/ "./node_modules/semver/internal/re.js":
/*!********************************************!*\
  !*** ./node_modules/semver/internal/re.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

const {
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_LENGTH,
} = __webpack_require__(/*! ./constants */ "./node_modules/semver/internal/constants.js")
const debug = __webpack_require__(/*! ./debug */ "./node_modules/semver/internal/debug.js")
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const safeRe = exports.safeRe = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const LETTERDASHNUMBER = '[a-zA-Z0-9-]'

// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
  ['\\s', 1],
  ['\\d', MAX_LENGTH],
  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
]

const makeSafeRegex = (value) => {
  for (const [token, max] of safeRegexReplacements) {
    value = value
      .split(`${token}*`).join(`${token}{0,${max}}`)
      .split(`${token}+`).join(`${token}{1,${max}}`)
  }
  return value
}

const createToken = (name, value, isGlobal) => {
  const safe = makeSafeRegex(value)
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '\\d+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')


/***/ }),

/***/ "./node_modules/semver/node_modules/lru-cache/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/semver/node_modules/lru-cache/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(/*! yallist */ "./node_modules/semver/node_modules/yallist/yallist.js")

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache


/***/ }),

/***/ "./node_modules/semver/node_modules/yallist/iterator.js":
/*!**************************************************************!*\
  !*** ./node_modules/semver/node_modules/yallist/iterator.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),

/***/ "./node_modules/semver/node_modules/yallist/yallist.js":
/*!*************************************************************!*\
  !*** ./node_modules/semver/node_modules/yallist/yallist.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(/*! ./iterator.js */ "./node_modules/semver/node_modules/yallist/iterator.js")(Yallist)
} catch (er) {}


/***/ }),

/***/ "./node_modules/semver/ranges/gtr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/gtr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js")
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ "./node_modules/semver/ranges/intersects.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/ranges/intersects.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2, options)
}
module.exports = intersects


/***/ }),

/***/ "./node_modules/semver/ranges/ltr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/ltr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js")
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ "./node_modules/semver/ranges/max-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/max-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/min-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-version.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/ranges/min-version.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js")

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ "./node_modules/semver/ranges/outside.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/ranges/outside.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Comparator = __webpack_require__(/*! ../classes/comparator */ "./node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = __webpack_require__(/*! ../functions/satisfies */ "./node_modules/semver/functions/satisfies.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js")
const lt = __webpack_require__(/*! ../functions/lt */ "./node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ../functions/lte */ "./node_modules/semver/functions/lte.js")
const gte = __webpack_require__(/*! ../functions/gte */ "./node_modules/semver/functions/gte.js")

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ "./node_modules/semver/ranges/simplify.js":
/*!************************************************!*\
  !*** ./node_modules/semver/ranges/simplify.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js")
module.exports = (versions, range, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!first) {
        first = version
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }

  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push('*')
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ "./node_modules/semver/ranges/subset.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/ranges/subset.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range.js */ "./node_modules/semver/classes/range.js")
const Comparator = __webpack_require__(/*! ../classes/comparator.js */ "./node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js")

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
}

const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]
const minimumVersion = [new Comparator('>=0.0.0')]

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease
    } else {
      sub = minimumVersion
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = minimumVersion
    }
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options)
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ "./node_modules/semver/ranges/to-comparators.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/to-comparators.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ "./node_modules/semver/ranges/valid.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/ranges/valid.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}


/***/ }),

/***/ "./node_modules/wrappy/wrappy.js":
/*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ "../../node_modules/@noble/curves/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ../../node_modules/@noble/curves/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createCurve = exports.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ "../../node_modules/@noble/hashes/hmac.js");
const utils_1 = __webpack_require__(/*! @noble/hashes/utils */ "../../node_modules/@noble/hashes/utils.js");
const weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "../../node_modules/@noble/curves/abstract/weierstrass.js");
// connects noble-curves to noble-hashes
function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes,
    };
}
exports.getHash = getHash;
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
    return Object.freeze({ ...create(defHash), create });
}
exports.createCurve = createCurve;


/***/ }),

/***/ "../../node_modules/@noble/curves/abstract/curve.js":
/*!**********************************************************!*\
  !*** ../../node_modules/@noble/curves/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateBasic = exports.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Abelian group utilities
const modular_js_1 = __webpack_require__(/*! ./modular.js */ "../../node_modules/@noble/curves/abstract/modular.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/@noble/curves/abstract/utils.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
    };
    const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1; // +1, because
        const windowSize = 2 ** (W - 1); // -1 because we skip zero
        return { windows, windowSize };
    };
    return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                // =1, because we skip zero
                for (let i = 1; i < windowSize; i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                // Extract W bits.
                let wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) {
                    // The most important part for const-time getPublicKey
                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                }
                else {
                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
            // @ts-ignore
            const W = P._WINDOW_SIZE || 1;
            // Calculate precomputes on a first run, reuse them after
            let comp = precomputesMap.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                    precomputesMap.set(P, transform(comp));
                }
            }
            return this.wNAF(W, comp, n);
        },
    };
}
exports.wNAF = wNAF;
function validateBasic(curve) {
    (0, modular_js_1.validateField)(curve.Fp);
    (0, utils_js_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
exports.validateBasic = validateBasic;


/***/ }),

/***/ "../../node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
const modular_js_1 = __webpack_require__(/*! ./modular.js */ "../../node_modules/@noble/curves/abstract/modular.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/@noble/curves/abstract/utils.js");
function validateDST(dst) {
    if (dst instanceof Uint8Array)
        return dst;
    if (typeof dst === 'string')
        return (0, utils_js_1.utf8ToBytes)(dst);
    throw new Error('DST must be Uint8Array or string');
}
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_js_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    if (value < 0 || value >= 1 << (8 * length)) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    }
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function isBytes(item) {
    if (!(item instanceof Uint8Array))
        throw new Error('Uint8Array expected');
}
function isNum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
function expand_message_xmd(msg, DST, lenInBytes, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255)
        throw new Error('Invalid xmd length');
    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
exports.expand_message_xmd = expand_message_xmd;
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
exports.expand_message_xof = expand_message_xof;
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_js_1.validateObject)(options, {
        DST: 'stringOrUint8Array',
        p: 'bigint',
        m: 'isSafeInteger',
        k: 'isSafeInteger',
        hash: 'hash',
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    isBytes(msg);
    isNum(count);
    const DST = validateDST(_DST);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
exports.hash_to_field = hash_to_field;
function isogenyMap(field, map) {
    // Make same order as in spec
    const COEFF = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return { x, y };
    };
}
exports.isogenyMap = isogenyMap;
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        },
    };
}
exports.createHasher = createHasher;


/***/ }),

/***/ "../../node_modules/@noble/curves/abstract/modular.js":
/*!************************************************************!*\
  !*** ../../node_modules/@noble/curves/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Utilities for modular arithmetics and finite fields
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/@noble/curves/abstract/utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
const _9n = BigInt(9), _16n = BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
exports.mod = mod;
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
// TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n)
        throw new Error('Expected power/modulo > 0');
    if (modulo === _1n)
        return _0n;
    let res = _1n;
    while (power > _0n) {
        if (power & _1n)
            res = (res * num) % modulo;
        num = (num * num) % modulo;
        power >>= _1n;
    }
    return res;
}
exports.pow = pow;
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
exports.pow2 = pow2;
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
exports.invert = invert;
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p) ≡ 1    if a is a square (mod p)
    // (a | p) ≡ -1   if a is not a square (mod p)
    // (a | p) ≡ 0    if a ≡ 0 (mod p)
    const legendreC = (P - _1n) / _2n;
    let Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq
    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
    // Fast-path
    if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Slow-path
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error('Cannot find square root');
        let r = S;
        // TODO: will fail at Fp2/etc
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        let x = Fp.pow(n, Q1div2); // first guess at the square root
        let b = Fp.pow(n, Q); // first guess at the fudge factor
        while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
                if (Fp.eql(t2, Fp.ONE))
                    break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
exports.tonelliShanks = tonelliShanks;
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P ≡ 3 (mod 4)
    // √n = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // P ≡ 9 (mod 16)
    if (P % _16n === _9n) {
        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start
        // Means we cannot use sqrt for constants at all!
        //
        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic
        // sqrt = (x) => {
        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4
        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1
        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1
        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1
        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x
        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x
        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x
        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2
        // }
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
exports.FpSqrt = FpSqrt;
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    return (0, utils_js_1.validateObject)(field, opts);
}
exports.validateField = validateField;
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n)
        throw new Error('Expected power > 0');
    if (power === _0n)
        return f.ONE;
    if (power === _1n)
        return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
exports.FpPow = FpPow;
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */
function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    const inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
exports.FpInvertBatch = FpInvertBatch;
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
}
exports.FpDiv = FpDiv;
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
    return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
exports.FpIsSquare = FpIsSquare;
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
exports.nLength = nLength;
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048)
        throw new Error('Field lengths over 2048 bytes are not supported');
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => (c ? b : a),
        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        },
    });
    return Object.freeze(f);
}
exports.Field = Field;
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
exports.FpSqrtOdd = FpSqrtOdd;
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
exports.FpSqrtEven = FpSqrtEven;
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
exports.hashToPrivateScalar = hashToPrivateScalar;
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
exports.getFieldBytesLength = getFieldBytesLength;
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
exports.getMinHashLength = getMinHashLength;
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
}
exports.mapHashToField = mapHashToField;


/***/ }),

/***/ "../../node_modules/@noble/curves/abstract/utils.js":
/*!**********************************************************!*\
  !*** ../../node_modules/@noble/curves/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const u8a = (a) => a instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
exports.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : `0x${hex}`);
}
exports.hexToNumber = hexToNumber;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
exports.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
exports.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
exports.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
exports.numberToBytesLE = numberToBytesLE;
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
exports.numberToVarBytesBE = numberToVarBytesBE;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        }
        catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
    }
    else if (u8a(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
exports.ensureBytes = ensureBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
exports.concatBytes = concatBytes;
function equalBytes(b1, b2) {
    // We don't care about timing attacks here
    if (b1.length !== b2.length)
        return false;
    for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
            return false;
    return true;
}
exports.equalBytes = equalBytes;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
exports.bitLen = bitLen;
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
exports.bitGet = bitGet;
/**
 * Sets single bit at position.
 */
const bitSet = (n, pos, value) => {
    return n | ((value ? _1n : _0n) << BigInt(pos));
};
exports.bitSet = bitSet;
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
exports.bitMask = bitMask;
// DRBG
const u8n = (data) => new Uint8Array(data); // creates Uint8Array
const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n()) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
exports.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
exports.validateObject = validateObject;
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });


/***/ }),

/***/ "../../node_modules/@noble/curves/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@noble/curves/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Short Weierstrass curve. The formula is: y² = x³ + ax + b
const mod = __webpack_require__(/*! ./modular.js */ "../../node_modules/@noble/curves/abstract/modular.js");
const ut = __webpack_require__(/*! ./utils.js */ "../../node_modules/@noble/curves/abstract/utils.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/@noble/curves/abstract/utils.js");
const curve_js_1 = __webpack_require__(/*! ./curve.js */ "../../node_modules/@noble/curves/abstract/curve.js");
function validatePointOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        a: 'field',
        b: 'field',
    }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function',
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (typeof endo !== 'object' ||
            typeof endo.beta !== 'bigint' ||
            typeof endo.splitScalar !== 'function') {
            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
    }
    return Object.freeze({ ...opts });
}
// ASN.1 DER encoding utilities
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
exports.DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
        constructor(m = '') {
            super(m);
        }
    },
    _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 0x02)
            throw new E('Invalid signature integer tag');
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
            throw new E('Invalid signature integer: wrong length');
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 0b10000000)
            throw new E('Invalid signature integer: negative');
        if (res[0] === 0x00 && !(res[1] & 0b10000000))
            throw new E('Invalid signature integer: unnecessary leading zero');
        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E } = exports.DER;
        const data = typeof hex === 'string' ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
            throw new Error('ui8a expected');
        let l = data.length;
        if (l < 2 || data[0] != 0x30)
            throw new E('Invalid signature tag');
        if (data[1] !== l - 2)
            throw new E('Invalid signature: incorrect length');
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
            throw new E('Invalid signature: left bytes after parsing');
        return { r, s };
    },
    hexFromSig(sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);
        const h = (num) => {
            const hex = num.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const toBytes = CURVE.toBytes ||
        ((_c, point, _isCompressed) => {
            const a = point.toAffine();
            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
        });
    const fromBytes = CURVE.fromBytes ||
        ((bytes) => {
            // const head = bytes[0];
            const tail = bytes.subarray(1);
            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
        });
    /**
     * y² = x³ + ax + b: Short weierstrass curve formula
     * @returns y²
     */
    function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error('bad generator point: equation left != right');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num))
            throw new Error('Expected valid bigint: 0 < bigint < curve.n');
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== 'bigint') {
            if (key instanceof Uint8Array)
                key = ut.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length))
                throw new Error('Invalid key');
            key = key.padStart(nByteLength * 2, '0');
        }
        let num;
        try {
            num =
                typeof key === 'bigint'
                    ? key
                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));
        }
        catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
            num = mod.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    const pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        constructor(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px))
                throw new Error('x required');
            if (py == null || !Fp.isValid(py))
                throw new Error('y required');
            if (pz == null || !Fp.isValid(pz))
                throw new Error('z required');
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            const is0 = (i) => Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.pz));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                    return;
                throw new Error('bad point: ZERO');
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            const { x, y } = this.toAffine();
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('bad point: x or y not FE');
            const left = Fp.sqr(y); // y²
            const right = weierstrassEquation(x); // x³ + ax + b
            if (!Fp.eql(left, right))
                throw new Error('bad point: equation left != right');
            if (!this.isTorsionFree())
                throw new Error('bad point: not in prime-order subgroup');
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd)
                return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
                const toInv = Fp.invertBatch(comp.map((p) => p.pz));
                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
            });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
            const I = Point.ZERO;
            if (n === _0n)
                return I;
            assertGE(n); // Will throw on 0
            if (n === _1n)
                return this;
            const { endo } = CURVE;
            if (!endo)
                return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
                if (k1 & _1n)
                    k1p = k1p.add(d);
                if (k2 & _1n)
                    k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake; // Fake point is used to const-time mult
            const { endo } = CURVE;
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            }
            else {
                const { p, f } = this.wNAF(n);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
            const { px: x, py: y, pz: z } = this;
            const is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null)
                iz = is0 ? Fp.ONE : Fp.inv(z);
            const ax = Fp.mul(x, iz);
            const ay = Fp.mul(y, iz);
            const zz = Fp.mul(z, iz);
            if (is0)
                return { x: Fp.ZERO, y: Fp.ZERO };
            if (!Fp.eql(zz, Fp.ONE))
                throw new Error('invZ was invalid');
            return { x: ax, y: ay };
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n)
                return true; // No subgroups, always torsion-free
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder,
    };
}
exports.weierstrassPoints = weierstrassPoints;
function validateOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function',
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean',
    });
    return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return mod.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = ut.concatBytes;
            if (isCompressed) {
                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
            }
            else {
                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
            }
        },
        fromBytes(bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = ut.bytesToNumberBE(tail);
                if (!isValidFieldElement(x))
                    throw new Error('Point is not on curve');
                const y2 = weierstrassEquation(x); // y² = x³ + ax + b
                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4
                const isYOdd = (y & _1n) === _1n;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd)
                    y = Fp.neg(y);
                return { x, y };
            }
            else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return { x, y };
            }
            else {
                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
        },
    });
    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));
            return new Signature(r, s);
        }
        assertValidity() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r))
                throw new Error('r must be 0 < r < CURVE.n');
            if (!isWithinCurveOrder(this.s))
                throw new Error('s must be 0 < s < CURVE.n');
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER)
                throw new Error('recovery id 2 or 3 invalid');
            const prefix = (rec & 1) === 0 ? '02' : '03';
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q)
                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
            const length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        },
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === 'string';
        const len = (arr || str) && item.length;
        if (arr)
            return len === compressedLen || len === uncompressedLen;
        if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
            return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
            throw new Error('first arg must be private key');
        if (!isProbPub(publicB))
            throw new Error('second arg must be public key');
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int ||
        function (bytes) {
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = CURVE.bits2int_modN ||
        function (bytes) {
            return modN(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */
    function int2octets(num) {
        if (typeof num !== 'bigint')
            throw new Error('bigint expected');
        if (!(_0n <= num && num < ORDER_MASK))
            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null)
            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        if (prehash)
            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k))
                return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G × k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */
    function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1⋅G - U2⋅P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const { lowS, prehash } = opts;
        let _sig = undefined;
        let P;
        try {
            if (typeof sg === 'string' || sg instanceof Uint8Array) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    _sig = Signature.fromDER(sg);
                }
                catch (derError) {
                    if (!(derError instanceof exports.DER.Err))
                        throw derError;
                    _sig = Signature.fromCompact(sg);
                }
            }
            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                const { r, s } = sg;
                _sig = new Signature(r, s);
            }
            else {
                throw new Error('PARSE');
            }
            P = Point.fromHex(publicKey);
        }
        catch (error) {
            if (error.message === 'PARSE')
                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
        }
        if (lowS && _sig.hasHighS())
            return false;
        if (prehash)
            msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P
        if (!R)
            return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils,
    };
}
exports.weierstrass = weierstrass;
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd)
        throw new Error('Fp.isOdd is not implemented!');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return { x, y };
    };
}
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;


/***/ }),

/***/ "../../node_modules/@noble/curves/secp256k1.js":
/*!*****************************************************!*\
  !*** ../../node_modules/@noble/curves/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ "../../node_modules/@noble/hashes/sha256.js");
const utils_1 = __webpack_require__(/*! @noble/hashes/utils */ "../../node_modules/@noble/hashes/utils.js");
const modular_js_1 = __webpack_require__(/*! ./abstract/modular.js */ "../../node_modules/@noble/curves/abstract/modular.js");
const weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "../../node_modules/@noble/curves/abstract/weierstrass.js");
const utils_js_1 = __webpack_require__(/*! ./abstract/utils.js */ "../../node_modules/@noble/curves/abstract/utils.js");
const hash_to_curve_js_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ "../../node_modules/@noble/curves/abstract/hash-to-curve.js");
const _shortw_utils_js_1 = __webpack_require__(/*! ./_shortw_utils.js */ "../../node_modules/@noble/curves/_shortw_utils.js");
const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b) => (a + b / _2n) / b;
/**
 * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    const P = secp256k1P;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = (y * y * y) % P; // x^3, 11
    const b3 = (b2 * b2 * y) % P; // x^7
    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;
    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;
    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;
    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;
    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;
    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;
    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;
    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;
    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;
    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;
    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;
    const root = (0, modular_js_1.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
const Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: (k) => {
            const n = secp256k1N;
            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
            const b2 = a1;
            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg)
                k1 = n - k1;
            if (k2neg)
                k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
                throw new Error('splitScalar: Endomorphism failed, k=' + k);
            }
            return { k1neg, k1, k2neg, k2 };
        },
    },
}, sha256_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
const _0n = BigInt(0);
const fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;
const ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point) => point.toRawBytes(true).slice(1);
const numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
const modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
const modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
const Point = exports.secp256k1.ProjectivePoint;
const GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside
    const scalar = p.hasEvenY() ? d_ : modN(-d_);
    return { scalar: scalar, bytes: pointToBytes(p) };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */
function lift_x(x) {
    if (!fe(x))
        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.
    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n)
        y = modP(-y); // Return the unique point P such that x(P) = x and
    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */
function challenge(...args) {
    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */
function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */
function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
    const m = (0, utils_js_1.ensureBytes)('message', message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n)
        throw new Error('sign failed: k is zero'); // Fail if k' = 0.
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px))
        throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */
function schnorrVerify(signature, message, publicKey) {
    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);
    const m = (0, utils_js_1.ensureBytes)('message', message);
    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);
    try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.
        if (!fe(r))
            return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.
        if (!ge(s))
            return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
            return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.
    }
    catch (error) {
        return false;
    }
}
exports.schnorr = (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod,
    },
}))();
const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
    // xNum
    [
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
    ],
    // xDen
    [
        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
    // yNum
    [
        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
    ],
    // yDen
    [
        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
].map((i) => i.map((j) => BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
    B: BigInt('1771'),
    Z: Fp.create(BigInt('-11')),
}))();
const htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
    const { x, y } = mapSWU(Fp.create(scalars[0]));
    return isoMap(x, y);
}, {
    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha256_1.sha256,
}))();
exports.hashToCurve = (() => htf.hashToCurve)();
exports.encodeToCurve = (() => htf.encodeToCurve)();


/***/ }),

/***/ "../../node_modules/@noble/hashes/_assert.js":
/*!***************************************************!*\
  !*** ../../node_modules/@noble/hashes/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = { number, bool, bytes, hash, exists, output };
exports["default"] = assert;


/***/ }),

/***/ "../../node_modules/@noble/hashes/_sha2.js":
/*!*************************************************!*\
  !*** ../../node_modules/@noble/hashes/_sha2.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SHA2 = void 0;
const _assert_js_1 = __webpack_require__(/*! ./_assert.js */ "../../node_modules/@noble/hashes/_assert.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/@noble/hashes/utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;


/***/ }),

/***/ "../../node_modules/@noble/hashes/_u64.js":
/*!************************************************!*\
  !*** ../../node_modules/@noble/hashes/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;


/***/ }),

/***/ "../../node_modules/@noble/hashes/crypto.js":
/*!**************************************************!*\
  !*** ../../node_modules/@noble/hashes/crypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;


/***/ }),

/***/ "../../node_modules/@noble/hashes/hmac.js":
/*!************************************************!*\
  !*** ../../node_modules/@noble/hashes/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hmac = exports.HMAC = void 0;
const _assert_js_1 = __webpack_require__(/*! ./_assert.js */ "../../node_modules/@noble/hashes/_assert.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/@noble/hashes/utils.js");
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);


/***/ }),

/***/ "../../node_modules/@noble/hashes/ripemd160.js":
/*!*****************************************************!*\
  !*** ../../node_modules/@noble/hashes/ripemd160.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = exports.RIPEMD160 = void 0;
const _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ "../../node_modules/@noble/hashes/_sha2.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/@noble/hashes/utils.js");
// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
const shifts = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = /* @__PURE__ */ new Uint32Array([
    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
]);
const Kr = /* @__PURE__ */ new Uint32Array([
    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
]);
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    else if (group === 1)
        return (x & y) | (~x & z);
    else if (group === 2)
        return (x | ~y) ^ z;
    else if (group === 3)
        return (x & z) | (y & ~z);
    else
        return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());


/***/ }),

/***/ "../../node_modules/@noble/hashes/sha256.js":
/*!**************************************************!*\
  !*** ../../node_modules/@noble/hashes/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha224 = exports.sha256 = void 0;
const _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ "../../node_modules/@noble/hashes/_sha2.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/@noble/hashes/utils.js");
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());


/***/ }),

/***/ "../../node_modules/@noble/hashes/sha3.js":
/*!************************************************!*\
  !*** ../../node_modules/@noble/hashes/sha3.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = __webpack_require__(/*! ./_assert.js */ "../../node_modules/@noble/hashes/_assert.js");
const _u64_js_1 = __webpack_require__(/*! ./_u64.js */ "../../node_modules/@noble/hashes/_u64.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/@noble/hashes/utils.js");
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        (0, _assert_js_1.number)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);


/***/ }),

/***/ "../../node_modules/@noble/hashes/utils.js":
/*!*************************************************!*\
  !*** ../../node_modules/@noble/hashes/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
const crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ "../../node_modules/@noble/hashes/crypto.js");
const u8a = (a) => a instanceof Uint8Array;
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;


/***/ }),

/***/ "../../node_modules/base64-js/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/base64-js/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "../../node_modules/buffer/index.js":
/*!******************************************!*\
  !*** ../../node_modules/buffer/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "../../node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "../../node_modules/ieee754/index.js")
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        Buffer.from(buf).copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()


/***/ }),

/***/ "../../node_modules/ieee754/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/ieee754/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "?ed1b":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?d17e":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/errors.js":
/*!*****************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseError = void 0;
const version_js_1 = __webpack_require__(/*! ./version.js */ "../../node_modules/abitype/dist/cjs/version.js");
class BaseError extends Error {
    constructor(shortMessage, args = {}) {
        const details = args.cause instanceof BaseError
            ? args.cause.details
            : args.cause?.message
                ? args.cause.message
                : args.details;
        const docsPath = args.cause instanceof BaseError
            ? args.cause.docsPath || args.docsPath
            : args.docsPath;
        const message = [
            shortMessage || 'An error occurred.',
            '',
            ...(args.metaMessages ? [...args.metaMessages, ''] : []),
            ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),
            ...(details ? [`Details: ${details}`] : []),
            `Version: abitype@${version_js_1.version}`,
        ].join('\n');
        super(message);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiTypeError'
        });
        if (args.cause)
            this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
    }
}
exports.BaseError = BaseError;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnknownSolidityTypeError = exports.UnknownTypeError = exports.InvalidAbiItemError = void 0;
const errors_js_1 = __webpack_require__(/*! ../../errors.js */ "../../node_modules/abitype/dist/cjs/errors.js");
class InvalidAbiItemError extends errors_js_1.BaseError {
    constructor({ signature }) {
        super('Failed to parse ABI item.', {
            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
            docsPath: '/api/human.html#parseabiitem-1',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiItemError'
        });
    }
}
exports.InvalidAbiItemError = InvalidAbiItemError;
class UnknownTypeError extends errors_js_1.BaseError {
    constructor({ type }) {
        super('Unknown type.', {
            metaMessages: [
                `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownTypeError'
        });
    }
}
exports.UnknownTypeError = UnknownTypeError;
class UnknownSolidityTypeError extends errors_js_1.BaseError {
    constructor({ type }) {
        super('Unknown type.', {
            metaMessages: [`Type "${type}" is not a valid ABI type.`],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownSolidityTypeError'
        });
    }
}
exports.UnknownSolidityTypeError = UnknownSolidityTypeError;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidAbiTypeParameterError = exports.InvalidFunctionModifierError = exports.InvalidModifierError = exports.SolidityProtectedKeywordError = exports.InvalidParameterError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = void 0;
const errors_js_1 = __webpack_require__(/*! ../../errors.js */ "../../node_modules/abitype/dist/cjs/errors.js");
class InvalidAbiParameterError extends errors_js_1.BaseError {
    constructor({ param }) {
        super('Failed to parse ABI parameter.', {
            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
            docsPath: '/api/human.html#parseabiparameter-1',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiParameterError'
        });
    }
}
exports.InvalidAbiParameterError = InvalidAbiParameterError;
class InvalidAbiParametersError extends errors_js_1.BaseError {
    constructor({ params }) {
        super('Failed to parse ABI parameters.', {
            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
            docsPath: '/api/human.html#parseabiparameters-1',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiParametersError'
        });
    }
}
exports.InvalidAbiParametersError = InvalidAbiParametersError;
class InvalidParameterError extends errors_js_1.BaseError {
    constructor({ param }) {
        super('Invalid ABI parameter.', {
            details: param,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidParameterError'
        });
    }
}
exports.InvalidParameterError = InvalidParameterError;
class SolidityProtectedKeywordError extends errors_js_1.BaseError {
    constructor({ param, name }) {
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'SolidityProtectedKeywordError'
        });
    }
}
exports.SolidityProtectedKeywordError = SolidityProtectedKeywordError;
class InvalidModifierError extends errors_js_1.BaseError {
    constructor({ param, type, modifier, }) {
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidModifierError'
        });
    }
}
exports.InvalidModifierError = InvalidModifierError;
class InvalidFunctionModifierError extends errors_js_1.BaseError {
    constructor({ param, type, modifier, }) {
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`,
                `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidFunctionModifierError'
        });
    }
}
exports.InvalidFunctionModifierError = InvalidFunctionModifierError;
class InvalidAbiTypeParameterError extends errors_js_1.BaseError {
    constructor({ abiParameter, }) {
        super('Invalid ABI parameter.', {
            details: JSON.stringify(abiParameter, null, 2),
            metaMessages: ['ABI parameter type is invalid.'],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiTypeParameterError'
        });
    }
}
exports.InvalidAbiTypeParameterError = InvalidAbiTypeParameterError;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/errors/signature.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/errors/signature.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidStructSignatureError = exports.UnknownSignatureError = exports.InvalidSignatureError = void 0;
const errors_js_1 = __webpack_require__(/*! ../../errors.js */ "../../node_modules/abitype/dist/cjs/errors.js");
class InvalidSignatureError extends errors_js_1.BaseError {
    constructor({ signature, type, }) {
        super(`Invalid ${type} signature.`, {
            details: signature,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidSignatureError'
        });
    }
}
exports.InvalidSignatureError = InvalidSignatureError;
class UnknownSignatureError extends errors_js_1.BaseError {
    constructor({ signature }) {
        super('Unknown signature.', {
            details: signature,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownSignatureError'
        });
    }
}
exports.UnknownSignatureError = UnknownSignatureError;
class InvalidStructSignatureError extends errors_js_1.BaseError {
    constructor({ signature }) {
        super('Invalid struct signature.', {
            details: signature,
            metaMessages: ['No properties exist.'],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidStructSignatureError'
        });
    }
}
exports.InvalidStructSignatureError = InvalidStructSignatureError;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidParenthesisError = void 0;
const errors_js_1 = __webpack_require__(/*! ../../errors.js */ "../../node_modules/abitype/dist/cjs/errors.js");
class InvalidParenthesisError extends errors_js_1.BaseError {
    constructor({ current, depth }) {
        super('Unbalanced parentheses.', {
            metaMessages: [
                `"${current.trim()}" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`,
            ],
            details: `Depth "${depth}"`,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidParenthesisError'
        });
    }
}
exports.InvalidParenthesisError = InvalidParenthesisError;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/errors/struct.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/errors/struct.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CircularReferenceError = void 0;
const errors_js_1 = __webpack_require__(/*! ../../errors.js */ "../../node_modules/abitype/dist/cjs/errors.js");
class CircularReferenceError extends errors_js_1.BaseError {
    constructor({ type }) {
        super('Circular reference detected.', {
            metaMessages: [`Struct "${type}" is a circular reference.`],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'CircularReferenceError'
        });
    }
}
exports.CircularReferenceError = CircularReferenceError;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/formatAbi.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/formatAbi.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbi = void 0;
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "../../node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js");
function formatAbi(abi) {
    const signatures = [];
    const length = abi.length;
    for (let i = 0; i < length; i++) {
        const abiItem = abi[i];
        const signature = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
        signatures.push(signature);
    }
    return signatures;
}
exports.formatAbi = formatAbi;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbiItem = void 0;
const formatAbiParameters_js_1 = __webpack_require__(/*! ./formatAbiParameters.js */ "../../node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js");
function formatAbiItem(abiItem) {
    if (abiItem.type === 'function')
        return `function ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'
            ? ` ${abiItem.stateMutability}`
            : ''}${abiItem.outputs.length
            ? ` returns (${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.outputs)})`
            : ''}`;
    else if (abiItem.type === 'event')
        return `event ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
    else if (abiItem.type === 'error')
        return `error ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
    else if (abiItem.type === 'constructor')
        return `constructor(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
    else if (abiItem.type === 'fallback')
        return 'fallback()';
    return 'receive() external payable';
}
exports.formatAbiItem = formatAbiItem;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbiParameter = void 0;
const regex_js_1 = __webpack_require__(/*! ../regex.js */ "../../node_modules/abitype/dist/cjs/regex.js");
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter) {
    let type = abiParameter.type;
    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {
        type = '(';
        const length = abiParameter.components.length;
        for (let i = 0; i < length; i++) {
            const component = abiParameter.components[i];
            type += formatAbiParameter(component);
            if (i < length - 1)
                type += ', ';
        }
        const result = (0, regex_js_1.execTyped)(tupleRegex, abiParameter.type);
        type += `)${result?.array ?? ''}`;
        return formatAbiParameter({
            ...abiParameter,
            type,
        });
    }
    if ('indexed' in abiParameter && abiParameter.indexed)
        type = `${type} indexed`;
    if (abiParameter.name)
        return `${type} ${abiParameter.name}`;
    return type;
}
exports.formatAbiParameter = formatAbiParameter;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbiParameters = void 0;
const formatAbiParameter_js_1 = __webpack_require__(/*! ./formatAbiParameter.js */ "../../node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js");
function formatAbiParameters(abiParameters) {
    let params = '';
    const length = abiParameters.length;
    for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        params += (0, formatAbiParameter_js_1.formatAbiParameter)(abiParameter);
        if (i !== length - 1)
            params += ', ';
    }
    return params;
}
exports.formatAbiParameters = formatAbiParameters;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/parseAbi.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/parseAbi.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAbi = void 0;
const signatures_js_1 = __webpack_require__(/*! ./runtime/signatures.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
const structs_js_1 = __webpack_require__(/*! ./runtime/structs.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/structs.js");
const utils_js_1 = __webpack_require__(/*! ./runtime/utils.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
function parseAbi(signatures) {
    const structs = (0, structs_js_1.parseStructs)(signatures);
    const abi = [];
    const length = signatures.length;
    for (let i = 0; i < length; i++) {
        const signature = signatures[i];
        if ((0, signatures_js_1.isStructSignature)(signature))
            continue;
        abi.push((0, utils_js_1.parseSignature)(signature, structs));
    }
    return abi;
}
exports.parseAbi = parseAbi;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAbiItem = void 0;
const index_js_1 = __webpack_require__(/*! ../index.js */ "../../node_modules/abitype/dist/cjs/index.js");
const signatures_js_1 = __webpack_require__(/*! ./runtime/signatures.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
const structs_js_1 = __webpack_require__(/*! ./runtime/structs.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/structs.js");
const utils_js_1 = __webpack_require__(/*! ./runtime/utils.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
function parseAbiItem(signature) {
    let abiItem;
    if (typeof signature === 'string')
        abiItem = (0, utils_js_1.parseSignature)(signature);
    else {
        const structs = (0, structs_js_1.parseStructs)(signature);
        const length = signature.length;
        for (let i = 0; i < length; i++) {
            const signature_ = signature[i];
            if ((0, signatures_js_1.isStructSignature)(signature_))
                continue;
            abiItem = (0, utils_js_1.parseSignature)(signature_, structs);
            break;
        }
    }
    if (!abiItem)
        throw new index_js_1.InvalidAbiItemError({ signature });
    return abiItem;
}
exports.parseAbiItem = parseAbiItem;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAbiParameter = void 0;
const index_js_1 = __webpack_require__(/*! ../index.js */ "../../node_modules/abitype/dist/cjs/index.js");
const signatures_js_1 = __webpack_require__(/*! ./runtime/signatures.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
const structs_js_1 = __webpack_require__(/*! ./runtime/structs.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/structs.js");
const utils_js_1 = __webpack_require__(/*! ./runtime/utils.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
function parseAbiParameter(param) {
    let abiParameter;
    if (typeof param === 'string')
        abiParameter = (0, utils_js_1.parseAbiParameter)(param, {
            modifiers: signatures_js_1.modifiers,
        });
    else {
        const structs = (0, structs_js_1.parseStructs)(param);
        const length = param.length;
        for (let i = 0; i < length; i++) {
            const signature = param[i];
            if ((0, signatures_js_1.isStructSignature)(signature))
                continue;
            abiParameter = (0, utils_js_1.parseAbiParameter)(signature, { modifiers: signatures_js_1.modifiers, structs });
            break;
        }
    }
    if (!abiParameter)
        throw new index_js_1.InvalidAbiParameterError({ param });
    return abiParameter;
}
exports.parseAbiParameter = parseAbiParameter;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAbiParameters = void 0;
const index_js_1 = __webpack_require__(/*! ../index.js */ "../../node_modules/abitype/dist/cjs/index.js");
const signatures_js_1 = __webpack_require__(/*! ./runtime/signatures.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
const structs_js_1 = __webpack_require__(/*! ./runtime/structs.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/structs.js");
const utils_js_1 = __webpack_require__(/*! ./runtime/utils.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
const utils_js_2 = __webpack_require__(/*! ./runtime/utils.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
function parseAbiParameters(params) {
    const abiParameters = [];
    if (typeof params === 'string') {
        const parameters = (0, utils_js_1.splitParameters)(params);
        const length = parameters.length;
        for (let i = 0; i < length; i++) {
            abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[i], { modifiers: signatures_js_1.modifiers }));
        }
    }
    else {
        const structs = (0, structs_js_1.parseStructs)(params);
        const length = params.length;
        for (let i = 0; i < length; i++) {
            const signature = params[i];
            if ((0, signatures_js_1.isStructSignature)(signature))
                continue;
            const parameters = (0, utils_js_1.splitParameters)(signature);
            const length = parameters.length;
            for (let k = 0; k < length; k++) {
                abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[k], { modifiers: signatures_js_1.modifiers, structs }));
            }
        }
    }
    if (abiParameters.length === 0)
        throw new index_js_1.InvalidAbiParametersError({ params });
    return abiParameters;
}
exports.parseAbiParameters = parseAbiParameters;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/runtime/cache.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/runtime/cache.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parameterCache = exports.getParameterCacheKey = void 0;
function getParameterCacheKey(param, type) {
    if (type)
        return `${type}:${param}`;
    return param;
}
exports.getParameterCacheKey = getParameterCacheKey;
exports.parameterCache = new Map([
    ['address', { type: 'address' }],
    ['bool', { type: 'bool' }],
    ['bytes', { type: 'bytes' }],
    ['bytes32', { type: 'bytes32' }],
    ['int', { type: 'int256' }],
    ['int256', { type: 'int256' }],
    ['string', { type: 'string' }],
    ['uint', { type: 'uint256' }],
    ['uint8', { type: 'uint8' }],
    ['uint16', { type: 'uint16' }],
    ['uint24', { type: 'uint24' }],
    ['uint32', { type: 'uint32' }],
    ['uint64', { type: 'uint64' }],
    ['uint96', { type: 'uint96' }],
    ['uint112', { type: 'uint112' }],
    ['uint160', { type: 'uint160' }],
    ['uint192', { type: 'uint192' }],
    ['uint256', { type: 'uint256' }],
    ['address owner', { type: 'address', name: 'owner' }],
    ['address to', { type: 'address', name: 'to' }],
    ['bool approved', { type: 'bool', name: 'approved' }],
    ['bytes _data', { type: 'bytes', name: '_data' }],
    ['bytes data', { type: 'bytes', name: 'data' }],
    ['bytes signature', { type: 'bytes', name: 'signature' }],
    ['bytes32 hash', { type: 'bytes32', name: 'hash' }],
    ['bytes32 r', { type: 'bytes32', name: 'r' }],
    ['bytes32 root', { type: 'bytes32', name: 'root' }],
    ['bytes32 s', { type: 'bytes32', name: 's' }],
    ['string name', { type: 'string', name: 'name' }],
    ['string symbol', { type: 'string', name: 'symbol' }],
    ['string tokenURI', { type: 'string', name: 'tokenURI' }],
    ['uint tokenId', { type: 'uint256', name: 'tokenId' }],
    ['uint8 v', { type: 'uint8', name: 'v' }],
    ['uint256 balance', { type: 'uint256', name: 'balance' }],
    ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],
    ['uint256 value', { type: 'uint256', name: 'value' }],
    [
        'event:address indexed from',
        { type: 'address', name: 'from', indexed: true },
    ],
    ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],
    [
        'event:uint indexed tokenId',
        { type: 'uint256', name: 'tokenId', indexed: true },
    ],
    [
        'event:uint256 indexed tokenId',
        { type: 'uint256', name: 'tokenId', indexed: true },
    ],
]);


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.functionModifiers = exports.eventModifiers = exports.modifiers = exports.isReceiveSignature = exports.isFallbackSignature = exports.execConstructorSignature = exports.isConstructorSignature = exports.execStructSignature = exports.isStructSignature = exports.execFunctionSignature = exports.isFunctionSignature = exports.execEventSignature = exports.isEventSignature = exports.execErrorSignature = exports.isErrorSignature = void 0;
const regex_js_1 = __webpack_require__(/*! ../../regex.js */ "../../node_modules/abitype/dist/cjs/regex.js");
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(signature) {
    return errorSignatureRegex.test(signature);
}
exports.isErrorSignature = isErrorSignature;
function execErrorSignature(signature) {
    return (0, regex_js_1.execTyped)(errorSignatureRegex, signature);
}
exports.execErrorSignature = execErrorSignature;
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(signature) {
    return eventSignatureRegex.test(signature);
}
exports.isEventSignature = isEventSignature;
function execEventSignature(signature) {
    return (0, regex_js_1.execTyped)(eventSignatureRegex, signature);
}
exports.execEventSignature = execEventSignature;
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(signature) {
    return functionSignatureRegex.test(signature);
}
exports.isFunctionSignature = isFunctionSignature;
function execFunctionSignature(signature) {
    return (0, regex_js_1.execTyped)(functionSignatureRegex, signature);
}
exports.execFunctionSignature = execFunctionSignature;
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(signature) {
    return structSignatureRegex.test(signature);
}
exports.isStructSignature = isStructSignature;
function execStructSignature(signature) {
    return (0, regex_js_1.execTyped)(structSignatureRegex, signature);
}
exports.execStructSignature = execStructSignature;
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(signature) {
    return constructorSignatureRegex.test(signature);
}
exports.isConstructorSignature = isConstructorSignature;
function execConstructorSignature(signature) {
    return (0, regex_js_1.execTyped)(constructorSignatureRegex, signature);
}
exports.execConstructorSignature = execConstructorSignature;
const fallbackSignatureRegex = /^fallback\(\)$/;
function isFallbackSignature(signature) {
    return fallbackSignatureRegex.test(signature);
}
exports.isFallbackSignature = isFallbackSignature;
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(signature) {
    return receiveSignatureRegex.test(signature);
}
exports.isReceiveSignature = isReceiveSignature;
exports.modifiers = new Set([
    'memory',
    'indexed',
    'storage',
    'calldata',
]);
exports.eventModifiers = new Set(['indexed']);
exports.functionModifiers = new Set([
    'calldata',
    'memory',
    'storage',
]);


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/runtime/structs.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/runtime/structs.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseStructs = void 0;
const regex_js_1 = __webpack_require__(/*! ../../regex.js */ "../../node_modules/abitype/dist/cjs/regex.js");
const abiItem_js_1 = __webpack_require__(/*! ../errors/abiItem.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js");
const abiParameter_js_1 = __webpack_require__(/*! ../errors/abiParameter.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js");
const signature_js_1 = __webpack_require__(/*! ../errors/signature.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/signature.js");
const struct_js_1 = __webpack_require__(/*! ../errors/struct.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/struct.js");
const signatures_js_1 = __webpack_require__(/*! ./signatures.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
function parseStructs(signatures) {
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for (let i = 0; i < signaturesLength; i++) {
        const signature = signatures[i];
        if (!(0, signatures_js_1.isStructSignature)(signature))
            continue;
        const match = (0, signatures_js_1.execStructSignature)(signature);
        if (!match)
            throw new signature_js_1.InvalidSignatureError({ signature, type: 'struct' });
        const properties = match.properties.split(';');
        const components = [];
        const propertiesLength = properties.length;
        for (let k = 0; k < propertiesLength; k++) {
            const property = properties[k];
            const trimmed = property.trim();
            if (!trimmed)
                continue;
            const abiParameter = (0, utils_js_1.parseAbiParameter)(trimmed, {
                type: 'struct',
            });
            components.push(abiParameter);
        }
        if (!components.length)
            throw new signature_js_1.InvalidStructSignatureError({ signature });
        shallowStructs[match.name] = components;
    }
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for (let i = 0; i < entriesLength; i++) {
        const [name, parameters] = entries[i];
        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
}
exports.parseStructs = parseStructs;
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(abiParameters, structs, ancestors = new Set()) {
    const components = [];
    const length = abiParameters.length;
    for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        const isTuple = regex_js_1.isTupleRegex.test(abiParameter.type);
        if (isTuple)
            components.push(abiParameter);
        else {
            const match = (0, regex_js_1.execTyped)(typeWithoutTupleRegex, abiParameter.type);
            if (!match?.type)
                throw new abiParameter_js_1.InvalidAbiTypeParameterError({ abiParameter });
            const { array, type } = match;
            if (type in structs) {
                if (ancestors.has(type))
                    throw new struct_js_1.CircularReferenceError({ type });
                components.push({
                    ...abiParameter,
                    type: `tuple${array ?? ''}`,
                    components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type])),
                });
            }
            else {
                if ((0, utils_js_1.isSolidityType)(type))
                    components.push(abiParameter);
                else
                    throw new abiItem_js_1.UnknownTypeError({ type });
            }
        }
    }
    return components;
}


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/human-readable/runtime/utils.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/human-readable/runtime/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidDataLocation = exports.isSolidityKeyword = exports.isSolidityType = exports.splitParameters = exports.parseAbiParameter = exports.parseSignature = void 0;
const regex_js_1 = __webpack_require__(/*! ../../regex.js */ "../../node_modules/abitype/dist/cjs/regex.js");
const abiItem_js_1 = __webpack_require__(/*! ../errors/abiItem.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js");
const abiParameter_js_1 = __webpack_require__(/*! ../errors/abiParameter.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js");
const signature_js_1 = __webpack_require__(/*! ../errors/signature.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/signature.js");
const splitParameters_js_1 = __webpack_require__(/*! ../errors/splitParameters.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js");
const cache_js_1 = __webpack_require__(/*! ./cache.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/cache.js");
const signatures_js_1 = __webpack_require__(/*! ./signatures.js */ "../../node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
function parseSignature(signature, structs = {}) {
    if ((0, signatures_js_1.isFunctionSignature)(signature)) {
        const match = (0, signatures_js_1.execFunctionSignature)(signature);
        if (!match)
            throw new signature_js_1.InvalidSignatureError({ signature, type: 'function' });
        const inputParams = splitParameters(match.parameters);
        const inputs = [];
        const inputLength = inputParams.length;
        for (let i = 0; i < inputLength; i++) {
            inputs.push(parseAbiParameter(inputParams[i], {
                modifiers: signatures_js_1.functionModifiers,
                structs,
                type: 'function',
            }));
        }
        const outputs = [];
        if (match.returns) {
            const outputParams = splitParameters(match.returns);
            const outputLength = outputParams.length;
            for (let i = 0; i < outputLength; i++) {
                outputs.push(parseAbiParameter(outputParams[i], {
                    modifiers: signatures_js_1.functionModifiers,
                    structs,
                    type: 'function',
                }));
            }
        }
        return {
            name: match.name,
            type: 'function',
            stateMutability: match.stateMutability ?? 'nonpayable',
            inputs,
            outputs,
        };
    }
    if ((0, signatures_js_1.isEventSignature)(signature)) {
        const match = (0, signatures_js_1.execEventSignature)(signature);
        if (!match)
            throw new signature_js_1.InvalidSignatureError({ signature, type: 'event' });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
            abiParameters.push(parseAbiParameter(params[i], {
                modifiers: signatures_js_1.eventModifiers,
                structs,
                type: 'event',
            }));
        }
        return { name: match.name, type: 'event', inputs: abiParameters };
    }
    if ((0, signatures_js_1.isErrorSignature)(signature)) {
        const match = (0, signatures_js_1.execErrorSignature)(signature);
        if (!match)
            throw new signature_js_1.InvalidSignatureError({ signature, type: 'error' });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
            abiParameters.push(parseAbiParameter(params[i], { structs, type: 'error' }));
        }
        return { name: match.name, type: 'error', inputs: abiParameters };
    }
    if ((0, signatures_js_1.isConstructorSignature)(signature)) {
        const match = (0, signatures_js_1.execConstructorSignature)(signature);
        if (!match)
            throw new signature_js_1.InvalidSignatureError({ signature, type: 'constructor' });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
            abiParameters.push(parseAbiParameter(params[i], { structs, type: 'constructor' }));
        }
        return {
            type: 'constructor',
            stateMutability: match.stateMutability ?? 'nonpayable',
            inputs: abiParameters,
        };
    }
    if ((0, signatures_js_1.isFallbackSignature)(signature))
        return { type: 'fallback' };
    if ((0, signatures_js_1.isReceiveSignature)(signature))
        return {
            type: 'receive',
            stateMutability: 'payable',
        };
    throw new signature_js_1.UnknownSignatureError({ signature });
}
exports.parseSignature = parseSignature;
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(param, options) {
    const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type);
    if (cache_js_1.parameterCache.has(parameterCacheKey))
        return cache_js_1.parameterCache.get(parameterCacheKey);
    const isTuple = regex_js_1.isTupleRegex.test(param);
    const match = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match)
        throw new abiParameter_js_1.InvalidParameterError({ param });
    if (match.name && isSolidityKeyword(match.name))
        throw new abiParameter_js_1.SolidityProtectedKeywordError({ param, name: match.name });
    const name = match.name ? { name: match.name } : {};
    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};
    const structs = options?.structs ?? {};
    let type;
    let components = {};
    if (isTuple) {
        type = 'tuple';
        const params = splitParameters(match.type);
        const components_ = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
            components_.push(parseAbiParameter(params[i], { structs }));
        }
        components = { components: components_ };
    }
    else if (match.type in structs) {
        type = 'tuple';
        components = { components: structs[match.type] };
    }
    else if (dynamicIntegerRegex.test(match.type)) {
        type = `${match.type}256`;
    }
    else {
        type = match.type;
        if (!(options?.type === 'struct') && !isSolidityType(type))
            throw new abiItem_js_1.UnknownSolidityTypeError({ type });
    }
    if (match.modifier) {
        if (!options?.modifiers?.has?.(match.modifier))
            throw new abiParameter_js_1.InvalidModifierError({
                param,
                type: options?.type,
                modifier: match.modifier,
            });
        if (signatures_js_1.functionModifiers.has(match.modifier) &&
            !isValidDataLocation(type, !!match.array))
            throw new abiParameter_js_1.InvalidFunctionModifierError({
                param,
                type: options?.type,
                modifier: match.modifier,
            });
    }
    const abiParameter = {
        type: `${type}${match.array ?? ''}`,
        ...name,
        ...indexed,
        ...components,
    };
    cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);
    return abiParameter;
}
exports.parseAbiParameter = parseAbiParameter;
function splitParameters(params, result = [], current = '', depth = 0) {
    if (params === '') {
        if (current === '')
            return result;
        if (depth !== 0)
            throw new splitParameters_js_1.InvalidParenthesisError({ current, depth });
        result.push(current.trim());
        return result;
    }
    const length = params.length;
    for (let i = 0; i < length; i++) {
        const char = params[i];
        const tail = params.slice(i + 1);
        switch (char) {
            case ',':
                return depth === 0
                    ? splitParameters(tail, [...result, current.trim()])
                    : splitParameters(tail, result, `${current}${char}`, depth);
            case '(':
                return splitParameters(tail, result, `${current}${char}`, depth + 1);
            case ')':
                return splitParameters(tail, result, `${current}${char}`, depth - 1);
            default:
                return splitParameters(tail, result, `${current}${char}`, depth);
        }
    }
    return [];
}
exports.splitParameters = splitParameters;
function isSolidityType(type) {
    return (type === 'address' ||
        type === 'bool' ||
        type === 'function' ||
        type === 'string' ||
        regex_js_1.bytesRegex.test(type) ||
        regex_js_1.integerRegex.test(type));
}
exports.isSolidityType = isSolidityType;
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(name) {
    return (name === 'address' ||
        name === 'bool' ||
        name === 'function' ||
        name === 'string' ||
        name === 'tuple' ||
        regex_js_1.bytesRegex.test(name) ||
        regex_js_1.integerRegex.test(name) ||
        protectedKeywordsRegex.test(name));
}
exports.isSolidityKeyword = isSolidityKeyword;
function isValidDataLocation(type, isArray) {
    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';
}
exports.isValidDataLocation = isValidDataLocation;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CircularReferenceError = exports.InvalidParenthesisError = exports.UnknownSignatureError = exports.InvalidSignatureError = exports.InvalidStructSignatureError = exports.InvalidAbiParameterError = exports.InvalidAbiParametersError = exports.InvalidParameterError = exports.SolidityProtectedKeywordError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.UnknownSolidityTypeError = exports.InvalidAbiItemError = exports.UnknownTypeError = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.formatAbiParameters = exports.formatAbiParameter = exports.formatAbiItem = exports.formatAbi = exports.narrow = exports.BaseError = void 0;
var errors_js_1 = __webpack_require__(/*! ./errors.js */ "../../node_modules/abitype/dist/cjs/errors.js");
Object.defineProperty(exports, "BaseError", ({ enumerable: true, get: function () { return errors_js_1.BaseError; } }));
var narrow_js_1 = __webpack_require__(/*! ./narrow.js */ "../../node_modules/abitype/dist/cjs/narrow.js");
Object.defineProperty(exports, "narrow", ({ enumerable: true, get: function () { return narrow_js_1.narrow; } }));
var formatAbi_js_1 = __webpack_require__(/*! ./human-readable/formatAbi.js */ "../../node_modules/abitype/dist/cjs/human-readable/formatAbi.js");
Object.defineProperty(exports, "formatAbi", ({ enumerable: true, get: function () { return formatAbi_js_1.formatAbi; } }));
var formatAbiItem_js_1 = __webpack_require__(/*! ./human-readable/formatAbiItem.js */ "../../node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js");
Object.defineProperty(exports, "formatAbiItem", ({ enumerable: true, get: function () { return formatAbiItem_js_1.formatAbiItem; } }));
var formatAbiParameter_js_1 = __webpack_require__(/*! ./human-readable/formatAbiParameter.js */ "../../node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js");
Object.defineProperty(exports, "formatAbiParameter", ({ enumerable: true, get: function () { return formatAbiParameter_js_1.formatAbiParameter; } }));
var formatAbiParameters_js_1 = __webpack_require__(/*! ./human-readable/formatAbiParameters.js */ "../../node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js");
Object.defineProperty(exports, "formatAbiParameters", ({ enumerable: true, get: function () { return formatAbiParameters_js_1.formatAbiParameters; } }));
var parseAbi_js_1 = __webpack_require__(/*! ./human-readable/parseAbi.js */ "../../node_modules/abitype/dist/cjs/human-readable/parseAbi.js");
Object.defineProperty(exports, "parseAbi", ({ enumerable: true, get: function () { return parseAbi_js_1.parseAbi; } }));
var parseAbiItem_js_1 = __webpack_require__(/*! ./human-readable/parseAbiItem.js */ "../../node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js");
Object.defineProperty(exports, "parseAbiItem", ({ enumerable: true, get: function () { return parseAbiItem_js_1.parseAbiItem; } }));
var parseAbiParameter_js_1 = __webpack_require__(/*! ./human-readable/parseAbiParameter.js */ "../../node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js");
Object.defineProperty(exports, "parseAbiParameter", ({ enumerable: true, get: function () { return parseAbiParameter_js_1.parseAbiParameter; } }));
var parseAbiParameters_js_1 = __webpack_require__(/*! ./human-readable/parseAbiParameters.js */ "../../node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js");
Object.defineProperty(exports, "parseAbiParameters", ({ enumerable: true, get: function () { return parseAbiParameters_js_1.parseAbiParameters; } }));
var abiItem_js_1 = __webpack_require__(/*! ./human-readable/errors/abiItem.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js");
Object.defineProperty(exports, "UnknownTypeError", ({ enumerable: true, get: function () { return abiItem_js_1.UnknownTypeError; } }));
Object.defineProperty(exports, "InvalidAbiItemError", ({ enumerable: true, get: function () { return abiItem_js_1.InvalidAbiItemError; } }));
Object.defineProperty(exports, "UnknownSolidityTypeError", ({ enumerable: true, get: function () { return abiItem_js_1.UnknownSolidityTypeError; } }));
var abiParameter_js_1 = __webpack_require__(/*! ./human-readable/errors/abiParameter.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js");
Object.defineProperty(exports, "InvalidAbiTypeParameterError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidAbiTypeParameterError; } }));
Object.defineProperty(exports, "InvalidFunctionModifierError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidFunctionModifierError; } }));
Object.defineProperty(exports, "InvalidModifierError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidModifierError; } }));
Object.defineProperty(exports, "SolidityProtectedKeywordError", ({ enumerable: true, get: function () { return abiParameter_js_1.SolidityProtectedKeywordError; } }));
Object.defineProperty(exports, "InvalidParameterError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidParameterError; } }));
Object.defineProperty(exports, "InvalidAbiParametersError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidAbiParametersError; } }));
Object.defineProperty(exports, "InvalidAbiParameterError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidAbiParameterError; } }));
var signature_js_1 = __webpack_require__(/*! ./human-readable/errors/signature.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/signature.js");
Object.defineProperty(exports, "InvalidStructSignatureError", ({ enumerable: true, get: function () { return signature_js_1.InvalidStructSignatureError; } }));
Object.defineProperty(exports, "InvalidSignatureError", ({ enumerable: true, get: function () { return signature_js_1.InvalidSignatureError; } }));
Object.defineProperty(exports, "UnknownSignatureError", ({ enumerable: true, get: function () { return signature_js_1.UnknownSignatureError; } }));
var splitParameters_js_1 = __webpack_require__(/*! ./human-readable/errors/splitParameters.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js");
Object.defineProperty(exports, "InvalidParenthesisError", ({ enumerable: true, get: function () { return splitParameters_js_1.InvalidParenthesisError; } }));
var struct_js_1 = __webpack_require__(/*! ./human-readable/errors/struct.js */ "../../node_modules/abitype/dist/cjs/human-readable/errors/struct.js");
Object.defineProperty(exports, "CircularReferenceError", ({ enumerable: true, get: function () { return struct_js_1.CircularReferenceError; } }));


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/narrow.js":
/*!*****************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/narrow.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.narrow = void 0;
function narrow(value) {
    return value;
}
exports.narrow = narrow;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/regex.js":
/*!****************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/regex.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTupleRegex = exports.integerRegex = exports.bytesRegex = exports.execTyped = void 0;
function execTyped(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
}
exports.execTyped = execTyped;
exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
exports.integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
exports.isTupleRegex = /^\(.+?\).*?$/;


/***/ }),

/***/ "../../node_modules/abitype/dist/cjs/version.js":
/*!******************************************************!*\
  !*** ../../node_modules/abitype/dist/cjs/version.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = '0.9.8';


/***/ }),

/***/ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/accounts/utils/parseAccount.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAccount = void 0;
function parseAccount(account) {
    if (typeof account === 'string')
        return { address: account, type: 'json-rpc' };
    return account;
}
exports.parseAccount = parseAccount;


/***/ }),

/***/ "../../node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.publicKeyToAddress = void 0;
const getAddress_js_1 = __webpack_require__(/*! ../../utils/address/getAddress.js */ "../../node_modules/viem/_cjs/utils/address/getAddress.js");
const keccak256_js_1 = __webpack_require__(/*! ../../utils/hash/keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
function publicKeyToAddress(publicKey) {
    const address = (0, keccak256_js_1.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
    return (0, getAddress_js_1.checksumAddress)(`0x${address}`);
}
exports.publicKeyToAddress = publicKeyToAddress;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/ens/getEnsAddress.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/ens/getEnsAddress.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEnsAddress = void 0;
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "../../node_modules/viem/_cjs/constants/abis.js");
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "../../node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const trim_js_1 = __webpack_require__(/*! ../../utils/data/trim.js */ "../../node_modules/viem/_cjs/utils/data/trim.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const errors_js_1 = __webpack_require__(/*! ../../utils/ens/errors.js */ "../../node_modules/viem/_cjs/utils/ens/errors.js");
const namehash_js_1 = __webpack_require__(/*! ../../utils/ens/namehash.js */ "../../node_modules/viem/_cjs/utils/ens/namehash.js");
const packetToBytes_js_1 = __webpack_require__(/*! ../../utils/ens/packetToBytes.js */ "../../node_modules/viem/_cjs/utils/ens/packetToBytes.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const readContract_js_1 = __webpack_require__(/*! ../public/readContract.js */ "../../node_modules/viem/_cjs/actions/public/readContract.js");
async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, universalResolverAddress: universalResolverAddress_, }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain)
            throw new Error('client chain not configured. universalResolverAddress is required.');
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: 'ensUniversalResolver',
        });
    }
    try {
        const functionData = (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi: abis_js_1.addressResolverAbi,
            functionName: 'addr',
            ...(coinType != null
                ? { args: [(0, namehash_js_1.namehash)(name), BigInt(coinType)] }
                : { args: [(0, namehash_js_1.namehash)(name)] }),
        });
        const res = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract')({
            address: universalResolverAddress,
            abi: abis_js_1.universalResolverResolveAbi,
            functionName: 'resolve',
            args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)), functionData],
            blockNumber,
            blockTag,
        });
        if (res[0] === '0x')
            return null;
        const address = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi: abis_js_1.addressResolverAbi,
            args: coinType != null ? [(0, namehash_js_1.namehash)(name), BigInt(coinType)] : undefined,
            functionName: 'addr',
            data: res[0],
        });
        if (address === '0x')
            return null;
        if ((0, trim_js_1.trim)(address) === '0x00')
            return null;
        return address;
    }
    catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, 'resolve'))
            return null;
        throw err;
    }
}
exports.getEnsAddress = getEnsAddress;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/ens/getEnsAvatar.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/ens/getEnsAvatar.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEnsAvatar = void 0;
const parseAvatarRecord_js_1 = __webpack_require__(/*! ../../utils/ens/avatar/parseAvatarRecord.js */ "../../node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const getEnsText_js_1 = __webpack_require__(/*! ./getEnsText.js */ "../../node_modules/viem/_cjs/actions/ens/getEnsText.js");
async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress, }) {
    const record = await (0, getAction_js_1.getAction)(client, getEnsText_js_1.getEnsText, 'getEnsText')({
        blockNumber,
        blockTag,
        key: 'avatar',
        name,
        universalResolverAddress,
    });
    if (!record)
        return null;
    try {
        return await (0, parseAvatarRecord_js_1.parseAvatarRecord)(client, { record, gatewayUrls });
    }
    catch {
        return null;
    }
}
exports.getEnsAvatar = getEnsAvatar;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/ens/getEnsName.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/ens/getEnsName.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEnsName = void 0;
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "../../node_modules/viem/_cjs/constants/abis.js");
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "../../node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const errors_js_1 = __webpack_require__(/*! ../../utils/ens/errors.js */ "../../node_modules/viem/_cjs/utils/ens/errors.js");
const packetToBytes_js_1 = __webpack_require__(/*! ../../utils/ens/packetToBytes.js */ "../../node_modules/viem/_cjs/utils/ens/packetToBytes.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const readContract_js_1 = __webpack_require__(/*! ../public/readContract.js */ "../../node_modules/viem/_cjs/actions/public/readContract.js");
async function getEnsName(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_, }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain)
            throw new Error('client chain not configured. universalResolverAddress is required.');
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: 'ensUniversalResolver',
        });
    }
    const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
    try {
        const [name, resolvedAddress] = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract')({
            address: universalResolverAddress,
            abi: abis_js_1.universalResolverReverseAbi,
            functionName: 'reverse',
            args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(reverseNode))],
            blockNumber,
            blockTag,
        });
        if (address.toLowerCase() !== resolvedAddress.toLowerCase())
            return null;
        return name;
    }
    catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, 'reverse'))
            return null;
        throw err;
    }
}
exports.getEnsName = getEnsName;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/ens/getEnsResolver.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/ens/getEnsResolver.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEnsResolver = void 0;
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "../../node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const packetToBytes_js_1 = __webpack_require__(/*! ../../utils/ens/packetToBytes.js */ "../../node_modules/viem/_cjs/utils/ens/packetToBytes.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const readContract_js_1 = __webpack_require__(/*! ../public/readContract.js */ "../../node_modules/viem/_cjs/actions/public/readContract.js");
async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_, }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain)
            throw new Error('client chain not configured. universalResolverAddress is required.');
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: 'ensUniversalResolver',
        });
    }
    const [resolverAddress] = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract')({
        address: universalResolverAddress,
        abi: [
            {
                inputs: [{ type: 'bytes' }],
                name: 'findResolver',
                outputs: [{ type: 'address' }, { type: 'bytes32' }],
                stateMutability: 'view',
                type: 'function',
            },
        ],
        functionName: 'findResolver',
        args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name))],
        blockNumber,
        blockTag,
    });
    return resolverAddress;
}
exports.getEnsResolver = getEnsResolver;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/ens/getEnsText.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/ens/getEnsText.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEnsText = void 0;
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "../../node_modules/viem/_cjs/constants/abis.js");
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "../../node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const errors_js_1 = __webpack_require__(/*! ../../utils/ens/errors.js */ "../../node_modules/viem/_cjs/utils/ens/errors.js");
const namehash_js_1 = __webpack_require__(/*! ../../utils/ens/namehash.js */ "../../node_modules/viem/_cjs/utils/ens/namehash.js");
const packetToBytes_js_1 = __webpack_require__(/*! ../../utils/ens/packetToBytes.js */ "../../node_modules/viem/_cjs/utils/ens/packetToBytes.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const readContract_js_1 = __webpack_require__(/*! ../public/readContract.js */ "../../node_modules/viem/_cjs/actions/public/readContract.js");
async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_, }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain)
            throw new Error('client chain not configured. universalResolverAddress is required.');
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: 'ensUniversalResolver',
        });
    }
    try {
        const res = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract')({
            address: universalResolverAddress,
            abi: abis_js_1.universalResolverResolveAbi,
            functionName: 'resolve',
            args: [
                (0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)),
                (0, encodeFunctionData_js_1.encodeFunctionData)({
                    abi: abis_js_1.textResolverAbi,
                    functionName: 'text',
                    args: [(0, namehash_js_1.namehash)(name), key],
                }),
            ],
            blockNumber,
            blockTag,
        });
        if (res[0] === '0x')
            return null;
        const record = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi: abis_js_1.textResolverAbi,
            functionName: 'text',
            data: res[0],
        });
        return record === '' ? null : record;
    }
    catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, 'resolve'))
            return null;
        throw err;
    }
}
exports.getEnsText = getEnsText;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/getContract.js":
/*!***********************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/getContract.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEventParameters = exports.getFunctionParameters = exports.getContract = void 0;
const getAction_js_1 = __webpack_require__(/*! ../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const createContractEventFilter_js_1 = __webpack_require__(/*! ./public/createContractEventFilter.js */ "../../node_modules/viem/_cjs/actions/public/createContractEventFilter.js");
const estimateContractGas_js_1 = __webpack_require__(/*! ./public/estimateContractGas.js */ "../../node_modules/viem/_cjs/actions/public/estimateContractGas.js");
const getContractEvents_js_1 = __webpack_require__(/*! ./public/getContractEvents.js */ "../../node_modules/viem/_cjs/actions/public/getContractEvents.js");
const readContract_js_1 = __webpack_require__(/*! ./public/readContract.js */ "../../node_modules/viem/_cjs/actions/public/readContract.js");
const simulateContract_js_1 = __webpack_require__(/*! ./public/simulateContract.js */ "../../node_modules/viem/_cjs/actions/public/simulateContract.js");
const watchContractEvent_js_1 = __webpack_require__(/*! ./public/watchContractEvent.js */ "../../node_modules/viem/_cjs/actions/public/watchContractEvent.js");
const writeContract_js_1 = __webpack_require__(/*! ./wallet/writeContract.js */ "../../node_modules/viem/_cjs/actions/wallet/writeContract.js");
function getContract({ abi, address, publicClient, walletClient, }) {
    const hasPublicClient = publicClient !== undefined && publicClient !== null;
    const hasWalletClient = walletClient !== undefined && walletClient !== null;
    const contract = {};
    let hasReadFunction = false;
    let hasWriteFunction = false;
    let hasEvent = false;
    for (const item of abi) {
        if (item.type === 'function')
            if (item.stateMutability === 'view' || item.stateMutability === 'pure')
                hasReadFunction = true;
            else
                hasWriteFunction = true;
        else if (item.type === 'event')
            hasEvent = true;
        if (hasReadFunction && hasWriteFunction && hasEvent)
            break;
    }
    if (hasPublicClient) {
        if (hasReadFunction)
            contract.read = new Proxy({}, {
                get(_, functionName) {
                    return (...parameters) => {
                        const { args, options } = getFunctionParameters(parameters);
                        return (0, getAction_js_1.getAction)(publicClient, readContract_js_1.readContract, 'readContract')({
                            abi,
                            address,
                            functionName,
                            args,
                            ...options,
                        });
                    };
                },
            });
        if (hasWriteFunction)
            contract.simulate = new Proxy({}, {
                get(_, functionName) {
                    return (...parameters) => {
                        const { args, options } = getFunctionParameters(parameters);
                        return (0, getAction_js_1.getAction)(publicClient, simulateContract_js_1.simulateContract, 'simulateContract')({
                            abi,
                            address,
                            functionName,
                            args,
                            ...options,
                        });
                    };
                },
            });
        if (hasEvent) {
            contract.createEventFilter = new Proxy({}, {
                get(_, eventName) {
                    return (...parameters) => {
                        const abiEvent = abi.find((x) => x.type === 'event' && x.name === eventName);
                        const { args, options } = getEventParameters(parameters, abiEvent);
                        return (0, getAction_js_1.getAction)(publicClient, createContractEventFilter_js_1.createContractEventFilter, 'createContractEventFilter')({
                            abi,
                            address,
                            eventName,
                            args,
                            ...options,
                        });
                    };
                },
            });
            contract.getEvents = new Proxy({}, {
                get(_, eventName) {
                    return (...parameters) => {
                        const abiEvent = abi.find((x) => x.type === 'event' && x.name === eventName);
                        const { args, options } = getEventParameters(parameters, abiEvent);
                        return (0, getAction_js_1.getAction)(publicClient, getContractEvents_js_1.getContractEvents, 'getContractEvents')({
                            abi,
                            address,
                            eventName,
                            args,
                            ...options,
                        });
                    };
                },
            });
            contract.watchEvent = new Proxy({}, {
                get(_, eventName) {
                    return (...parameters) => {
                        const abiEvent = abi.find((x) => x.type === 'event' && x.name === eventName);
                        const { args, options } = getEventParameters(parameters, abiEvent);
                        return (0, getAction_js_1.getAction)(publicClient, watchContractEvent_js_1.watchContractEvent, 'watchContractEvent')({
                            abi,
                            address,
                            eventName,
                            args,
                            ...options,
                        });
                    };
                },
            });
        }
    }
    if (hasWalletClient) {
        if (hasWriteFunction)
            contract.write = new Proxy({}, {
                get(_, functionName) {
                    return (...parameters) => {
                        const { args, options } = getFunctionParameters(parameters);
                        return (0, getAction_js_1.getAction)(walletClient, writeContract_js_1.writeContract, 'writeContract')({
                            abi,
                            address,
                            functionName,
                            args,
                            ...options,
                        });
                    };
                },
            });
    }
    if (hasPublicClient || hasWalletClient)
        if (hasWriteFunction)
            contract.estimateGas = new Proxy({}, {
                get(_, functionName) {
                    return (...parameters) => {
                        const { args, options } = getFunctionParameters(parameters);
                        const client = (publicClient ?? walletClient);
                        return (0, getAction_js_1.getAction)(client, estimateContractGas_js_1.estimateContractGas, 'estimateContractGas')({
                            abi,
                            address,
                            functionName,
                            args,
                            ...options,
                            account: options.account ??
                                walletClient.account,
                        });
                    };
                },
            });
    contract.address = address;
    contract.abi = abi;
    return contract;
}
exports.getContract = getContract;
function getFunctionParameters(values) {
    const hasArgs = values.length && Array.isArray(values[0]);
    const args = hasArgs ? values[0] : [];
    const options = (hasArgs ? values[1] : values[0]) ?? {};
    return { args, options };
}
exports.getFunctionParameters = getFunctionParameters;
function getEventParameters(values, abiEvent) {
    let hasArgs = false;
    if (Array.isArray(values[0]))
        hasArgs = true;
    else if (values.length === 1) {
        hasArgs = abiEvent.inputs.some((x) => x.indexed);
    }
    else if (values.length === 2) {
        hasArgs = true;
    }
    const args = hasArgs ? values[0] : undefined;
    const options = (hasArgs ? values[1] : values[0]) ?? {};
    return { args, options };
}
exports.getEventParameters = getEventParameters;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/call.js":
/*!***********************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/call.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRevertErrorData = exports.call = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "../../node_modules/viem/_cjs/constants/abis.js");
const contract_js_1 = __webpack_require__(/*! ../../constants/contract.js */ "../../node_modules/viem/_cjs/constants/contract.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const chain_js_1 = __webpack_require__(/*! ../../errors/chain.js */ "../../node_modules/viem/_cjs/errors/chain.js");
const contract_js_2 = __webpack_require__(/*! ../../errors/contract.js */ "../../node_modules/viem/_cjs/errors/contract.js");
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "../../node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const getCallError_js_1 = __webpack_require__(/*! ../../utils/errors/getCallError.js */ "../../node_modules/viem/_cjs/utils/errors/getCallError.js");
const extract_js_1 = __webpack_require__(/*! ../../utils/formatters/extract.js */ "../../node_modules/viem/_cjs/utils/formatters/extract.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
const createBatchScheduler_js_1 = __webpack_require__(/*! ../../utils/promise/createBatchScheduler.js */ "../../node_modules/viem/_cjs/utils/promise/createBatchScheduler.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "../../node_modules/viem/_cjs/utils/transaction/assertRequest.js");
async function call(client, args) {
    const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = 'latest', accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
    try {
        (0, assertRequest_js_1.assertRequest)(args);
        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
            ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
            from: account?.address,
            accessList,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
        });
        if (batch && shouldPerformMulticall({ request })) {
            try {
                return await scheduleMulticall(client, {
                    ...request,
                    blockNumber,
                    blockTag,
                });
            }
            catch (err) {
                if (!(err instanceof chain_js_1.ClientChainNotConfiguredError) &&
                    !(err instanceof chain_js_1.ChainDoesNotSupportContract))
                    throw err;
            }
        }
        const response = await client.request({
            method: 'eth_call',
            params: block
                ? [request, block]
                : [request],
        });
        if (response === '0x')
            return { data: undefined };
        return { data: response };
    }
    catch (err) {
        const data = getRevertErrorData(err);
        const { offchainLookup, offchainLookupSignature } = await Promise.resolve().then(() => __webpack_require__(/*! ../../utils/ccip.js */ "../../node_modules/viem/_cjs/utils/ccip.js"));
        if (data?.slice(0, 10) === offchainLookupSignature && to) {
            return { data: await offchainLookup(client, { data, to }) };
        }
        throw (0, getCallError_js_1.getCallError)(err, {
            ...args,
            account,
            chain: client.chain,
        });
    }
}
exports.call = call;
function shouldPerformMulticall({ request }) {
    const { data, to, ...request_ } = request;
    if (!data)
        return false;
    if (data.startsWith(contract_js_1.aggregate3Signature))
        return false;
    if (!to)
        return false;
    if (Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0)
        return false;
    return true;
}
async function scheduleMulticall(client, args) {
    const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {};
    const { blockNumber, blockTag = 'latest', data, multicallAddress: multicallAddress_, to, } = args;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
        if (!client.chain)
            throw new chain_js_1.ClientChainNotConfiguredError();
        multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: 'multicall3',
        });
    }
    const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: `${client.uid}.${block}`,
        wait,
        shouldSplitBatch(args) {
            const size = args.reduce((size, { data }) => size + (data.length - 2), 0);
            return size > batchSize * 2;
        },
        fn: async (requests) => {
            const calls = requests.map((request) => ({
                allowFailure: true,
                callData: request.data,
                target: request.to,
            }));
            const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
                abi: abis_js_1.multicall3Abi,
                args: [calls],
                functionName: 'aggregate3',
            });
            const data = await client.request({
                method: 'eth_call',
                params: [
                    {
                        data: calldata,
                        to: multicallAddress,
                    },
                    block,
                ],
            });
            return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
                abi: abis_js_1.multicall3Abi,
                args: [calls],
                functionName: 'aggregate3',
                data: data || '0x',
            });
        },
    });
    const [{ returnData, success }] = await schedule({ data, to });
    if (!success)
        throw new contract_js_2.RawContractError({ data: returnData });
    if (returnData === '0x')
        return { data: undefined };
    return { data: returnData };
}
function getRevertErrorData(err) {
    if (!(err instanceof base_js_1.BaseError))
        return undefined;
    const error = err.walk();
    return typeof error.data === 'object' ? error.data.data : error.data;
}
exports.getRevertErrorData = getRevertErrorData;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/createBlockFilter.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/createBlockFilter.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createBlockFilter = void 0;
const createFilterRequestScope_js_1 = __webpack_require__(/*! ../../utils/filters/createFilterRequestScope.js */ "../../node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js");
async function createBlockFilter(client) {
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: 'eth_newBlockFilter',
    });
    const id = await client.request({
        method: 'eth_newBlockFilter',
    });
    return { id, request: getRequest(id), type: 'block' };
}
exports.createBlockFilter = createBlockFilter;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/createContractEventFilter.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/createContractEventFilter.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createContractEventFilter = void 0;
const encodeEventTopics_js_1 = __webpack_require__(/*! ../../utils/abi/encodeEventTopics.js */ "../../node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const createFilterRequestScope_js_1 = __webpack_require__(/*! ../../utils/filters/createFilterRequestScope.js */ "../../node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js");
async function createContractEventFilter(client, { address, abi, args, eventName, fromBlock, strict, toBlock, }) {
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: 'eth_newFilter',
    });
    const topics = eventName
        ? (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi,
            args,
            eventName,
        })
        : undefined;
    const id = await client.request({
        method: 'eth_newFilter',
        params: [
            {
                address,
                fromBlock: typeof fromBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
                topics,
            },
        ],
    });
    return {
        abi,
        args,
        eventName,
        id,
        request: getRequest(id),
        strict,
        type: 'event',
    };
}
exports.createContractEventFilter = createContractEventFilter;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/createEventFilter.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/createEventFilter.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createEventFilter = void 0;
const encodeEventTopics_js_1 = __webpack_require__(/*! ../../utils/abi/encodeEventTopics.js */ "../../node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const createFilterRequestScope_js_1 = __webpack_require__(/*! ../../utils/filters/createFilterRequestScope.js */ "../../node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js");
async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock, } = {}) {
    const events = events_ ?? (event ? [event] : undefined);
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: 'eth_newFilter',
    });
    let topics = [];
    if (events) {
        topics = [
            events.flatMap((event) => (0, encodeEventTopics_js_1.encodeEventTopics)({
                abi: [event],
                eventName: event.name,
                args,
            })),
        ];
        if (event)
            topics = topics[0];
    }
    const id = await client.request({
        method: 'eth_newFilter',
        params: [
            {
                address,
                fromBlock: typeof fromBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
                ...(topics.length ? { topics } : {}),
            },
        ],
    });
    return {
        abi: events,
        args,
        eventName: event ? event.name : undefined,
        fromBlock,
        id,
        request: getRequest(id),
        strict,
        toBlock,
        type: 'event',
    };
}
exports.createEventFilter = createEventFilter;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPendingTransactionFilter = void 0;
const createFilterRequestScope_js_1 = __webpack_require__(/*! ../../utils/filters/createFilterRequestScope.js */ "../../node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js");
async function createPendingTransactionFilter(client) {
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: 'eth_newPendingTransactionFilter',
    });
    const id = await client.request({
        method: 'eth_newPendingTransactionFilter',
    });
    return { id, request: getRequest(id), type: 'transaction' };
}
exports.createPendingTransactionFilter = createPendingTransactionFilter;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/estimateContractGas.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/estimateContractGas.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.estimateContractGas = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getContractError_js_1 = __webpack_require__(/*! ../../utils/errors/getContractError.js */ "../../node_modules/viem/_cjs/utils/errors/getContractError.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const estimateGas_js_1 = __webpack_require__(/*! ./estimateGas.js */ "../../node_modules/viem/_cjs/actions/public/estimateGas.js");
async function estimateContractGas(client, { abi, address, args, functionName, ...request }) {
    const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName,
    });
    try {
        const gas = await (0, getAction_js_1.getAction)(client, estimateGas_js_1.estimateGas, 'estimateGas')({
            data,
            to: address,
            ...request,
        });
        return gas;
    }
    catch (err) {
        const account = request.account ? (0, parseAccount_js_1.parseAccount)(request.account) : undefined;
        throw (0, getContractError_js_1.getContractError)(err, {
            abi: abi,
            address,
            args,
            docsPath: '/docs/contract/estimateContractGas',
            functionName,
            sender: account?.address,
        });
    }
}
exports.estimateContractGas = estimateContractGas;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.internal_estimateFeesPerGas = exports.estimateFeesPerGas = void 0;
const fee_js_1 = __webpack_require__(/*! ../../errors/fee.js */ "../../node_modules/viem/_cjs/errors/fee.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const estimateMaxPriorityFeePerGas_js_1 = __webpack_require__(/*! ./estimateMaxPriorityFeePerGas.js */ "../../node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js");
const getBlock_js_1 = __webpack_require__(/*! ./getBlock.js */ "../../node_modules/viem/_cjs/actions/public/getBlock.js");
const getGasPrice_js_1 = __webpack_require__(/*! ./getGasPrice.js */ "../../node_modules/viem/_cjs/actions/public/getGasPrice.js");
async function estimateFeesPerGas(client, args) {
    return internal_estimateFeesPerGas(client, args);
}
exports.estimateFeesPerGas = estimateFeesPerGas;
async function internal_estimateFeesPerGas(client, args) {
    const { block: block_, chain = client.chain, request, type = 'eip1559', } = args || {};
    const baseFeeMultiplier = await (async () => {
        if (typeof chain?.fees?.baseFeeMultiplier === 'function')
            return chain.fees.baseFeeMultiplier({
                block: block_,
                client,
                request,
            });
        return chain?.fees?.baseFeeMultiplier ?? 1.2;
    })();
    if (baseFeeMultiplier < 1)
        throw new fee_js_1.BaseFeeScalarError();
    const decimals = baseFeeMultiplier.toString().split('.')[1]?.length ?? 0;
    const denominator = 10 ** decimals;
    const multiply = (base) => (base * BigInt(Math.ceil(baseFeeMultiplier * denominator))) /
        BigInt(denominator);
    const block = block_
        ? block_
        : await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({});
    if (typeof chain?.fees?.estimateFeesPerGas === 'function')
        return chain.fees.estimateFeesPerGas({
            block: block_,
            client,
            multiply,
            request,
            type,
        });
    if (type === 'eip1559') {
        if (typeof block.baseFeePerGas !== 'bigint')
            throw new fee_js_1.Eip1559FeesNotSupportedError();
        const maxPriorityFeePerGas = request?.maxPriorityFeePerGas
            ? request.maxPriorityFeePerGas
            : await (0, estimateMaxPriorityFeePerGas_js_1.internal_estimateMaxPriorityFeePerGas)(client, {
                block,
                chain,
                request,
            });
        const baseFeePerGas = multiply(block.baseFeePerGas);
        const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
        return {
            maxFeePerGas,
            maxPriorityFeePerGas,
        };
    }
    const gasPrice = request?.gasPrice ??
        multiply(await (0, getAction_js_1.getAction)(client, getGasPrice_js_1.getGasPrice, 'getGasPrice')({}));
    return {
        gasPrice,
    };
}
exports.internal_estimateFeesPerGas = internal_estimateFeesPerGas;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/estimateGas.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/estimateGas.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.estimateGas = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "../../node_modules/viem/_cjs/errors/account.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const getEstimateGasError_js_1 = __webpack_require__(/*! ../../utils/errors/getEstimateGasError.js */ "../../node_modules/viem/_cjs/utils/errors/getEstimateGasError.js");
const extract_js_1 = __webpack_require__(/*! ../../utils/formatters/extract.js */ "../../node_modules/viem/_cjs/utils/formatters/extract.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "../../node_modules/viem/_cjs/utils/transaction/assertRequest.js");
const prepareTransactionRequest_js_1 = __webpack_require__(/*! ../wallet/prepareTransactionRequest.js */ "../../node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js");
async function estimateGas(client, args) {
    const account_ = args.account ?? client.account;
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/actions/public/estimateGas',
        });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    try {
        const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === 'local'
            ? (await (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args))
            : args;
        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        (0, assertRequest_js_1.assertRequest)(args);
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
            ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
            from: account.address,
            accessList,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
        });
        const balance = await client.request({
            method: 'eth_estimateGas',
            params: block ? [request, block] : [request],
        });
        return BigInt(balance);
    }
    catch (err) {
        throw (0, getEstimateGasError_js_1.getEstimateGasError)(err, {
            ...args,
            account,
            chain: client.chain,
        });
    }
}
exports.estimateGas = estimateGas;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.internal_estimateMaxPriorityFeePerGas = exports.estimateMaxPriorityFeePerGas = void 0;
const fee_js_1 = __webpack_require__(/*! ../../errors/fee.js */ "../../node_modules/viem/_cjs/errors/fee.js");
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const getBlock_js_1 = __webpack_require__(/*! ./getBlock.js */ "../../node_modules/viem/_cjs/actions/public/getBlock.js");
const getGasPrice_js_1 = __webpack_require__(/*! ./getGasPrice.js */ "../../node_modules/viem/_cjs/actions/public/getGasPrice.js");
async function estimateMaxPriorityFeePerGas(client, args) {
    return internal_estimateMaxPriorityFeePerGas(client, args);
}
exports.estimateMaxPriorityFeePerGas = estimateMaxPriorityFeePerGas;
async function internal_estimateMaxPriorityFeePerGas(client, args) {
    const { block: block_, chain = client.chain, request } = args || {};
    if (typeof chain?.fees?.defaultPriorityFee === 'function') {
        const block = block_ || (await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({}));
        return chain.fees.defaultPriorityFee({
            block,
            client,
            request,
        });
    }
    if (typeof chain?.fees?.defaultPriorityFee !== 'undefined')
        return chain?.fees?.defaultPriorityFee;
    try {
        const maxPriorityFeePerGasHex = await client.request({
            method: 'eth_maxPriorityFeePerGas',
        });
        return (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGasHex);
    }
    catch {
        const [block, gasPrice] = await Promise.all([
            block_
                ? Promise.resolve(block_)
                : (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({}),
            (0, getAction_js_1.getAction)(client, getGasPrice_js_1.getGasPrice, 'getGasPrice')({}),
        ]);
        if (typeof block.baseFeePerGas !== 'bigint')
            throw new fee_js_1.Eip1559FeesNotSupportedError();
        const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
        if (maxPriorityFeePerGas < 0n)
            return 0n;
        return maxPriorityFeePerGas;
    }
}
exports.internal_estimateMaxPriorityFeePerGas = internal_estimateMaxPriorityFeePerGas;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getBalance.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getBalance.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBalance = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function getBalance(client, { address, blockNumber, blockTag = 'latest' }) {
    const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const balance = await client.request({
        method: 'eth_getBalance',
        params: [address, blockNumberHex || blockTag],
    });
    return BigInt(balance);
}
exports.getBalance = getBalance;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getBlock.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getBlock.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBlock = void 0;
const block_js_1 = __webpack_require__(/*! ../../errors/block.js */ "../../node_modules/viem/_cjs/errors/block.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const block_js_2 = __webpack_require__(/*! ../../utils/formatters/block.js */ "../../node_modules/viem/_cjs/utils/formatters/block.js");
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_, } = {}) {
    const blockTag = blockTag_ ?? 'latest';
    const includeTransactions = includeTransactions_ ?? false;
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    let block = null;
    if (blockHash) {
        block = await client.request({
            method: 'eth_getBlockByHash',
            params: [blockHash, includeTransactions],
        });
    }
    else {
        block = await client.request({
            method: 'eth_getBlockByNumber',
            params: [blockNumberHex || blockTag, includeTransactions],
        });
    }
    if (!block)
        throw new block_js_1.BlockNotFoundError({ blockHash, blockNumber });
    const format = client.chain?.formatters?.block?.format || block_js_2.formatBlock;
    return format(block);
}
exports.getBlock = getBlock;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getBlockNumber.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getBlockNumber.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBlockNumber = exports.getBlockNumberCache = void 0;
const withCache_js_1 = __webpack_require__(/*! ../../utils/promise/withCache.js */ "../../node_modules/viem/_cjs/utils/promise/withCache.js");
const cacheKey = (id) => `blockNumber.${id}`;
function getBlockNumberCache(id) {
    return (0, withCache_js_1.getCache)(cacheKey(id));
}
exports.getBlockNumberCache = getBlockNumberCache;
async function getBlockNumber(client, { cacheTime = client.cacheTime, maxAge } = {}) {
    const blockNumberHex = await (0, withCache_js_1.withCache)(() => client.request({
        method: 'eth_blockNumber',
    }), { cacheKey: cacheKey(client.uid), cacheTime: maxAge ?? cacheTime });
    return BigInt(blockNumberHex);
}
exports.getBlockNumber = getBlockNumber;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBlockTransactionCount = void 0;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = 'latest', } = {}) {
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    let count;
    if (blockHash) {
        count = await client.request({
            method: 'eth_getBlockTransactionCountByHash',
            params: [blockHash],
        });
    }
    else {
        count = await client.request({
            method: 'eth_getBlockTransactionCountByNumber',
            params: [blockNumberHex || blockTag],
        });
    }
    return (0, fromHex_js_1.hexToNumber)(count);
}
exports.getBlockTransactionCount = getBlockTransactionCount;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getBytecode.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getBytecode.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBytecode = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function getBytecode(client, { address, blockNumber, blockTag = 'latest' }) {
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const hex = await client.request({
        method: 'eth_getCode',
        params: [address, blockNumberHex || blockTag],
    });
    if (hex === '0x')
        return undefined;
    return hex;
}
exports.getBytecode = getBytecode;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getChainId.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getChainId.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getChainId = void 0;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
async function getChainId(client) {
    const chainIdHex = await client.request({
        method: 'eth_chainId',
    });
    return (0, fromHex_js_1.hexToNumber)(chainIdHex);
}
exports.getChainId = getChainId;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getContractEvents.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getContractEvents.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContractEvents = void 0;
const getAbiItem_js_1 = __webpack_require__(/*! ../../utils/abi/getAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const getLogs_js_1 = __webpack_require__(/*! ./getLogs.js */ "../../node_modules/viem/_cjs/actions/public/getLogs.js");
async function getContractEvents(client, { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict, }) {
    const event = eventName
        ? (0, getAbiItem_js_1.getAbiItem)({ abi, name: eventName })
        : undefined;
    const events = !event
        ? abi.filter((x) => x.type === 'event')
        : undefined;
    return (0, getAction_js_1.getAction)(client, getLogs_js_1.getLogs, 'getLogs')({
        address,
        args,
        blockHash,
        event,
        events,
        fromBlock,
        toBlock,
        strict,
    });
}
exports.getContractEvents = getContractEvents;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getFeeHistory.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getFeeHistory.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFeeHistory = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const feeHistory_js_1 = __webpack_require__(/*! ../../utils/formatters/feeHistory.js */ "../../node_modules/viem/_cjs/utils/formatters/feeHistory.js");
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = 'latest', rewardPercentiles, }) {
    const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const feeHistory = await client.request({
        method: 'eth_feeHistory',
        params: [
            (0, toHex_js_1.numberToHex)(blockCount),
            blockNumberHex || blockTag,
            rewardPercentiles,
        ],
    });
    return (0, feeHistory_js_1.formatFeeHistory)(feeHistory);
}
exports.getFeeHistory = getFeeHistory;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getFilterChanges.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getFilterChanges.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFilterChanges = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const decodeEventLog_js_1 = __webpack_require__(/*! ../../utils/abi/decodeEventLog.js */ "../../node_modules/viem/_cjs/utils/abi/decodeEventLog.js");
const log_js_1 = __webpack_require__(/*! ../../utils/formatters/log.js */ "../../node_modules/viem/_cjs/utils/formatters/log.js");
async function getFilterChanges(_client, { filter, }) {
    const strict = 'strict' in filter && filter.strict;
    const logs = await filter.request({
        method: 'eth_getFilterChanges',
        params: [filter.id],
    });
    return logs
        .map((log) => {
        if (typeof log === 'string')
            return log;
        try {
            const { eventName, args } = 'abi' in filter && filter.abi
                ? (0, decodeEventLog_js_1.decodeEventLog)({
                    abi: filter.abi,
                    data: log.data,
                    topics: log.topics,
                    strict,
                })
                : { eventName: undefined, args: undefined };
            return (0, log_js_1.formatLog)(log, { args, eventName });
        }
        catch (err) {
            let eventName;
            let isUnnamed;
            if (err instanceof abi_js_1.DecodeLogDataMismatch ||
                err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                if ('strict' in filter && filter.strict)
                    return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
            }
            return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
    })
        .filter(Boolean);
}
exports.getFilterChanges = getFilterChanges;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getFilterLogs.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getFilterLogs.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFilterLogs = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const decodeEventLog_js_1 = __webpack_require__(/*! ../../utils/abi/decodeEventLog.js */ "../../node_modules/viem/_cjs/utils/abi/decodeEventLog.js");
const log_js_1 = __webpack_require__(/*! ../../utils/formatters/log.js */ "../../node_modules/viem/_cjs/utils/formatters/log.js");
async function getFilterLogs(_client, { filter, }) {
    const strict = filter.strict ?? false;
    const logs = await filter.request({
        method: 'eth_getFilterLogs',
        params: [filter.id],
    });
    return logs
        .map((log) => {
        try {
            const { eventName, args } = 'abi' in filter && filter.abi
                ? (0, decodeEventLog_js_1.decodeEventLog)({
                    abi: filter.abi,
                    data: log.data,
                    topics: log.topics,
                    strict,
                })
                : { eventName: undefined, args: undefined };
            return (0, log_js_1.formatLog)(log, { args, eventName });
        }
        catch (err) {
            let eventName;
            let isUnnamed;
            if (err instanceof abi_js_1.DecodeLogDataMismatch ||
                err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                if ('strict' in filter && filter.strict)
                    return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
            }
            return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
    })
        .filter(Boolean);
}
exports.getFilterLogs = getFilterLogs;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getGasPrice.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getGasPrice.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getGasPrice = void 0;
async function getGasPrice(client) {
    const gasPrice = await client.request({
        method: 'eth_gasPrice',
    });
    return BigInt(gasPrice);
}
exports.getGasPrice = getGasPrice;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getLogs.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getLogs.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLogs = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const decodeEventLog_js_1 = __webpack_require__(/*! ../../utils/abi/decodeEventLog.js */ "../../node_modules/viem/_cjs/utils/abi/decodeEventLog.js");
const encodeEventTopics_js_1 = __webpack_require__(/*! ../../utils/abi/encodeEventTopics.js */ "../../node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const log_js_1 = __webpack_require__(/*! ../../utils/formatters/log.js */ "../../node_modules/viem/_cjs/utils/formatters/log.js");
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_, } = {}) {
    const strict = strict_ ?? false;
    const events = events_ ?? (event ? [event] : undefined);
    let topics = [];
    if (events) {
        topics = [
            events.flatMap((event) => (0, encodeEventTopics_js_1.encodeEventTopics)({
                abi: [event],
                eventName: event.name,
                args,
            })),
        ];
        if (event)
            topics = topics[0];
    }
    let logs;
    if (blockHash) {
        logs = await client.request({
            method: 'eth_getLogs',
            params: [{ address, topics, blockHash }],
        });
    }
    else {
        logs = await client.request({
            method: 'eth_getLogs',
            params: [
                {
                    address,
                    topics,
                    fromBlock: typeof fromBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
                    toBlock: typeof toBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
                },
            ],
        });
    }
    return logs
        .map((log) => {
        try {
            const { eventName, args } = events
                ? (0, decodeEventLog_js_1.decodeEventLog)({
                    abi: events,
                    data: log.data,
                    topics: log.topics,
                    strict,
                })
                : { eventName: undefined, args: undefined };
            return (0, log_js_1.formatLog)(log, { args, eventName: eventName });
        }
        catch (err) {
            let eventName;
            let isUnnamed;
            if (err instanceof abi_js_1.DecodeLogDataMismatch ||
                err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                if (strict)
                    return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
            }
            return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
    })
        .filter(Boolean);
}
exports.getLogs = getLogs;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getProof.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getProof.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProof = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const proof_js_1 = __webpack_require__(/*! ../../utils/formatters/proof.js */ "../../node_modules/viem/_cjs/utils/formatters/proof.js");
async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys, }) {
    const blockTag = blockTag_ ?? 'latest';
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const proof = await client.request({
        method: 'eth_getProof',
        params: [address, storageKeys, blockNumberHex || blockTag],
    });
    return (0, proof_js_1.formatProof)(proof);
}
exports.getProof = getProof;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getStorageAt.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getStorageAt.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getStorageAt = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function getStorageAt(client, { address, blockNumber, blockTag = 'latest', slot }) {
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const data = await client.request({
        method: 'eth_getStorageAt',
        params: [address, slot, blockNumberHex || blockTag],
    });
    return data;
}
exports.getStorageAt = getStorageAt;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getTransaction.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getTransaction.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransaction = void 0;
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const transaction_js_2 = __webpack_require__(/*! ../../utils/formatters/transaction.js */ "../../node_modules/viem/_cjs/utils/formatters/transaction.js");
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash, index, }) {
    const blockTag = blockTag_ || 'latest';
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    let transaction = null;
    if (hash) {
        transaction = await client.request({
            method: 'eth_getTransactionByHash',
            params: [hash],
        });
    }
    else if (blockHash) {
        transaction = await client.request({
            method: 'eth_getTransactionByBlockHashAndIndex',
            params: [blockHash, (0, toHex_js_1.numberToHex)(index)],
        });
    }
    else if (blockNumberHex || blockTag) {
        transaction = await client.request({
            method: 'eth_getTransactionByBlockNumberAndIndex',
            params: [blockNumberHex || blockTag, (0, toHex_js_1.numberToHex)(index)],
        });
    }
    if (!transaction)
        throw new transaction_js_1.TransactionNotFoundError({
            blockHash,
            blockNumber,
            blockTag,
            hash,
            index,
        });
    const format = client.chain?.formatters?.transaction?.format || transaction_js_2.formatTransaction;
    return format(transaction);
}
exports.getTransaction = getTransaction;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransactionConfirmations = void 0;
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const getBlockNumber_js_1 = __webpack_require__(/*! ./getBlockNumber.js */ "../../node_modules/viem/_cjs/actions/public/getBlockNumber.js");
const getTransaction_js_1 = __webpack_require__(/*! ./getTransaction.js */ "../../node_modules/viem/_cjs/actions/public/getTransaction.js");
async function getTransactionConfirmations(client, { hash, transactionReceipt }) {
    const [blockNumber, transaction] = await Promise.all([
        (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, 'getBlockNumber')({}),
        hash
            ? (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, 'getBlockNumber')({ hash })
            : undefined,
    ]);
    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
    if (!transactionBlockNumber)
        return 0n;
    return blockNumber - transactionBlockNumber + 1n;
}
exports.getTransactionConfirmations = getTransactionConfirmations;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getTransactionCount.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getTransactionCount.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransactionCount = void 0;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function getTransactionCount(client, { address, blockTag = 'latest', blockNumber }) {
    const count = await client.request({
        method: 'eth_getTransactionCount',
        params: [address, blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : blockTag],
    });
    return (0, fromHex_js_1.hexToNumber)(count);
}
exports.getTransactionCount = getTransactionCount;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/getTransactionReceipt.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/getTransactionReceipt.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransactionReceipt = void 0;
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
const transactionReceipt_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionReceipt.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionReceipt.js");
async function getTransactionReceipt(client, { hash }) {
    const receipt = await client.request({
        method: 'eth_getTransactionReceipt',
        params: [hash],
    });
    if (!receipt)
        throw new transaction_js_1.TransactionReceiptNotFoundError({ hash });
    const format = client.chain?.formatters?.transactionReceipt?.format ||
        transactionReceipt_js_1.formatTransactionReceipt;
    return format(receipt);
}
exports.getTransactionReceipt = getTransactionReceipt;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/multicall.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/multicall.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.multicall = void 0;
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "../../node_modules/viem/_cjs/constants/abis.js");
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const contract_js_1 = __webpack_require__(/*! ../../errors/contract.js */ "../../node_modules/viem/_cjs/errors/contract.js");
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "../../node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const getContractError_js_1 = __webpack_require__(/*! ../../utils/errors/getContractError.js */ "../../node_modules/viem/_cjs/utils/errors/getContractError.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const readContract_js_1 = __webpack_require__(/*! ./readContract.js */ "../../node_modules/viem/_cjs/actions/public/readContract.js");
async function multicall(client, args) {
    const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts, multicallAddress: multicallAddress_, } = args;
    const batchSize = batchSize_ ??
        ((typeof client.batch?.multicall === 'object' &&
            client.batch.multicall.batchSize) ||
            1024);
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
        if (!client.chain)
            throw new Error('client chain not configured. multicallAddress is required.');
        multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: 'multicall3',
        });
    }
    const chunkedCalls = [[]];
    let currentChunk = 0;
    let currentChunkSize = 0;
    for (let i = 0; i < contracts.length; i++) {
        const { abi, address, args, functionName } = contracts[i];
        try {
            const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({
                abi,
                args,
                functionName,
            });
            currentChunkSize += (callData.length - 2) / 2;
            if (batchSize > 0 &&
                currentChunkSize > batchSize &&
                chunkedCalls[currentChunk].length > 0) {
                currentChunk++;
                currentChunkSize = (callData.length - 2) / 2;
                chunkedCalls[currentChunk] = [];
            }
            chunkedCalls[currentChunk] = [
                ...chunkedCalls[currentChunk],
                {
                    allowFailure: true,
                    callData,
                    target: address,
                },
            ];
        }
        catch (err) {
            const error = (0, getContractError_js_1.getContractError)(err, {
                abi,
                address,
                args,
                docsPath: '/docs/contract/multicall',
                functionName,
            });
            if (!allowFailure)
                throw error;
            chunkedCalls[currentChunk] = [
                ...chunkedCalls[currentChunk],
                {
                    allowFailure: true,
                    callData: '0x',
                    target: address,
                },
            ];
        }
    }
    const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract')({
        abi: abis_js_1.multicall3Abi,
        address: multicallAddress,
        args: [calls],
        blockNumber,
        blockTag,
        functionName: 'aggregate3',
    })));
    const results = [];
    for (let i = 0; i < aggregate3Results.length; i++) {
        const result = aggregate3Results[i];
        if (result.status === 'rejected') {
            if (!allowFailure)
                throw result.reason;
            for (let j = 0; j < chunkedCalls[i].length; j++) {
                results.push({
                    status: 'failure',
                    error: result.reason,
                    result: undefined,
                });
            }
            continue;
        }
        const aggregate3Result = result.value;
        for (let j = 0; j < aggregate3Result.length; j++) {
            const { returnData, success } = aggregate3Result[j];
            const { callData } = chunkedCalls[i][j];
            const { abi, address, functionName, args } = contracts[results.length];
            try {
                if (callData === '0x')
                    throw new abi_js_1.AbiDecodingZeroDataError();
                if (!success)
                    throw new contract_js_1.RawContractError({ data: returnData });
                const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
                    abi,
                    args,
                    data: returnData,
                    functionName,
                });
                results.push(allowFailure ? { result, status: 'success' } : result);
            }
            catch (err) {
                const error = (0, getContractError_js_1.getContractError)(err, {
                    abi,
                    address,
                    args,
                    docsPath: '/docs/contract/multicall',
                    functionName,
                });
                if (!allowFailure)
                    throw error;
                results.push({ error, result: undefined, status: 'failure' });
            }
        }
    }
    if (results.length !== contracts.length)
        throw new base_js_1.BaseError('multicall results mismatch');
    return results;
}
exports.multicall = multicall;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/readContract.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/readContract.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readContract = void 0;
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getContractError_js_1 = __webpack_require__(/*! ../../utils/errors/getContractError.js */ "../../node_modules/viem/_cjs/utils/errors/getContractError.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const call_js_1 = __webpack_require__(/*! ./call.js */ "../../node_modules/viem/_cjs/actions/public/call.js");
async function readContract(client, { abi, address, args, functionName, ...callRequest }) {
    const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName,
    });
    try {
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, 'call')({
            data: calldata,
            to: address,
            ...callRequest,
        });
        return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi,
            args,
            functionName,
            data: data || '0x',
        });
    }
    catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
            abi: abi,
            address,
            args,
            docsPath: '/docs/contract/readContract',
            functionName,
        });
    }
}
exports.readContract = readContract;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/simulateContract.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/simulateContract.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.simulateContract = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getContractError_js_1 = __webpack_require__(/*! ../../utils/errors/getContractError.js */ "../../node_modules/viem/_cjs/utils/errors/getContractError.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const call_js_1 = __webpack_require__(/*! ./call.js */ "../../node_modules/viem/_cjs/actions/public/call.js");
async function simulateContract(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
    const account = callRequest.account
        ? (0, parseAccount_js_1.parseAccount)(callRequest.account)
        : undefined;
    const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName,
    });
    try {
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, 'call')({
            batch: false,
            data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
            to: address,
            ...callRequest,
        });
        const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi,
            args,
            functionName,
            data: data || '0x',
        });
        return {
            result,
            request: {
                abi,
                address,
                args,
                dataSuffix,
                functionName,
                ...callRequest,
            },
        };
    }
    catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
            abi: abi,
            address,
            args,
            docsPath: '/docs/contract/simulateContract',
            functionName,
            sender: account?.address,
        });
    }
}
exports.simulateContract = simulateContract;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/uninstallFilter.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/uninstallFilter.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uninstallFilter = void 0;
async function uninstallFilter(_client, { filter }) {
    return filter.request({
        method: 'eth_uninstallFilter',
        params: [filter.id],
    });
}
exports.uninstallFilter = uninstallFilter;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/verifyHash.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/verifyHash.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyHash = void 0;
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "../../node_modules/viem/_cjs/constants/abis.js");
const contracts_js_1 = __webpack_require__(/*! ../../constants/contracts.js */ "../../node_modules/viem/_cjs/constants/contracts.js");
const contract_js_1 = __webpack_require__(/*! ../../errors/contract.js */ "../../node_modules/viem/_cjs/errors/contract.js");
const isBytesEqual_js_1 = __webpack_require__(/*! ../../utils/data/isBytesEqual.js */ "../../node_modules/viem/_cjs/utils/data/isBytesEqual.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const index_js_1 = __webpack_require__(/*! ../../utils/index.js */ "../../node_modules/viem/_cjs/utils/index.js");
const call_js_1 = __webpack_require__(/*! ./call.js */ "../../node_modules/viem/_cjs/actions/public/call.js");
async function verifyHash(client, { address, hash, signature, ...callRequest }) {
    const signatureHex = (0, index_js_1.isHex)(signature) ? signature : (0, index_js_1.toHex)(signature);
    try {
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, 'call')({
            data: (0, index_js_1.encodeDeployData)({
                abi: abis_js_1.universalSignatureValidatorAbi,
                args: [address, hash, signatureHex],
                bytecode: contracts_js_1.universalSignatureValidatorByteCode,
            }),
            ...callRequest,
        });
        return (0, isBytesEqual_js_1.isBytesEqual)(data ?? '0x0', '0x1');
    }
    catch (error) {
        if (error instanceof contract_js_1.CallExecutionError) {
            return false;
        }
        throw error;
    }
}
exports.verifyHash = verifyHash;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/verifyMessage.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/verifyMessage.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyMessage = void 0;
const index_js_1 = __webpack_require__(/*! ../../utils/index.js */ "../../node_modules/viem/_cjs/utils/index.js");
const verifyHash_js_1 = __webpack_require__(/*! ./verifyHash.js */ "../../node_modules/viem/_cjs/actions/public/verifyHash.js");
async function verifyMessage(client, { address, message, signature, ...callRequest }) {
    const hash = (0, index_js_1.hashMessage)(message);
    return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest,
    });
}
exports.verifyMessage = verifyMessage;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/verifyTypedData.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/verifyTypedData.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyTypedData = void 0;
const hashTypedData_js_1 = __webpack_require__(/*! ../../utils/signature/hashTypedData.js */ "../../node_modules/viem/_cjs/utils/signature/hashTypedData.js");
const verifyHash_js_1 = __webpack_require__(/*! ./verifyHash.js */ "../../node_modules/viem/_cjs/actions/public/verifyHash.js");
async function verifyTypedData(client, { address, signature, message, primaryType, types, domain, ...callRequest }) {
    const hash = (0, hashTypedData_js_1.hashTypedData)({ message, primaryType, types, domain });
    return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest,
    });
}
exports.verifyTypedData = verifyTypedData;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitForTransactionReceipt = void 0;
const block_js_1 = __webpack_require__(/*! ../../errors/block.js */ "../../node_modules/viem/_cjs/errors/block.js");
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "../../node_modules/viem/_cjs/utils/observe.js");
const withRetry_js_1 = __webpack_require__(/*! ../../utils/promise/withRetry.js */ "../../node_modules/viem/_cjs/utils/promise/withRetry.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
const getBlock_js_1 = __webpack_require__(/*! ./getBlock.js */ "../../node_modules/viem/_cjs/actions/public/getBlock.js");
const getTransaction_js_1 = __webpack_require__(/*! ./getTransaction.js */ "../../node_modules/viem/_cjs/actions/public/getTransaction.js");
const getTransactionReceipt_js_1 = __webpack_require__(/*! ./getTransactionReceipt.js */ "../../node_modules/viem/_cjs/actions/public/getTransactionReceipt.js");
const watchBlockNumber_js_1 = __webpack_require__(/*! ./watchBlockNumber.js */ "../../node_modules/viem/_cjs/actions/public/watchBlockNumber.js");
async function waitForTransactionReceipt(client, { confirmations = 1, hash, onReplaced, pollingInterval = client.pollingInterval, timeout, }) {
    const observerId = (0, stringify_js_1.stringify)(['waitForTransactionReceipt', client.uid, hash]);
    let transaction;
    let replacedTransaction;
    let receipt;
    let retrying = false;
    return new Promise((resolve, reject) => {
        if (timeout)
            setTimeout(() => reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({ hash })), timeout);
        const _unobserve = (0, observe_js_1.observe)(observerId, { onReplaced, resolve, reject }, (emit) => {
            const _unwatch = (0, getAction_js_1.getAction)(client, watchBlockNumber_js_1.watchBlockNumber, 'watchBlockNumber')({
                emitMissed: true,
                emitOnBegin: true,
                poll: true,
                pollingInterval,
                async onBlockNumber(blockNumber_) {
                    if (retrying)
                        return;
                    let blockNumber = blockNumber_;
                    const done = (fn) => {
                        _unwatch();
                        fn();
                        _unobserve();
                    };
                    try {
                        if (receipt) {
                            if (confirmations > 1 &&
                                (!receipt.blockNumber ||
                                    blockNumber - receipt.blockNumber + 1n < confirmations))
                                return;
                            done(() => emit.resolve(receipt));
                            return;
                        }
                        if (!transaction) {
                            retrying = true;
                            await (0, withRetry_js_1.withRetry)(async () => {
                                transaction = (await (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, 'getTransaction')({ hash }));
                                if (transaction.blockNumber)
                                    blockNumber = transaction.blockNumber;
                            }, {
                                delay: ({ count }) => ~~(1 << count) * 200,
                                retryCount: 6,
                            });
                            retrying = false;
                        }
                        receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({ hash });
                        if (confirmations > 1 &&
                            (!receipt.blockNumber ||
                                blockNumber - receipt.blockNumber + 1n < confirmations))
                            return;
                        done(() => emit.resolve(receipt));
                    }
                    catch (err) {
                        if (transaction &&
                            (err instanceof transaction_js_1.TransactionNotFoundError ||
                                err instanceof transaction_js_1.TransactionReceiptNotFoundError)) {
                            try {
                                replacedTransaction = transaction;
                                retrying = true;
                                const block = await (0, withRetry_js_1.withRetry)(() => (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({
                                    blockNumber,
                                    includeTransactions: true,
                                }), {
                                    delay: ({ count }) => ~~(1 << count) * 200,
                                    retryCount: 6,
                                    shouldRetry: ({ error }) => error instanceof block_js_1.BlockNotFoundError,
                                });
                                retrying = false;
                                const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from &&
                                    nonce === replacedTransaction.nonce);
                                if (!replacementTransaction)
                                    return;
                                receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({
                                    hash: replacementTransaction.hash,
                                });
                                if (confirmations > 1 &&
                                    (!receipt.blockNumber ||
                                        blockNumber - receipt.blockNumber + 1n < confirmations))
                                    return;
                                let reason = 'replaced';
                                if (replacementTransaction.to === replacedTransaction.to &&
                                    replacementTransaction.value === replacedTransaction.value) {
                                    reason = 'repriced';
                                }
                                else if (replacementTransaction.from === replacementTransaction.to &&
                                    replacementTransaction.value === 0n) {
                                    reason = 'cancelled';
                                }
                                done(() => {
                                    emit.onReplaced?.({
                                        reason,
                                        replacedTransaction: replacedTransaction,
                                        transaction: replacementTransaction,
                                        transactionReceipt: receipt,
                                    });
                                    emit.resolve(receipt);
                                });
                            }
                            catch (err_) {
                                done(() => emit.reject(err_));
                            }
                        }
                        else {
                            done(() => emit.reject(err));
                        }
                    }
                },
            });
        });
    });
}
exports.waitForTransactionReceipt = waitForTransactionReceipt;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/watchBlockNumber.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/watchBlockNumber.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchBlockNumber = void 0;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "../../node_modules/viem/_cjs/utils/observe.js");
const poll_js_1 = __webpack_require__(/*! ../../utils/poll.js */ "../../node_modules/viem/_cjs/utils/poll.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
const getBlockNumber_js_1 = __webpack_require__(/*! ./getBlockNumber.js */ "../../node_modules/viem/_cjs/actions/public/getBlockNumber.js");
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval, }) {
    const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';
    let prevBlockNumber;
    const pollBlockNumber = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchBlockNumber',
            client.uid,
            emitOnBegin,
            emitMissed,
            pollingInterval,
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlockNumber, onError }, (emit) => (0, poll_js_1.poll)(async () => {
            try {
                const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, 'getBlockNumber')({ cacheTime: 0 });
                if (prevBlockNumber) {
                    if (blockNumber === prevBlockNumber)
                        return;
                    if (blockNumber - prevBlockNumber > 1 && emitMissed) {
                        for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
                            emit.onBlockNumber(i, prevBlockNumber);
                            prevBlockNumber = i;
                        }
                    }
                }
                if (!prevBlockNumber || blockNumber > prevBlockNumber) {
                    emit.onBlockNumber(blockNumber, prevBlockNumber);
                    prevBlockNumber = blockNumber;
                }
            }
            catch (err) {
                emit.onError?.(err);
            }
        }, {
            emitOnBegin,
            interval: pollingInterval,
        }));
    };
    const subscribeBlockNumber = () => {
        let active = true;
        let unsubscribe = () => (active = false);
        (async () => {
            try {
                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                    params: ['newHeads'],
                    onData(data) {
                        if (!active)
                            return;
                        const blockNumber = (0, fromHex_js_1.hexToBigInt)(data.result?.number);
                        onBlockNumber(blockNumber, prevBlockNumber);
                        prevBlockNumber = blockNumber;
                    },
                    onError(error) {
                        onError?.(error);
                    },
                });
                unsubscribe = unsubscribe_;
                if (!active)
                    unsubscribe();
            }
            catch (err) {
                onError?.(err);
            }
        })();
        return unsubscribe;
    };
    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}
exports.watchBlockNumber = watchBlockNumber;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/watchBlocks.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/watchBlocks.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchBlocks = void 0;
const block_js_1 = __webpack_require__(/*! ../../utils/formatters/block.js */ "../../node_modules/viem/_cjs/utils/formatters/block.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "../../node_modules/viem/_cjs/utils/observe.js");
const poll_js_1 = __webpack_require__(/*! ../../utils/poll.js */ "../../node_modules/viem/_cjs/utils/poll.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
const getBlock_js_1 = __webpack_require__(/*! ./getBlock.js */ "../../node_modules/viem/_cjs/actions/public/getBlock.js");
function watchBlocks(client, { blockTag = 'latest', emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval, }) {
    const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';
    const includeTransactions = includeTransactions_ ?? false;
    let prevBlock;
    const pollBlocks = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchBlocks',
            client.uid,
            emitMissed,
            emitOnBegin,
            includeTransactions,
            pollingInterval,
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlock, onError }, (emit) => (0, poll_js_1.poll)(async () => {
            try {
                const block = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({
                    blockTag,
                    includeTransactions,
                });
                if (block.number && prevBlock?.number) {
                    if (block.number === prevBlock.number)
                        return;
                    if (block.number - prevBlock.number > 1 && emitMissed) {
                        for (let i = prevBlock?.number + 1n; i < block.number; i++) {
                            const block = (await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({
                                blockNumber: i,
                                includeTransactions,
                            }));
                            emit.onBlock(block, prevBlock);
                            prevBlock = block;
                        }
                    }
                }
                if (!prevBlock?.number ||
                    (blockTag === 'pending' && !block?.number) ||
                    (block.number && block.number > prevBlock.number)) {
                    emit.onBlock(block, prevBlock);
                    prevBlock = block;
                }
            }
            catch (err) {
                emit.onError?.(err);
            }
        }, {
            emitOnBegin,
            interval: pollingInterval,
        }));
    };
    const subscribeBlocks = () => {
        let active = true;
        let unsubscribe = () => (active = false);
        (async () => {
            try {
                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                    params: ['newHeads'],
                    onData(data) {
                        if (!active)
                            return;
                        const format = client.chain?.formatters?.block?.format || block_js_1.formatBlock;
                        const block = format(data.result);
                        onBlock(block, prevBlock);
                        prevBlock = block;
                    },
                    onError(error) {
                        onError?.(error);
                    },
                });
                unsubscribe = unsubscribe_;
                if (!active)
                    unsubscribe();
            }
            catch (err) {
                onError?.(err);
            }
        })();
        return unsubscribe;
    };
    return enablePolling ? pollBlocks() : subscribeBlocks();
}
exports.watchBlocks = watchBlocks;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/watchContractEvent.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/watchContractEvent.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchContractEvent = void 0;
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "../../node_modules/viem/_cjs/utils/observe.js");
const poll_js_1 = __webpack_require__(/*! ../../utils/poll.js */ "../../node_modules/viem/_cjs/utils/poll.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const rpc_js_1 = __webpack_require__(/*! ../../errors/rpc.js */ "../../node_modules/viem/_cjs/errors/rpc.js");
const decodeEventLog_js_1 = __webpack_require__(/*! ../../utils/abi/decodeEventLog.js */ "../../node_modules/viem/_cjs/utils/abi/decodeEventLog.js");
const encodeEventTopics_js_1 = __webpack_require__(/*! ../../utils/abi/encodeEventTopics.js */ "../../node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
const log_js_1 = __webpack_require__(/*! ../../utils/formatters/log.js */ "../../node_modules/viem/_cjs/utils/formatters/log.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const createContractEventFilter_js_1 = __webpack_require__(/*! ./createContractEventFilter.js */ "../../node_modules/viem/_cjs/actions/public/createContractEventFilter.js");
const getBlockNumber_js_1 = __webpack_require__(/*! ./getBlockNumber.js */ "../../node_modules/viem/_cjs/actions/public/getBlockNumber.js");
const getContractEvents_js_1 = __webpack_require__(/*! ./getContractEvents.js */ "../../node_modules/viem/_cjs/actions/public/getContractEvents.js");
const getFilterChanges_js_1 = __webpack_require__(/*! ./getFilterChanges.js */ "../../node_modules/viem/_cjs/actions/public/getFilterChanges.js");
const uninstallFilter_js_1 = __webpack_require__(/*! ./uninstallFilter.js */ "../../node_modules/viem/_cjs/actions/public/uninstallFilter.js");
function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_, }) {
    const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';
    const pollContractEvent = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchContractEvent',
            address,
            args,
            batch,
            client.uid,
            eventName,
            pollingInterval,
        ]);
        const strict = strict_ ?? false;
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
            let previousBlockNumber;
            let filter;
            let initialized = false;
            const unwatch = (0, poll_js_1.poll)(async () => {
                if (!initialized) {
                    try {
                        filter = (await (0, getAction_js_1.getAction)(client, createContractEventFilter_js_1.createContractEventFilter, 'createContractEventFilter')({
                            abi,
                            address,
                            args,
                            eventName,
                            strict,
                        }));
                    }
                    catch { }
                    initialized = true;
                    return;
                }
                try {
                    let logs;
                    if (filter) {
                        logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, 'getFilterChanges')({ filter });
                    }
                    else {
                        const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, 'getBlockNumber')({});
                        if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                            logs = await (0, getAction_js_1.getAction)(client, getContractEvents_js_1.getContractEvents, 'getContractEvents')({
                                abi,
                                address,
                                args,
                                eventName,
                                fromBlock: previousBlockNumber + 1n,
                                toBlock: blockNumber,
                                strict,
                            });
                        }
                        else {
                            logs = [];
                        }
                        previousBlockNumber = blockNumber;
                    }
                    if (logs.length === 0)
                        return;
                    if (batch)
                        emit.onLogs(logs);
                    else
                        for (const log of logs)
                            emit.onLogs([log]);
                }
                catch (err) {
                    if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
                        initialized = false;
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval,
            });
            return async () => {
                if (filter)
                    await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, 'uninstallFilter')({ filter });
                unwatch();
            };
        });
    };
    const subscribeContractEvent = () => {
        let active = true;
        let unsubscribe = () => (active = false);
        (async () => {
            try {
                const topics = eventName
                    ? (0, encodeEventTopics_js_1.encodeEventTopics)({
                        abi: abi,
                        eventName: eventName,
                        args,
                    })
                    : [];
                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                    params: ['logs', { address, topics }],
                    onData(data) {
                        if (!active)
                            return;
                        const log = data.result;
                        try {
                            const { eventName, args } = (0, decodeEventLog_js_1.decodeEventLog)({
                                abi: abi,
                                data: log.data,
                                topics: log.topics,
                                strict: strict_,
                            });
                            const formatted = (0, log_js_1.formatLog)(log, {
                                args,
                                eventName: eventName,
                            });
                            onLogs([formatted]);
                        }
                        catch (err) {
                            let eventName;
                            let isUnnamed;
                            if (err instanceof abi_js_1.DecodeLogDataMismatch ||
                                err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                                if (strict_)
                                    return;
                                eventName = err.abiItem.name;
                                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
                            }
                            const formatted = (0, log_js_1.formatLog)(log, {
                                args: isUnnamed ? [] : {},
                                eventName,
                            });
                            onLogs([formatted]);
                        }
                    },
                    onError(error) {
                        onError?.(error);
                    },
                });
                unsubscribe = unsubscribe_;
                if (!active)
                    unsubscribe();
            }
            catch (err) {
                onError?.(err);
            }
        })();
        return unsubscribe;
    };
    return enablePolling ? pollContractEvent() : subscribeContractEvent();
}
exports.watchContractEvent = watchContractEvent;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/watchEvent.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/watchEvent.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchEvent = void 0;
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "../../node_modules/viem/_cjs/utils/observe.js");
const poll_js_1 = __webpack_require__(/*! ../../utils/poll.js */ "../../node_modules/viem/_cjs/utils/poll.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const rpc_js_1 = __webpack_require__(/*! ../../errors/rpc.js */ "../../node_modules/viem/_cjs/errors/rpc.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const index_js_1 = __webpack_require__(/*! ../../utils/index.js */ "../../node_modules/viem/_cjs/utils/index.js");
const createEventFilter_js_1 = __webpack_require__(/*! ./createEventFilter.js */ "../../node_modules/viem/_cjs/actions/public/createEventFilter.js");
const getBlockNumber_js_1 = __webpack_require__(/*! ./getBlockNumber.js */ "../../node_modules/viem/_cjs/actions/public/getBlockNumber.js");
const getFilterChanges_js_1 = __webpack_require__(/*! ./getFilterChanges.js */ "../../node_modules/viem/_cjs/actions/public/getFilterChanges.js");
const getLogs_js_1 = __webpack_require__(/*! ./getLogs.js */ "../../node_modules/viem/_cjs/actions/public/getLogs.js");
const uninstallFilter_js_1 = __webpack_require__(/*! ./uninstallFilter.js */ "../../node_modules/viem/_cjs/actions/public/uninstallFilter.js");
function watchEvent(client, { address, args, batch = true, event, events, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_, }) {
    const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';
    const strict = strict_ ?? false;
    const pollEvent = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchEvent',
            address,
            args,
            batch,
            client.uid,
            event,
            pollingInterval,
        ]);
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
            let previousBlockNumber;
            let filter;
            let initialized = false;
            const unwatch = (0, poll_js_1.poll)(async () => {
                if (!initialized) {
                    try {
                        filter = (await (0, getAction_js_1.getAction)(client, createEventFilter_js_1.createEventFilter, 'createEventFilter')({
                            address,
                            args,
                            event: event,
                            events,
                            strict,
                        }));
                    }
                    catch { }
                    initialized = true;
                    return;
                }
                try {
                    let logs;
                    if (filter) {
                        logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, 'getFilterChanges')({ filter });
                    }
                    else {
                        const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, 'getBlockNumber')({});
                        if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                            logs = await (0, getAction_js_1.getAction)(client, getLogs_js_1.getLogs, 'getLogs')({
                                address,
                                args,
                                event: event,
                                events,
                                fromBlock: previousBlockNumber + 1n,
                                toBlock: blockNumber,
                            });
                        }
                        else {
                            logs = [];
                        }
                        previousBlockNumber = blockNumber;
                    }
                    if (logs.length === 0)
                        return;
                    if (batch)
                        emit.onLogs(logs);
                    else
                        for (const log of logs)
                            emit.onLogs([log]);
                }
                catch (err) {
                    if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
                        initialized = false;
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval,
            });
            return async () => {
                if (filter)
                    await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, 'uninstallFilter')({ filter });
                unwatch();
            };
        });
    };
    const subscribeEvent = () => {
        let active = true;
        let unsubscribe = () => (active = false);
        (async () => {
            try {
                const events_ = events ?? (event ? [event] : undefined);
                let topics = [];
                if (events_) {
                    topics = [
                        events_.flatMap((event) => (0, index_js_1.encodeEventTopics)({
                            abi: [event],
                            eventName: event.name,
                            args,
                        })),
                    ];
                    if (event)
                        topics = topics[0];
                }
                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                    params: ['logs', { address, topics }],
                    onData(data) {
                        if (!active)
                            return;
                        const log = data.result;
                        try {
                            const { eventName, args } = (0, index_js_1.decodeEventLog)({
                                abi: events_,
                                data: log.data,
                                topics: log.topics,
                                strict,
                            });
                            const formatted = (0, index_js_1.formatLog)(log, {
                                args,
                                eventName: eventName,
                            });
                            onLogs([formatted]);
                        }
                        catch (err) {
                            let eventName;
                            let isUnnamed;
                            if (err instanceof abi_js_1.DecodeLogDataMismatch ||
                                err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                                if (strict_)
                                    return;
                                eventName = err.abiItem.name;
                                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
                            }
                            const formatted = (0, index_js_1.formatLog)(log, {
                                args: isUnnamed ? [] : {},
                                eventName,
                            });
                            onLogs([formatted]);
                        }
                    },
                    onError(error) {
                        onError?.(error);
                    },
                });
                unsubscribe = unsubscribe_;
                if (!active)
                    unsubscribe();
            }
            catch (err) {
                onError?.(err);
            }
        })();
        return unsubscribe;
    };
    return enablePolling ? pollEvent() : subscribeEvent();
}
exports.watchEvent = watchEvent;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/public/watchPendingTransactions.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/public/watchPendingTransactions.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchPendingTransactions = void 0;
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "../../node_modules/viem/_cjs/utils/observe.js");
const poll_js_1 = __webpack_require__(/*! ../../utils/poll.js */ "../../node_modules/viem/_cjs/utils/poll.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
const createPendingTransactionFilter_js_1 = __webpack_require__(/*! ./createPendingTransactionFilter.js */ "../../node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js");
const getFilterChanges_js_1 = __webpack_require__(/*! ./getFilterChanges.js */ "../../node_modules/viem/_cjs/actions/public/getFilterChanges.js");
const uninstallFilter_js_1 = __webpack_require__(/*! ./uninstallFilter.js */ "../../node_modules/viem/_cjs/actions/public/uninstallFilter.js");
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval, }) {
    const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';
    const pollPendingTransactions = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchPendingTransactions',
            client.uid,
            batch,
            pollingInterval,
        ]);
        return (0, observe_js_1.observe)(observerId, { onTransactions, onError }, (emit) => {
            let filter;
            const unwatch = (0, poll_js_1.poll)(async () => {
                try {
                    if (!filter) {
                        try {
                            filter = await (0, getAction_js_1.getAction)(client, createPendingTransactionFilter_js_1.createPendingTransactionFilter, 'createPendingTransactionFilter')({});
                            return;
                        }
                        catch (err) {
                            unwatch();
                            throw err;
                        }
                    }
                    const hashes = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, 'getFilterChanges')({ filter });
                    if (hashes.length === 0)
                        return;
                    if (batch)
                        emit.onTransactions(hashes);
                    else
                        for (const hash of hashes)
                            emit.onTransactions([hash]);
                }
                catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval,
            });
            return async () => {
                if (filter)
                    await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, 'uninstallFilter')({ filter });
                unwatch();
            };
        });
    };
    const subscribePendingTransactions = () => {
        let active = true;
        let unsubscribe = () => (active = false);
        (async () => {
            try {
                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                    params: ['newPendingTransactions'],
                    onData(data) {
                        if (!active)
                            return;
                        const transaction = data.result;
                        onTransactions([transaction]);
                    },
                    onError(error) {
                        onError?.(error);
                    },
                });
                unsubscribe = unsubscribe_;
                if (!active)
                    unsubscribe();
            }
            catch (err) {
                onError?.(err);
            }
        })();
        return unsubscribe;
    };
    return enablePolling
        ? pollPendingTransactions()
        : subscribePendingTransactions();
}
exports.watchPendingTransactions = watchPendingTransactions;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/dropTransaction.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/dropTransaction.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dropTransaction = void 0;
async function dropTransaction(client, { hash }) {
    await client.request({
        method: `${client.mode}_dropTransaction`,
        params: [hash],
    });
}
exports.dropTransaction = dropTransaction;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/dumpState.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/dumpState.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dumpState = void 0;
async function dumpState(client) {
    return client.request({
        method: `${client.mode}_dumpState`,
    });
}
exports.dumpState = dumpState;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/getAutomine.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/getAutomine.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAutomine = void 0;
async function getAutomine(client) {
    if (client.mode === 'ganache')
        return await client.request({
            method: 'eth_mining',
        });
    return await client.request({
        method: `${client.mode}_getAutomine`,
    });
}
exports.getAutomine = getAutomine;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/getTxpoolContent.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/getTxpoolContent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTxpoolContent = void 0;
async function getTxpoolContent(client) {
    return await client.request({
        method: 'txpool_content',
    });
}
exports.getTxpoolContent = getTxpoolContent;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/getTxpoolStatus.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/getTxpoolStatus.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTxpoolStatus = void 0;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
async function getTxpoolStatus(client) {
    const { pending, queued } = await client.request({
        method: 'txpool_status',
    });
    return {
        pending: (0, fromHex_js_1.hexToNumber)(pending),
        queued: (0, fromHex_js_1.hexToNumber)(queued),
    };
}
exports.getTxpoolStatus = getTxpoolStatus;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/impersonateAccount.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/impersonateAccount.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.impersonateAccount = void 0;
async function impersonateAccount(client, { address }) {
    await client.request({
        method: `${client.mode}_impersonateAccount`,
        params: [address],
    });
}
exports.impersonateAccount = impersonateAccount;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/increaseTime.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/increaseTime.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.increaseTime = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function increaseTime(client, { seconds }) {
    return await client.request({
        method: 'evm_increaseTime',
        params: [(0, toHex_js_1.numberToHex)(seconds)],
    });
}
exports.increaseTime = increaseTime;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/inspectTxpool.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/inspectTxpool.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inspectTxpool = void 0;
async function inspectTxpool(client) {
    return await client.request({
        method: 'txpool_inspect',
    });
}
exports.inspectTxpool = inspectTxpool;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/loadState.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/loadState.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadState = void 0;
async function loadState(client, { state }) {
    await client.request({
        method: `${client.mode}_loadState`,
        params: [state],
    });
}
exports.loadState = loadState;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/mine.js":
/*!*********************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/mine.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mine = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function mine(client, { blocks, interval }) {
    if (client.mode === 'ganache')
        await client.request({
            method: 'evm_mine',
            params: [{ blocks: (0, toHex_js_1.numberToHex)(blocks) }],
        });
    else
        await client.request({
            method: `${client.mode}_mine`,
            params: [(0, toHex_js_1.numberToHex)(blocks), (0, toHex_js_1.numberToHex)(interval || 0)],
        });
}
exports.mine = mine;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeBlockTimestampInterval = void 0;
async function removeBlockTimestampInterval(client) {
    await client.request({
        method: `${client.mode}_removeBlockTimestampInterval`,
    });
}
exports.removeBlockTimestampInterval = removeBlockTimestampInterval;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/reset.js":
/*!**********************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/reset.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reset = void 0;
async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
    await client.request({
        method: `${client.mode}_reset`,
        params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }],
    });
}
exports.reset = reset;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/revert.js":
/*!***********************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/revert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.revert = void 0;
async function revert(client, { id }) {
    await client.request({
        method: 'evm_revert',
        params: [id],
    });
}
exports.revert = revert;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendUnsignedTransaction = void 0;
const extract_js_1 = __webpack_require__(/*! ../../utils/formatters/extract.js */ "../../node_modules/viem/_cjs/utils/formatters/extract.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
async function sendUnsignedTransaction(client, args) {
    const { accessList, data, from, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
    const request = format({
        ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
        accessList,
        data,
        from,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
    });
    const hash = await client.request({
        method: 'eth_sendUnsignedTransaction',
        params: [request],
    });
    return hash;
}
exports.sendUnsignedTransaction = sendUnsignedTransaction;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setAutomine.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setAutomine.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setAutomine = void 0;
async function setAutomine(client, enabled) {
    if (client.mode === 'ganache') {
        if (enabled)
            await client.request({ method: 'miner_start' });
        else
            await client.request({ method: 'miner_stop' });
    }
    else
        await client.request({
            method: 'evm_setAutomine',
            params: [enabled],
        });
}
exports.setAutomine = setAutomine;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setBalance.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setBalance.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setBalance = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setBalance(client, { address, value }) {
    if (client.mode === 'ganache')
        await client.request({
            method: 'evm_setAccountBalance',
            params: [address, (0, toHex_js_1.numberToHex)(value)],
        });
    else
        await client.request({
            method: `${client.mode}_setBalance`,
            params: [address, (0, toHex_js_1.numberToHex)(value)],
        });
}
exports.setBalance = setBalance;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setBlockGasLimit.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setBlockGasLimit.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setBlockGasLimit = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setBlockGasLimit(client, { gasLimit }) {
    await client.request({
        method: 'evm_setBlockGasLimit',
        params: [(0, toHex_js_1.numberToHex)(gasLimit)],
    });
}
exports.setBlockGasLimit = setBlockGasLimit;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setBlockTimestampInterval = void 0;
async function setBlockTimestampInterval(client, { interval }) {
    const interval_ = (() => {
        if (client.mode === 'hardhat')
            return interval * 1000;
        return interval;
    })();
    await client.request({
        method: `${client.mode}_setBlockTimestampInterval`,
        params: [interval_],
    });
}
exports.setBlockTimestampInterval = setBlockTimestampInterval;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setCode.js":
/*!************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setCode.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setCode = void 0;
async function setCode(client, { address, bytecode }) {
    await client.request({
        method: `${client.mode}_setCode`,
        params: [address, bytecode],
    });
}
exports.setCode = setCode;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setCoinbase.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setCoinbase.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setCoinbase = void 0;
async function setCoinbase(client, { address }) {
    await client.request({
        method: `${client.mode}_setCoinbase`,
        params: [address],
    });
}
exports.setCoinbase = setCoinbase;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setIntervalMining.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setIntervalMining.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setIntervalMining = void 0;
async function setIntervalMining(client, { interval }) {
    const interval_ = (() => {
        if (client.mode === 'hardhat')
            return interval * 1000;
        return interval;
    })();
    await client.request({
        method: 'evm_setIntervalMining',
        params: [interval_],
    });
}
exports.setIntervalMining = setIntervalMining;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setLoggingEnabled.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setLoggingEnabled.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setLoggingEnabled = void 0;
async function setLoggingEnabled(client, enabled) {
    await client.request({
        method: `${client.mode}_setLoggingEnabled`,
        params: [enabled],
    });
}
exports.setLoggingEnabled = setLoggingEnabled;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setMinGasPrice.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setMinGasPrice.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setMinGasPrice = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setMinGasPrice(client, { gasPrice }) {
    await client.request({
        method: `${client.mode}_setMinGasPrice`,
        params: [(0, toHex_js_1.numberToHex)(gasPrice)],
    });
}
exports.setMinGasPrice = setMinGasPrice;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setNextBlockBaseFeePerGas = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
    await client.request({
        method: `${client.mode}_setNextBlockBaseFeePerGas`,
        params: [(0, toHex_js_1.numberToHex)(baseFeePerGas)],
    });
}
exports.setNextBlockBaseFeePerGas = setNextBlockBaseFeePerGas;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setNextBlockTimestamp = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setNextBlockTimestamp(client, { timestamp }) {
    await client.request({
        method: 'evm_setNextBlockTimestamp',
        params: [(0, toHex_js_1.numberToHex)(timestamp)],
    });
}
exports.setNextBlockTimestamp = setNextBlockTimestamp;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setNonce.js":
/*!*************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setNonce.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setNonce = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setNonce(client, { address, nonce }) {
    await client.request({
        method: `${client.mode}_setNonce`,
        params: [address, (0, toHex_js_1.numberToHex)(nonce)],
    });
}
exports.setNonce = setNonce;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setRpcUrl.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setRpcUrl.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setRpcUrl = void 0;
async function setRpcUrl(client, jsonRpcUrl) {
    await client.request({
        method: `${client.mode}_setRpcUrl`,
        params: [jsonRpcUrl],
    });
}
exports.setRpcUrl = setRpcUrl;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/setStorageAt.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/setStorageAt.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setStorageAt = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setStorageAt(client, { address, index, value }) {
    await client.request({
        method: `${client.mode}_setStorageAt`,
        params: [
            address,
            typeof index === 'number' ? (0, toHex_js_1.numberToHex)(index) : index,
            value,
        ],
    });
}
exports.setStorageAt = setStorageAt;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/snapshot.js":
/*!*************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/snapshot.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.snapshot = void 0;
async function snapshot(client) {
    return await client.request({
        method: 'evm_snapshot',
    });
}
exports.snapshot = snapshot;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stopImpersonatingAccount = void 0;
async function stopImpersonatingAccount(client, { address }) {
    await client.request({
        method: `${client.mode}_stopImpersonatingAccount`,
        params: [address],
    });
}
exports.stopImpersonatingAccount = stopImpersonatingAccount;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/addChain.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/addChain.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addChain = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function addChain(client, { chain }) {
    const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
    await client.request({
        method: 'wallet_addEthereumChain',
        params: [
            {
                chainId: (0, toHex_js_1.numberToHex)(id),
                chainName: name,
                nativeCurrency,
                rpcUrls: rpcUrls.default.http,
                blockExplorerUrls: blockExplorers
                    ? Object.values(blockExplorers).map(({ url }) => url)
                    : undefined,
            },
        ],
    });
}
exports.addChain = addChain;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/deployContract.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/deployContract.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deployContract = void 0;
const encodeDeployData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeDeployData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeDeployData.js");
const sendTransaction_js_1 = __webpack_require__(/*! ./sendTransaction.js */ "../../node_modules/viem/_cjs/actions/wallet/sendTransaction.js");
function deployContract(walletClient, { abi, args, bytecode, ...request }) {
    const calldata = (0, encodeDeployData_js_1.encodeDeployData)({
        abi,
        args,
        bytecode,
    });
    return (0, sendTransaction_js_1.sendTransaction)(walletClient, {
        ...request,
        data: calldata,
    });
}
exports.deployContract = deployContract;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/getAddresses.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/getAddresses.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAddresses = void 0;
const getAddress_js_1 = __webpack_require__(/*! ../../utils/address/getAddress.js */ "../../node_modules/viem/_cjs/utils/address/getAddress.js");
async function getAddresses(client) {
    if (client.account?.type === 'local')
        return [client.account.address];
    const addresses = await client.request({ method: 'eth_accounts' });
    return addresses.map((address) => (0, getAddress_js_1.checksumAddress)(address));
}
exports.getAddresses = getAddresses;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/getPermissions.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/getPermissions.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPermissions = void 0;
async function getPermissions(client) {
    const permissions = await client.request({ method: 'wallet_getPermissions' });
    return permissions;
}
exports.getPermissions = getPermissions;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareTransactionRequest = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const estimateFeesPerGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateFeesPerGas.js */ "../../node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js");
const estimateGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateGas.js */ "../../node_modules/viem/_cjs/actions/public/estimateGas.js");
const getBlock_js_1 = __webpack_require__(/*! ../../actions/public/getBlock.js */ "../../node_modules/viem/_cjs/actions/public/getBlock.js");
const getTransactionCount_js_1 = __webpack_require__(/*! ../../actions/public/getTransactionCount.js */ "../../node_modules/viem/_cjs/actions/public/getTransactionCount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "../../node_modules/viem/_cjs/errors/account.js");
const fee_js_1 = __webpack_require__(/*! ../../errors/fee.js */ "../../node_modules/viem/_cjs/errors/fee.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "../../node_modules/viem/_cjs/utils/transaction/assertRequest.js");
const getTransactionType_js_1 = __webpack_require__(/*! ../../utils/transaction/getTransactionType.js */ "../../node_modules/viem/_cjs/utils/transaction/getTransactionType.js");
async function prepareTransactionRequest(client, args) {
    const { account: account_ = client.account, chain, gas, nonce, type } = args;
    if (!account_)
        throw new account_js_1.AccountNotFoundError();
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    const block = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({ blockTag: 'latest' });
    const request = { ...args, from: account.address };
    if (typeof nonce === 'undefined')
        request.nonce = await (0, getAction_js_1.getAction)(client, getTransactionCount_js_1.getTransactionCount, 'getTransactionCount')({
            address: account.address,
            blockTag: 'pending',
        });
    if (typeof type === 'undefined') {
        try {
            request.type = (0, getTransactionType_js_1.getTransactionType)(request);
        }
        catch {
            request.type =
                typeof block.baseFeePerGas === 'bigint' ? 'eip1559' : 'legacy';
        }
    }
    if (request.type === 'eip1559') {
        const { maxFeePerGas, maxPriorityFeePerGas } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
            block,
            chain,
            request: request,
        });
        if (typeof args.maxPriorityFeePerGas === 'undefined' &&
            args.maxFeePerGas &&
            args.maxFeePerGas < maxPriorityFeePerGas)
            throw new fee_js_1.MaxFeePerGasTooLowError({
                maxPriorityFeePerGas,
            });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
    }
    else {
        if (typeof args.maxFeePerGas !== 'undefined' ||
            typeof args.maxPriorityFeePerGas !== 'undefined')
            throw new fee_js_1.Eip1559FeesNotSupportedError();
        const { gasPrice: gasPrice_ } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
            block,
            chain,
            request: request,
            type: 'legacy',
        });
        request.gasPrice = gasPrice_;
    }
    if (typeof gas === 'undefined')
        request.gas = await (0, getAction_js_1.getAction)(client, estimateGas_js_1.estimateGas, 'estimateGas')({
            ...request,
            account: { address: account.address, type: 'json-rpc' },
        });
    (0, assertRequest_js_1.assertRequest)(request);
    return request;
}
exports.prepareTransactionRequest = prepareTransactionRequest;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/requestAddresses.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/requestAddresses.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.requestAddresses = void 0;
const getAddress_js_1 = __webpack_require__(/*! ../../utils/address/getAddress.js */ "../../node_modules/viem/_cjs/utils/address/getAddress.js");
async function requestAddresses(client) {
    const addresses = await client.request({ method: 'eth_requestAccounts' });
    return addresses.map((address) => (0, getAddress_js_1.getAddress)(address));
}
exports.requestAddresses = requestAddresses;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/requestPermissions.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/requestPermissions.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.requestPermissions = void 0;
async function requestPermissions(client, permissions) {
    return client.request({
        method: 'wallet_requestPermissions',
        params: [permissions],
    });
}
exports.requestPermissions = requestPermissions;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendRawTransaction = void 0;
async function sendRawTransaction(client, { serializedTransaction }) {
    return client.request({
        method: 'eth_sendRawTransaction',
        params: [serializedTransaction],
    });
}
exports.sendRawTransaction = sendRawTransaction;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/sendTransaction.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/sendTransaction.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendTransaction = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "../../node_modules/viem/_cjs/errors/account.js");
const assertCurrentChain_js_1 = __webpack_require__(/*! ../../utils/chain/assertCurrentChain.js */ "../../node_modules/viem/_cjs/utils/chain/assertCurrentChain.js");
const getTransactionError_js_1 = __webpack_require__(/*! ../../utils/errors/getTransactionError.js */ "../../node_modules/viem/_cjs/utils/errors/getTransactionError.js");
const extract_js_1 = __webpack_require__(/*! ../../utils/formatters/extract.js */ "../../node_modules/viem/_cjs/utils/formatters/extract.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "../../node_modules/viem/_cjs/utils/transaction/assertRequest.js");
const getChainId_js_1 = __webpack_require__(/*! ../public/getChainId.js */ "../../node_modules/viem/_cjs/actions/public/getChainId.js");
const prepareTransactionRequest_js_1 = __webpack_require__(/*! ./prepareTransactionRequest.js */ "../../node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js");
const sendRawTransaction_js_1 = __webpack_require__(/*! ./sendRawTransaction.js */ "../../node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js");
async function sendTransaction(client, args) {
    const { account: account_ = client.account, chain = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/actions/wallet/sendTransaction',
        });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    try {
        (0, assertRequest_js_1.assertRequest)(args);
        let chainId;
        if (chain !== null) {
            chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, 'getChainId')({});
            (0, assertCurrentChain_js_1.assertCurrentChain)({
                currentChainId: chainId,
                chain,
            });
        }
        if (account.type === 'local') {
            const request = await (0, getAction_js_1.getAction)(client, prepareTransactionRequest_js_1.prepareTransactionRequest, 'prepareTransactionRequest')({
                account,
                accessList,
                chain,
                data,
                gas,
                gasPrice,
                maxFeePerGas,
                maxPriorityFeePerGas,
                nonce,
                to,
                value,
                ...rest,
            });
            if (!chainId)
                chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, 'getChainId')({});
            const serializer = chain?.serializers?.transaction;
            const serializedTransaction = (await account.signTransaction({
                ...request,
                chainId,
            }, { serializer }));
            return await (0, getAction_js_1.getAction)(client, sendRawTransaction_js_1.sendRawTransaction, 'sendRawTransaction')({
                serializedTransaction,
            });
        }
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
            ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
            accessList,
            data,
            from: account.address,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
        });
        return await client.request({
            method: 'eth_sendTransaction',
            params: [request],
        });
    }
    catch (err) {
        throw (0, getTransactionError_js_1.getTransactionError)(err, {
            ...args,
            account,
            chain: args.chain || undefined,
        });
    }
}
exports.sendTransaction = sendTransaction;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/signMessage.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/signMessage.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signMessage = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "../../node_modules/viem/_cjs/errors/account.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function signMessage(client, { account: account_ = client.account, message, }) {
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/actions/wallet/signMessage',
        });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    if (account.type === 'local')
        return account.signMessage({ message });
    const message_ = (() => {
        if (typeof message === 'string')
            return (0, toHex_js_1.stringToHex)(message);
        if (message.raw instanceof Uint8Array)
            return (0, toHex_js_1.toHex)(message.raw);
        return message.raw;
    })();
    return client.request({
        method: 'personal_sign',
        params: [message_, account.address],
    });
}
exports.signMessage = signMessage;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/signTransaction.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/signTransaction.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signTransaction = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "../../node_modules/viem/_cjs/errors/account.js");
const assertCurrentChain_js_1 = __webpack_require__(/*! ../../utils/chain/assertCurrentChain.js */ "../../node_modules/viem/_cjs/utils/chain/assertCurrentChain.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const index_js_1 = __webpack_require__(/*! ../../utils/index.js */ "../../node_modules/viem/_cjs/utils/index.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "../../node_modules/viem/_cjs/utils/transaction/assertRequest.js");
const getChainId_js_1 = __webpack_require__(/*! ../public/getChainId.js */ "../../node_modules/viem/_cjs/actions/public/getChainId.js");
async function signTransaction(client, args) {
    const { account: account_ = client.account, chain = client.chain, ...transaction } = args;
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/actions/wallet/signTransaction',
        });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    (0, assertRequest_js_1.assertRequest)({
        account,
        ...args,
    });
    const chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, 'getChainId')({});
    if (chain !== null)
        (0, assertCurrentChain_js_1.assertCurrentChain)({
            currentChainId: chainId,
            chain,
        });
    const formatters = chain?.formatters || client.chain?.formatters;
    const format = formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
    if (account.type === 'local')
        return account.signTransaction({
            ...transaction,
            chainId,
        }, { serializer: client.chain?.serializers?.transaction });
    return await client.request({
        method: 'eth_signTransaction',
        params: [
            {
                ...format(transaction),
                chainId: (0, index_js_1.numberToHex)(chainId),
                from: account.address,
            },
        ],
    });
}
exports.signTransaction = signTransaction;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/signTypedData.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/signTypedData.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signTypedData = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "../../node_modules/viem/_cjs/errors/account.js");
const isHex_js_1 = __webpack_require__(/*! ../../utils/data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
const typedData_js_1 = __webpack_require__(/*! ../../utils/typedData.js */ "../../node_modules/viem/_cjs/utils/typedData.js");
async function signTypedData(client, { account: account_ = client.account, domain, message, primaryType, types: types_, }) {
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/actions/wallet/signTypedData',
        });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    const types = {
        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
        ...types_,
    };
    (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types,
    });
    if (account.type === 'local')
        return account.signTypedData({
            domain,
            primaryType,
            types,
            message,
        });
    const typedData = (0, stringify_js_1.stringify)({ domain: domain ?? {}, primaryType, types, message }, (_, value) => ((0, isHex_js_1.isHex)(value) ? value.toLowerCase() : value));
    return client.request({
        method: 'eth_signTypedData_v4',
        params: [account.address, typedData],
    });
}
exports.signTypedData = signTypedData;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/switchChain.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/switchChain.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.switchChain = void 0;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function switchChain(client, { id }) {
    await client.request({
        method: 'wallet_switchEthereumChain',
        params: [
            {
                chainId: (0, toHex_js_1.numberToHex)(id),
            },
        ],
    });
}
exports.switchChain = switchChain;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/watchAsset.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/watchAsset.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchAsset = void 0;
async function watchAsset(client, params) {
    const added = await client.request({
        method: 'wallet_watchAsset',
        params,
    });
    return added;
}
exports.watchAsset = watchAsset;


/***/ }),

/***/ "../../node_modules/viem/_cjs/actions/wallet/writeContract.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/actions/wallet/writeContract.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeContract = void 0;
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "../../node_modules/viem/_cjs/utils/getAction.js");
const sendTransaction_js_1 = __webpack_require__(/*! ./sendTransaction.js */ "../../node_modules/viem/_cjs/actions/wallet/sendTransaction.js");
async function writeContract(client, { abi, address, args, dataSuffix, functionName, ...request }) {
    const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName,
    });
    const hash = await (0, getAction_js_1.getAction)(client, sendTransaction_js_1.sendTransaction, 'sendTransaction')({
        data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
        to: address,
        ...request,
    });
    return hash;
}
exports.writeContract = writeContract;


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/celo/formatters.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/celo/formatters.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formattersCelo = void 0;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const block_js_1 = __webpack_require__(/*! ../../utils/formatters/block.js */ "../../node_modules/viem/_cjs/utils/formatters/block.js");
const transaction_js_1 = __webpack_require__(/*! ../../utils/formatters/transaction.js */ "../../node_modules/viem/_cjs/utils/formatters/transaction.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/viem/_cjs/chains/celo/utils.js");
exports.formattersCelo = {
    block: (0, block_js_1.defineBlock)({
        exclude: ['difficulty', 'gasLimit', 'mixHash', 'nonce', 'uncles'],
        format(args) {
            const transactions = args.transactions?.map((transaction) => {
                if (typeof transaction === 'string')
                    return transaction;
                return {
                    ...(0, transaction_js_1.formatTransaction)(transaction),
                    feeCurrency: transaction.feeCurrency,
                    ...(transaction.type !== '0x7b'
                        ? {
                            gatewayFee: transaction.gatewayFee
                                ? (0, fromHex_js_1.hexToBigInt)(transaction.gatewayFee)
                                : null,
                            gatewayFeeRecipient: transaction.gatewayFeeRecipient || null,
                        }
                        : {}),
                };
            });
            return {
                randomness: args.randomness,
                transactions,
            };
        },
    }),
    transaction: (0, transaction_js_1.defineTransaction)({
        format(args) {
            const transaction = { feeCurrency: args.feeCurrency };
            if (args.type === '0x7b')
                transaction.type = 'cip64';
            else {
                if (args.type === '0x7c')
                    transaction.type = 'cip42';
                transaction.gatewayFee = args.gatewayFee
                    ? (0, fromHex_js_1.hexToBigInt)(args.gatewayFee)
                    : null;
                transaction.gatewayFeeRecipient = args.gatewayFeeRecipient;
            }
            return transaction;
        },
    }),
    transactionRequest: (0, transactionRequest_js_1.defineTransactionRequest)({
        format(args) {
            const request = {
                feeCurrency: args.feeCurrency,
            };
            if ((0, utils_js_1.isCIP64)(args))
                request.type = '0x7b';
            else {
                if ((0, utils_js_1.isCIP42)(args))
                    request.type = '0x7c';
                request.gatewayFee =
                    typeof args.gatewayFee !== 'undefined'
                        ? (0, toHex_js_1.numberToHex)(args.gatewayFee)
                        : undefined;
                request.gatewayFeeRecipient = args.gatewayFeeRecipient;
            }
            return request;
        },
    }),
};


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/celo/serializers.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/celo/serializers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertTransactionCIP64 = exports.assertTransactionCIP42 = exports.serializersCelo = exports.serializeTransactionCelo = void 0;
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const chain_js_1 = __webpack_require__(/*! ../../errors/chain.js */ "../../node_modules/viem/_cjs/errors/chain.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "../../node_modules/viem/_cjs/errors/node.js");
const isAddress_js_1 = __webpack_require__(/*! ../../utils/address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
const concat_js_1 = __webpack_require__(/*! ../../utils/data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const trim_js_1 = __webpack_require__(/*! ../../utils/data/trim.js */ "../../node_modules/viem/_cjs/utils/data/trim.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const toRlp_js_1 = __webpack_require__(/*! ../../utils/encoding/toRlp.js */ "../../node_modules/viem/_cjs/utils/encoding/toRlp.js");
const serializeAccessList_js_1 = __webpack_require__(/*! ../../utils/transaction/serializeAccessList.js */ "../../node_modules/viem/_cjs/utils/transaction/serializeAccessList.js");
const serializeTransaction_js_1 = __webpack_require__(/*! ../../utils/transaction/serializeTransaction.js */ "../../node_modules/viem/_cjs/utils/transaction/serializeTransaction.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/viem/_cjs/chains/celo/utils.js");
const serializeTransactionCelo = (tx, signature) => {
    if ((0, utils_js_1.isCIP64)(tx))
        return serializeTransactionCIP64(tx, signature);
    if ((0, utils_js_1.isCIP42)(tx))
        return serializeTransactionCIP42(tx, signature);
    return (0, serializeTransaction_js_1.serializeTransaction)(tx, signature);
};
exports.serializeTransactionCelo = serializeTransactionCelo;
exports.serializersCelo = {
    transaction: exports.serializeTransactionCelo,
};
function serializeTransactionCIP42(transaction, signature) {
    assertTransactionCIP42(transaction);
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, gatewayFeeRecipient, gatewayFee, data, } = transaction;
    const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : '0x',
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : '0x',
        gas ? (0, toHex_js_1.toHex)(gas) : '0x',
        feeCurrency ?? '0x',
        gatewayFeeRecipient ?? '0x',
        gatewayFee ? (0, toHex_js_1.toHex)(gatewayFee) : '0x',
        to ?? '0x',
        value ? (0, toHex_js_1.toHex)(value) : '0x',
        data ?? '0x',
        (0, serializeAccessList_js_1.serializeAccessList)(accessList),
    ];
    if (signature) {
        serializedTransaction.push(signature.v === 27n ? '0x' : (0, toHex_js_1.toHex)(1), (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
    }
    return (0, concat_js_1.concatHex)([
        '0x7c',
        (0, toRlp_js_1.toRlp)(serializedTransaction),
    ]);
}
function serializeTransactionCIP64(transaction, signature) {
    assertTransactionCIP64(transaction);
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, data, } = transaction;
    const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : '0x',
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : '0x',
        gas ? (0, toHex_js_1.toHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, toHex_js_1.toHex)(value) : '0x',
        data ?? '0x',
        (0, serializeAccessList_js_1.serializeAccessList)(accessList),
        feeCurrency,
    ];
    if (signature) {
        serializedTransaction.push(signature.v === 27n ? '0x' : (0, toHex_js_1.toHex)(1), (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
    }
    return (0, concat_js_1.concatHex)([
        '0x7b',
        (0, toRlp_js_1.toRlp)(serializedTransaction),
    ]);
}
const MAX_MAX_FEE_PER_GAS = 2n ** 256n - 1n;
function assertTransactionCIP42(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, feeCurrency, gatewayFee, gatewayFeeRecipient, } = transaction;
    if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
    if (gasPrice)
        throw new base_js_1.BaseError('`gasPrice` is not a valid CIP-42 Transaction attribute.');
    if ((0, utils_js_1.isPresent)(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
    if ((0, utils_js_1.isPresent)(maxPriorityFeePerGas) &&
        (0, utils_js_1.isPresent)(maxFeePerGas) &&
        maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    if (((0, utils_js_1.isPresent)(gatewayFee) && (0, utils_js_1.isEmpty)(gatewayFeeRecipient)) ||
        ((0, utils_js_1.isPresent)(gatewayFeeRecipient) && (0, utils_js_1.isEmpty)(gatewayFee))) {
        throw new base_js_1.BaseError('`gatewayFee` and `gatewayFeeRecipient` must be provided together.');
    }
    if ((0, utils_js_1.isPresent)(feeCurrency) && !(0, isAddress_js_1.isAddress)(feeCurrency)) {
        throw new base_js_1.BaseError('`feeCurrency` MUST be a token address for CIP-42 transactions.');
    }
    if ((0, utils_js_1.isPresent)(gatewayFeeRecipient) && !(0, isAddress_js_1.isAddress)(gatewayFeeRecipient)) {
        throw new address_js_1.InvalidAddressError(gatewayFeeRecipient);
    }
    if ((0, utils_js_1.isEmpty)(feeCurrency) && (0, utils_js_1.isEmpty)(gatewayFeeRecipient)) {
        throw new base_js_1.BaseError('Either `feeCurrency` or `gatewayFeeRecipient` must be provided for CIP-42 transactions.');
    }
}
exports.assertTransactionCIP42 = assertTransactionCIP42;
function assertTransactionCIP64(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, feeCurrency, } = transaction;
    if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
    if (gasPrice)
        throw new base_js_1.BaseError('`gasPrice` is not a valid CIP-64 Transaction attribute.');
    if ((0, utils_js_1.isPresent)(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
    if ((0, utils_js_1.isPresent)(maxPriorityFeePerGas) &&
        (0, utils_js_1.isPresent)(maxFeePerGas) &&
        maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    if ((0, utils_js_1.isPresent)(feeCurrency) && !(0, isAddress_js_1.isAddress)(feeCurrency)) {
        throw new base_js_1.BaseError('`feeCurrency` MUST be a token address for CIP-64 transactions.');
    }
    if ((0, utils_js_1.isEmpty)(feeCurrency)) {
        throw new base_js_1.BaseError('`feeCurrency` must be provided for CIP-64 transactions.');
    }
}
exports.assertTransactionCIP64 = assertTransactionCIP64;


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/celo/utils.js":
/*!*********************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/celo/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCIP64 = exports.isCIP42 = exports.isEIP1559 = exports.isPresent = exports.isEmpty = void 0;
const trim_js_1 = __webpack_require__(/*! ../../utils/data/trim.js */ "../../node_modules/viem/_cjs/utils/data/trim.js");
function isEmpty(value) {
    return (value === 0 ||
        value === 0n ||
        value === undefined ||
        value === null ||
        value === '0' ||
        value === '' ||
        (typeof value === 'string' &&
            ((0, trim_js_1.trim)(value).toLowerCase() === '0x' ||
                (0, trim_js_1.trim)(value).toLowerCase() === '0x00')));
}
exports.isEmpty = isEmpty;
function isPresent(value) {
    return !isEmpty(value);
}
exports.isPresent = isPresent;
function isEIP1559(transaction) {
    return (isPresent(transaction.maxFeePerGas) &&
        isPresent(transaction.maxPriorityFeePerGas));
}
exports.isEIP1559 = isEIP1559;
function isCIP42(transaction) {
    if (transaction.type === 'cip42') {
        return true;
    }
    return (isEIP1559(transaction) &&
        (isPresent(transaction.feeCurrency) ||
            isPresent(transaction.gatewayFeeRecipient) ||
            isPresent(transaction.gatewayFee)));
}
exports.isCIP42 = isCIP42;
function isCIP64(transaction) {
    if (transaction.type === 'cip64') {
        return true;
    }
    return (isEIP1559(transaction) &&
        isPresent(transaction.feeCurrency) &&
        isEmpty(transaction.gatewayFee) &&
        isEmpty(transaction.gatewayFeeRecipient));
}
exports.isCIP64 = isCIP64;


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/acala.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/acala.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.acala = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.acala = (0, defineChain_js_1.defineChain)({
    id: 787,
    name: 'Acala',
    network: 'acala',
    nativeCurrency: {
        name: 'Acala',
        symbol: 'ACA',
        decimals: 18,
    },
    rpcUrls: {
        public: {
            http: ['https://eth-rpc-acala.aca-api.network'],
            webSocket: ['wss://eth-rpc-acala.aca-api.network'],
        },
        default: {
            http: ['https://eth-rpc-acala.aca-api.network'],
            webSocket: ['wss://eth-rpc-acala.aca-api.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Acala Blockscout',
            url: 'https://blockscout.acala.network',
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/arbitrum.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/arbitrum.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arbitrum = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.arbitrum = (0, defineChain_js_1.defineChain)({
    id: 42161,
    name: 'Arbitrum One',
    network: 'arbitrum',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://arb-mainnet.g.alchemy.com/v2'],
            webSocket: ['wss://arb-mainnet.g.alchemy.com/v2'],
        },
        infura: {
            http: ['https://arbitrum-mainnet.infura.io/v3'],
            webSocket: ['wss://arbitrum-mainnet.infura.io/ws/v3'],
        },
        default: {
            http: ['https://arb1.arbitrum.io/rpc'],
        },
        public: {
            http: ['https://arb1.arbitrum.io/rpc'],
        },
    },
    blockExplorers: {
        etherscan: { name: 'Arbiscan', url: 'https://arbiscan.io' },
        default: { name: 'Arbiscan', url: 'https://arbiscan.io' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 7654707,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/arbitrumGoerli.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/arbitrumGoerli.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arbitrumGoerli = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.arbitrumGoerli = (0, defineChain_js_1.defineChain)({
    id: 421613,
    name: 'Arbitrum Goerli',
    network: 'arbitrum-goerli',
    nativeCurrency: {
        name: 'Arbitrum Goerli Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    rpcUrls: {
        alchemy: {
            http: ['https://arb-goerli.g.alchemy.com/v2'],
            webSocket: ['wss://arb-goerli.g.alchemy.com/v2'],
        },
        infura: {
            http: ['https://arbitrum-goerli.infura.io/v3'],
            webSocket: ['wss://arbitrum-goerli.infura.io/ws/v3'],
        },
        default: {
            http: ['https://goerli-rollup.arbitrum.io/rpc'],
        },
        public: {
            http: ['https://goerli-rollup.arbitrum.io/rpc'],
        },
    },
    blockExplorers: {
        etherscan: { name: 'Arbiscan', url: 'https://goerli.arbiscan.io' },
        default: { name: 'Arbiscan', url: 'https://goerli.arbiscan.io' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 88114,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/arbitrumNova.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/arbitrumNova.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arbitrumNova = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.arbitrumNova = (0, defineChain_js_1.defineChain)({
    id: 42170,
    name: 'Arbitrum Nova',
    network: 'arbitrum-nova',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        blast: {
            http: ['https://arbitrum-nova.public.blastapi.io'],
            webSocket: ['wss://arbitrum-nova.public.blastapi.io'],
        },
        default: {
            http: ['https://nova.arbitrum.io/rpc'],
        },
        public: {
            http: ['https://nova.arbitrum.io/rpc'],
        },
    },
    blockExplorers: {
        etherscan: { name: 'Arbiscan', url: 'https://nova.arbiscan.io' },
        blockScout: {
            name: 'BlockScout',
            url: 'https://nova-explorer.arbitrum.io/',
        },
        default: { name: 'Arbiscan', url: 'https://nova.arbiscan.io' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 1746963,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/arbitrumSepolia.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/arbitrumSepolia.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arbitrumSepolia = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.arbitrumSepolia = (0, defineChain_js_1.defineChain)({
    id: 421614,
    name: 'Arbitrum Sepolia',
    network: 'arbitrum-sepolia',
    nativeCurrency: {
        name: 'Arbitrum Sepolia Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    rpcUrls: {
        alchemy: {
            http: ['https://arb-sepolia.g.alchemy.com/v2'],
            webSocket: ['wss://arb-sepolia.g.alchemy.com/v2'],
        },
        default: {
            http: ['https://sepolia-rollup.arbitrum.io/rpc'],
        },
        public: {
            http: ['https://sepolia-rollup.arbitrum.io/rpc'],
        },
    },
    blockExplorers: {
        etherscan: { name: 'Arbiscan', url: 'https://sepolia.arbiscan.io' },
        default: { name: 'Arbiscan', url: 'https://sepolia.arbiscan.io' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 81930,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/astar.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/astar.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.astar = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.astar = (0, defineChain_js_1.defineChain)({
    id: 592,
    name: 'Astar',
    network: 'astar-mainnet',
    nativeCurrency: {
        name: 'Astar',
        symbol: 'ASTR',
        decimals: 18,
    },
    rpcUrls: {
        public: { http: ['https://astar.api.onfinality.io/public'] },
        default: { http: ['https://astar.api.onfinality.io/public'] },
    },
    blockExplorers: {
        default: { name: 'Astar Subscan', url: 'https://astar.subscan.io' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 761794,
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/astarZkatana.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/astarZkatana.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.astarZkatana = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.astarZkatana = (0, defineChain_js_1.defineChain)({
    id: 1261120,
    name: 'Astar zkEVM Testnet zKatana',
    network: 'zKatana',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: [
                'https://rpc.zkatana.gelato.digital',
                'https://rpc.startale.com/zkatana',
            ],
        },
        public: {
            http: [
                'https://rpc.zkatana.gelato.digital',
                'https://rpc.startale.com/zkatana',
            ],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'Blockscout zKatana chain explorer',
            url: 'https://zkatana.blockscout.com',
        },
        default: {
            name: 'zKatana Explorer',
            url: 'https://zkatana.explorer.startale.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 31317,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/aurora.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/aurora.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aurora = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.aurora = (0, defineChain_js_1.defineChain)({
    id: 1313161554,
    name: 'Aurora',
    network: 'aurora',
    nativeCurrency: {
        decimals: 18,
        name: 'Ether',
        symbol: 'ETH',
    },
    rpcUrls: {
        infura: { http: ['https://aurora-mainnet.infura.io/v3'] },
        default: { http: ['https://mainnet.aurora.dev'] },
        public: { http: ['https://mainnet.aurora.dev'] },
    },
    blockExplorers: {
        etherscan: { name: 'Aurorascan', url: 'https://aurorascan.dev' },
        default: { name: 'Aurorascan', url: 'https://aurorascan.dev' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 62907816,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/auroraTestnet.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/auroraTestnet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.auroraTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.auroraTestnet = (0, defineChain_js_1.defineChain)({
    id: 1313161555,
    name: 'Aurora Testnet',
    network: 'aurora-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Ether',
        symbol: 'ETH',
    },
    rpcUrls: {
        infura: { http: ['https://aurora-testnet.infura.io/v3'] },
        default: { http: ['https://testnet.aurora.dev'] },
        public: { http: ['https://testnet.aurora.dev'] },
    },
    blockExplorers: {
        etherscan: { name: 'Aurorascan', url: 'https://testnet.aurorascan.dev' },
        default: { name: 'Aurorascan', url: 'https://testnet.aurorascan.dev' },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/avalanche.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/avalanche.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.avalanche = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.avalanche = (0, defineChain_js_1.defineChain)({
    id: 43114,
    name: 'Avalanche',
    network: 'avalanche',
    nativeCurrency: {
        decimals: 18,
        name: 'Avalanche',
        symbol: 'AVAX',
    },
    rpcUrls: {
        default: { http: ['https://api.avax.network/ext/bc/C/rpc'] },
        public: { http: ['https://api.avax.network/ext/bc/C/rpc'] },
    },
    blockExplorers: {
        etherscan: { name: 'SnowTrace', url: 'https://snowtrace.io' },
        default: { name: 'SnowTrace', url: 'https://snowtrace.io' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 11907934,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/avalancheFuji.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/avalancheFuji.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.avalancheFuji = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.avalancheFuji = (0, defineChain_js_1.defineChain)({
    id: 43113,
    name: 'Avalanche Fuji',
    network: 'avalanche-fuji',
    nativeCurrency: {
        decimals: 18,
        name: 'Avalanche Fuji',
        symbol: 'AVAX',
    },
    rpcUrls: {
        default: { http: ['https://api.avax-test.network/ext/bc/C/rpc'] },
        public: { http: ['https://api.avax-test.network/ext/bc/C/rpc'] },
    },
    blockExplorers: {
        etherscan: { name: 'SnowTrace', url: 'https://testnet.snowtrace.io' },
        default: { name: 'SnowTrace', url: 'https://testnet.snowtrace.io' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 7096959,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/bahamut.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/bahamut.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bahamut = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.bahamut = (0, defineChain_js_1.defineChain)({
    id: 5165,
    network: 'bahamut',
    name: 'Bahamut',
    nativeCurrency: { name: 'Fasttoken', symbol: 'FTN', decimals: 18 },
    rpcUrls: {
        default: {
            http: [
                'https://rpc1.bahamut.io',
                'https://bahamut.publicnode.com',
                'https://rpc2.bahamut.io',
            ],
            webSocket: [
                'wss://ws1.sahara.bahamutchain.com',
                'wss://bahamut.publicnode.com',
                'wss://ws2.sahara.bahamutchain.com',
            ],
        },
        public: {
            http: [
                'https://rpc1.bahamut.io',
                'https://bahamut.publicnode.com',
                'https://rpc2.bahamut.io',
            ],
            webSocket: [
                'wss://ws1.sahara.bahamutchain.com',
                'wss://bahamut.publicnode.com',
                'wss://ws2.sahara.bahamutchain.com',
            ],
        },
    },
    blockExplorers: {
        default: {
            name: 'Ftnscan',
            url: 'https://www.ftnscan.com',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/base.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/base.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.base = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../optimism/formatters.js */ "../../node_modules/viem/_cjs/chains/optimism/formatters.js");
exports.base = (0, defineChain_js_1.defineChain)({
    id: 8453,
    network: 'base',
    name: 'Base',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://base-mainnet.g.alchemy.com/v2'],
            webSocket: ['wss://base-mainnet.g.alchemy.com/v2'],
        },
        infura: {
            http: ['https://base-mainnet.infura.io/v3'],
            webSocket: ['wss://base-mainnet.infura.io/ws/v3'],
        },
        default: {
            http: ['https://mainnet.base.org'],
        },
        public: {
            http: ['https://mainnet.base.org'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'Basescout',
            url: 'https://base.blockscout.com',
        },
        default: {
            name: 'Basescan',
            url: 'https://basescan.org',
        },
        etherscan: {
            name: 'Basescan',
            url: 'https://basescan.org',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 5022,
        },
    },
}, {
    formatters: formatters_js_1.formattersOptimism,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/baseGoerli.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/baseGoerli.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.baseGoerli = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../optimism/formatters.js */ "../../node_modules/viem/_cjs/chains/optimism/formatters.js");
exports.baseGoerli = (0, defineChain_js_1.defineChain)({
    id: 84531,
    network: 'base-goerli',
    name: 'Base Goerli',
    nativeCurrency: { name: 'Goerli Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://base-goerli.g.alchemy.com/v2'],
            webSocket: ['wss://base-goerli.g.alchemy.com/v2'],
        },
        default: {
            http: ['https://goerli.base.org'],
        },
        public: {
            http: ['https://goerli.base.org'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'Basescan',
            url: 'https://goerli.basescan.org',
        },
        default: {
            name: 'Basescan',
            url: 'https://goerli.basescan.org',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 1376988,
        },
    },
    testnet: true,
    sourceId: 5,
}, {
    formatters: formatters_js_1.formattersOptimism,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/baseSepolia.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/baseSepolia.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.baseSepolia = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../optimism/formatters.js */ "../../node_modules/viem/_cjs/chains/optimism/formatters.js");
exports.baseSepolia = (0, defineChain_js_1.defineChain)({
    id: 84532,
    network: 'base-sepolia',
    name: 'Base Sepolia',
    nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://base-sepolia.g.alchemy.com/v2'],
            webSocket: ['wss://base-sepolia.g.alchemy.com/v2'],
        },
        default: {
            http: ['https://sepolia.base.org'],
        },
        public: {
            http: ['https://sepolia.base.org'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'Blockscout',
            url: 'https://base-sepolia.blockscout.com',
        },
        default: {
            name: 'Blockscout',
            url: 'https://base-sepolia.blockscout.com',
        },
    },
    testnet: true,
    sourceId: 11155111,
}, {
    formatters: formatters_js_1.formattersOptimism,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/bearNetworkChainMainnet.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/bearNetworkChainMainnet.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bearNetworkChainMainnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.bearNetworkChainMainnet = (0, defineChain_js_1.defineChain)({
    id: 641230,
    name: 'Bear Network Chain Mainnet',
    network: 'BearNetworkChainMainnet',
    nativeCurrency: {
        decimals: 18,
        name: 'BearNetworkChain',
        symbol: 'BRNKC',
    },
    rpcUrls: {
        public: { http: ['https://brnkc-mainnet.bearnetwork.net'] },
        default: { http: ['https://brnkc-mainnet.bearnetwork.net'] },
    },
    blockExplorers: {
        default: { name: 'BrnkScan', url: 'https://brnkscan.bearnetwork.net' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/bearNetworkChainTestnet.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/bearNetworkChainTestnet.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bearNetworkChainTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.bearNetworkChainTestnet = (0, defineChain_js_1.defineChain)({
    id: 751230,
    name: 'Bear Network Chain Testnet',
    network: 'BearNetworkChainTestnet',
    nativeCurrency: {
        decimals: 18,
        name: 'tBRNKC',
        symbol: 'tBRNKC',
    },
    rpcUrls: {
        public: { http: ['https://brnkc-test.bearnetwork.net'] },
        default: { http: ['https://brnkc-test.bearnetwork.net'] },
    },
    blockExplorers: {
        default: {
            name: 'BrnkTestScan',
            url: 'https://brnktest-scan.bearnetwork.net',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/bitTorrent.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/bitTorrent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bitTorrent = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.bitTorrent = (0, defineChain_js_1.defineChain)({
    id: 199,
    name: 'BitTorrent',
    network: 'bittorrent-chain-mainnet',
    nativeCurrency: { name: 'BitTorrent', symbol: 'BTT', decimals: 18 },
    rpcUrls: {
        default: { http: ['https://rpc.bittorrentchain.io'] },
        public: { http: ['https://rpc.bittorrentchain.io'] },
    },
    blockExplorers: {
        etherscan: { name: 'Bttcscan', url: 'https://bttcscan.com' },
        default: { name: 'Bttcscan', url: 'https://bttcscan.com' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/bitTorrentTestnet.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/bitTorrentTestnet.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bitTorrentTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.bitTorrentTestnet = (0, defineChain_js_1.defineChain)({
    id: 1028,
    name: 'BitTorrent Chain Testnet',
    network: 'bittorrent-chain-testnet',
    nativeCurrency: { name: 'BitTorrent', symbol: 'BTT', decimals: 18 },
    rpcUrls: {
        default: { http: ['https://testrpc.bittorrentchain.io'] },
        public: { http: ['https://testrpc.bittorrentchain.io'] },
    },
    blockExplorers: {
        etherscan: { name: 'Bttcscan', url: 'https://testnet.bttcscan.com' },
        default: { name: 'Bttcscan', url: 'https://testnet.bttcscan.com' },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/boba.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/boba.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.boba = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.boba = (0, defineChain_js_1.defineChain)({
    id: 288,
    name: 'Boba Network',
    network: 'boba',
    nativeCurrency: {
        decimals: 18,
        name: 'Boba',
        symbol: 'BOBA',
    },
    rpcUrls: {
        default: { http: ['https://mainnet.boba.network'] },
        public: { http: ['https://mainnet.boba.network'] },
    },
    blockExplorers: {
        etherscan: { name: 'BOBAScan', url: 'https://bobascan.com' },
        default: { name: 'BOBAScan', url: 'https://bobascan.com' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 446859,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/bronos.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/bronos.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bronos = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.bronos = (0, defineChain_js_1.defineChain)({
    id: 1039,
    name: 'Bronos',
    network: 'bronos',
    nativeCurrency: {
        decimals: 18,
        name: 'BRO',
        symbol: 'BRO',
    },
    rpcUrls: {
        default: { http: ['https://evm.bronos.org'] },
        public: { http: ['https://evm.bronos.org'] },
    },
    blockExplorers: {
        default: { name: 'BronoScan', url: 'https://broscan.bronos.org' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/bronosTestnet.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/bronosTestnet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bronosTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.bronosTestnet = (0, defineChain_js_1.defineChain)({
    id: 1038,
    name: 'Bronos Testnet',
    network: 'bronos-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Bronos Coin',
        symbol: 'tBRO',
    },
    rpcUrls: {
        default: { http: ['https://evm-testnet.bronos.org'] },
        public: { http: ['https://evm-testnet.bronos.org'] },
    },
    blockExplorers: {
        default: { name: 'BronoScan', url: 'https://tbroscan.bronos.org' },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/bsc.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/bsc.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bsc = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.bsc = (0, defineChain_js_1.defineChain)({
    id: 56,
    name: 'BNB Smart Chain',
    network: 'bsc',
    nativeCurrency: {
        decimals: 18,
        name: 'BNB',
        symbol: 'BNB',
    },
    rpcUrls: {
        default: { http: ['https://rpc.ankr.com/bsc'] },
        public: { http: ['https://rpc.ankr.com/bsc'] },
    },
    blockExplorers: {
        etherscan: { name: 'BscScan', url: 'https://bscscan.com' },
        default: { name: 'BscScan', url: 'https://bscscan.com' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 15921452,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/bscTestnet.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/bscTestnet.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bscTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.bscTestnet = (0, defineChain_js_1.defineChain)({
    id: 97,
    name: 'Binance Smart Chain Testnet',
    network: 'bsc-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'BNB',
        symbol: 'tBNB',
    },
    rpcUrls: {
        default: { http: ['https://data-seed-prebsc-1-s1.bnbchain.org:8545'] },
        public: { http: ['https://data-seed-prebsc-1-s1.bnbchain.org:8545'] },
    },
    blockExplorers: {
        etherscan: { name: 'BscScan', url: 'https://testnet.bscscan.com' },
        default: { name: 'BscScan', url: 'https://testnet.bscscan.com' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 17422483,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/bxn.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/bxn.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bxn = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.bxn = (0, defineChain_js_1.defineChain)({
    id: 4999,
    name: 'BlackFort Exchange Network',
    network: 'bxn',
    nativeCurrency: { name: 'BlackFort Token', symbol: 'BXN', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.blackfort.network/rpc'],
        },
        public: {
            http: ['https://mainnet.blackfort.network/rpc'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Blockscout',
            url: 'https://explorer.blackfort.network',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/bxnTestnet.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/bxnTestnet.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bxnTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.bxnTestnet = (0, defineChain_js_1.defineChain)({
    id: 4777,
    name: 'BlackFort Exchange Network Testnet',
    network: 'bxnTestnet',
    nativeCurrency: {
        name: 'BlackFort Testnet Token',
        symbol: 'TBXN',
        decimals: 18,
    },
    rpcUrls: {
        default: {
            http: ['https://testnet.blackfort.network/rpc'],
        },
        public: {
            http: ['https://testnet.blackfort.network/rpc'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Blockscout',
            url: 'https://testnet-explorer.blackfort.network',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/canto.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/canto.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.canto = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.canto = (0, defineChain_js_1.defineChain)({
    id: 7700,
    name: 'Canto',
    network: 'canto',
    nativeCurrency: {
        decimals: 18,
        name: 'Canto',
        symbol: 'CANTO',
    },
    rpcUrls: {
        default: { http: ['https://canto.gravitychain.io'] },
        public: { http: ['https://canto.gravitychain.io'] },
    },
    blockExplorers: {
        default: {
            name: 'Tuber.Build (Blockscout)',
            url: 'https://tuber.build',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 2905789,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/celo.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/celo.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.celo = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../celo/formatters.js */ "../../node_modules/viem/_cjs/chains/celo/formatters.js");
const serializers_js_1 = __webpack_require__(/*! ../celo/serializers.js */ "../../node_modules/viem/_cjs/chains/celo/serializers.js");
exports.celo = (0, defineChain_js_1.defineChain)({
    id: 42220,
    name: 'Celo',
    network: 'celo',
    nativeCurrency: {
        decimals: 18,
        name: 'CELO',
        symbol: 'CELO',
    },
    rpcUrls: {
        default: { http: ['https://forno.celo.org'] },
        infura: {
            http: ['https://celo-mainnet.infura.io/v3'],
        },
        public: {
            http: ['https://forno.celo.org'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Celo Explorer',
            url: 'https://explorer.celo.org/mainnet',
        },
        etherscan: { name: 'CeloScan', url: 'https://celoscan.io' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 13112599,
        },
    },
    testnet: false,
}, {
    formatters: formatters_js_1.formattersCelo,
    serializers: serializers_js_1.serializersCelo,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/celoAlfajores.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/celoAlfajores.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.celoAlfajores = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../celo/formatters.js */ "../../node_modules/viem/_cjs/chains/celo/formatters.js");
const serializers_js_1 = __webpack_require__(/*! ../celo/serializers.js */ "../../node_modules/viem/_cjs/chains/celo/serializers.js");
exports.celoAlfajores = (0, defineChain_js_1.defineChain)({
    id: 44787,
    name: 'Alfajores',
    network: 'celo-alfajores',
    nativeCurrency: {
        decimals: 18,
        name: 'CELO',
        symbol: 'A-CELO',
    },
    rpcUrls: {
        default: {
            http: ['https://alfajores-forno.celo-testnet.org'],
        },
        infura: {
            http: ['https://celo-alfajores.infura.io/v3'],
        },
        public: {
            http: ['https://alfajores-forno.celo-testnet.org'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Celo Explorer',
            url: 'https://explorer.celo.org/alfajores',
        },
        etherscan: { name: 'CeloScan', url: 'https://alfajores.celoscan.io/' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 14569001,
        },
    },
    testnet: true,
}, {
    formatters: formatters_js_1.formattersCelo,
    serializers: serializers_js_1.serializersCelo,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/celoCannoli.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/celoCannoli.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.celoCannoli = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../celo/formatters.js */ "../../node_modules/viem/_cjs/chains/celo/formatters.js");
const serializers_js_1 = __webpack_require__(/*! ../celo/serializers.js */ "../../node_modules/viem/_cjs/chains/celo/serializers.js");
exports.celoCannoli = (0, defineChain_js_1.defineChain)({
    id: 17323,
    name: 'Cannoli',
    network: 'celo-cannoli',
    nativeCurrency: {
        decimals: 18,
        name: 'CELO',
        symbol: 'C-CELO',
    },
    rpcUrls: {
        default: {
            http: ['https://forno.cannoli.celo-testnet.org'],
        },
        public: {
            http: ['https://forno.cannoli.celo-testnet.org'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Celo Explorer',
            url: 'https://explorer.celo.org/cannoli',
        },
    },
    contracts: {
        multicall3: {
            address: '0x5Acb0aa8BF4E8Ff0d882Ee187140713C12BF9718',
            blockCreated: 87429,
        },
    },
    testnet: true,
}, {
    formatters: formatters_js_1.formattersCelo,
    serializers: serializers_js_1.serializersCelo,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/chiliz.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/chiliz.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.chiliz = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.chiliz = (0, defineChain_js_1.defineChain)({
    id: 88888,
    name: 'Chiliz Chain',
    network: 'chiliz-chain',
    nativeCurrency: {
        decimals: 18,
        name: 'CHZ',
        symbol: 'CHZ',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.ankr.com/chiliz', 'https://chiliz.publicnode.com'],
        },
        public: {
            http: ['https://rpc.ankr.com/chiliz', 'https://chiliz.publicnode.com'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Chiliz Explorer',
            url: 'https://scan.chiliz.com',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/classic.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/classic.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.classic = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.classic = (0, defineChain_js_1.defineChain)({
    id: 61,
    name: 'Ethereum Classic',
    network: 'classic',
    nativeCurrency: {
        decimals: 18,
        name: 'ETC',
        symbol: 'ETC',
    },
    rpcUrls: {
        default: { http: ['https://etc.rivet.link'] },
        public: { http: ['https://etc.rivet.link'] },
    },
    blockExplorers: {
        default: {
            name: 'Blockscout',
            url: 'https://blockscout.com/etc/mainnet',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/confluxESpace.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/confluxESpace.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.confluxESpace = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.confluxESpace = (0, defineChain_js_1.defineChain)({
    id: 1030,
    name: 'Conflux eSpace',
    network: 'cfx-espace',
    nativeCurrency: { name: 'Conflux', symbol: 'CFX', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://evm.confluxrpc.org'],
            webSocket: ['wss://evm.confluxrpc.org/ws'],
        },
        public: {
            http: ['https://evm.confluxrpc.org'],
            webSocket: ['wss://evm.confluxrpc.org/ws'],
        },
    },
    blockExplorers: {
        default: {
            name: 'ConfluxScan',
            url: 'https://evm.confluxscan.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xEFf0078910f638cd81996cc117bccD3eDf2B072F',
            blockCreated: 68602935,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/confluxESpaceTestnet.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/confluxESpaceTestnet.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.confluxESpaceTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.confluxESpaceTestnet = (0, defineChain_js_1.defineChain)({
    id: 71,
    name: 'Conflux eSpace Testnet',
    network: 'cfx-espace-testnet',
    testnet: true,
    nativeCurrency: { name: 'Conflux', symbol: 'CFX', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://evmtestnet.confluxrpc.org'],
            webSocket: ['wss://evmtestnet.confluxrpc.org/ws'],
        },
        public: {
            http: ['https://evmtestnet.confluxrpc.org'],
            webSocket: ['wss://evmtestnet.confluxrpc.org/ws'],
        },
    },
    blockExplorers: {
        default: {
            name: 'ConfluxScan',
            url: 'https://evmtestnet.confluxscan.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xEFf0078910f638cd81996cc117bccD3eDf2B072F',
            blockCreated: 117499050,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/coreDao.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/coreDao.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.coreDao = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.coreDao = (0, defineChain_js_1.defineChain)({
    id: 1116,
    name: 'Core Dao',
    network: 'coreDao',
    nativeCurrency: {
        decimals: 18,
        name: 'Core',
        symbol: 'CORE',
    },
    rpcUrls: {
        public: { http: ['https://rpc.coredao.org'] },
        default: { http: ['https://rpc.coredao.org'] },
    },
    blockExplorers: {
        default: { name: 'CoreDao', url: 'https://scan.coredao.org' },
        etherscan: { name: 'CoreDao', url: 'https://scan.coredao.org' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 11907934,
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/cronos.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/cronos.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cronos = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.cronos = (0, defineChain_js_1.defineChain)({
    id: 25,
    name: 'Cronos Mainnet',
    network: 'cronos',
    nativeCurrency: {
        decimals: 18,
        name: 'Cronos',
        symbol: 'CRO',
    },
    rpcUrls: {
        default: { http: ['https://evm.cronos.org'] },
        public: { http: ['https://evm.cronos.org'] },
    },
    blockExplorers: {
        default: { name: 'Cronoscan', url: 'https://cronoscan.com' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 1963112,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/cronosTestnet.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/cronosTestnet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cronosTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.cronosTestnet = (0, defineChain_js_1.defineChain)({
    id: 338,
    name: 'Cronos Testnet',
    network: 'cronos-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'CRO',
        symbol: 'tCRO',
    },
    rpcUrls: {
        default: { http: ['https://evm-t3.cronos.org'] },
        public: { http: ['https://evm-t3.cronos.org'] },
    },
    blockExplorers: {
        default: {
            name: 'Cronos Explorer',
            url: 'https://cronos.org/explorer/testnet3',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 10191251,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/crossbell.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/crossbell.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crossbell = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.crossbell = (0, defineChain_js_1.defineChain)({
    id: 3737,
    network: 'crossbell',
    name: 'Crossbell',
    nativeCurrency: {
        decimals: 18,
        name: 'CSB',
        symbol: 'CSB',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.crossbell.io'],
        },
        public: {
            http: ['https://rpc.crossbell.io'],
        },
    },
    blockExplorers: {
        default: { name: 'CrossScan', url: 'https://scan.crossbell.io' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 38246031,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/dfk.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/dfk.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dfk = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.dfk = (0, defineChain_js_1.defineChain)({
    id: 53935,
    name: 'DFK Chain',
    network: 'dfk',
    nativeCurrency: {
        decimals: 18,
        name: 'Jewel',
        symbol: 'JEWEL',
    },
    rpcUrls: {
        default: {
            http: ['https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc'],
        },
        public: {
            http: ['https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'DFKSubnetScan',
            url: 'https://subnets.avax.network/defi-kingdoms',
        },
        default: {
            name: 'DFKSubnetScan',
            url: 'https://subnets.avax.network/defi-kingdoms',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/dogechain.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/dogechain.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dogechain = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.dogechain = (0, defineChain_js_1.defineChain)({
    id: 2000,
    name: 'Dogechain',
    network: 'dogechain',
    nativeCurrency: {
        decimals: 18,
        name: 'Dogechain',
        symbol: 'DC',
    },
    rpcUrls: {
        default: { http: ['https://rpc.dogechain.dog'] },
        public: { http: ['https://rpc.dogechain.dog'] },
    },
    blockExplorers: {
        etherscan: {
            name: 'DogeChainExplorer',
            url: 'https://explorer.dogechain.dog',
        },
        default: {
            name: 'DogeChainExplorer',
            url: 'https://explorer.dogechain.dog',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/edgeware.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/edgeware.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.edgeware = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.edgeware = (0, defineChain_js_1.defineChain)({
    id: 2021,
    name: 'Edgeware EdgeEVM Mainnet',
    network: 'edgeware',
    nativeCurrency: {
        decimals: 18,
        name: 'Edgeware',
        symbol: 'EDG',
    },
    rpcUrls: {
        default: { http: ['https://edgeware-evm.jelliedowl.net'] },
        public: { http: ['https://edgeware-evm.jelliedowl.net'] },
    },
    blockExplorers: {
        etherscan: { name: 'Edgscan by Bharathcoorg', url: 'https://edgscan.live' },
        default: { name: 'Edgscan by Bharathcoorg', url: 'https://edgscan.live' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 18117872,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/edgewareTestnet.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/edgewareTestnet.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.edgewareTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.edgewareTestnet = (0, defineChain_js_1.defineChain)({
    id: 2022,
    name: 'Beresheet BereEVM Testnet',
    network: 'edgewareTestnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Testnet EDG',
        symbol: 'tEDG',
    },
    rpcUrls: {
        default: { http: ['https://beresheet-evm.jelliedowl.net'] },
        public: { http: ['https://beresheet-evm.jelliedowl.net'] },
    },
    blockExplorers: {
        etherscan: {
            name: 'Edgscan by Bharathcoorg',
            url: 'https://testnet.edgscan.live',
        },
        default: {
            name: 'Edgscan by Bharathcoorg',
            url: 'https://testnet.edgscan.live',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/ekta.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/ekta.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ekta = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.ekta = (0, defineChain_js_1.defineChain)({
    id: 1994,
    name: 'Ekta',
    network: 'ekta',
    nativeCurrency: {
        decimals: 18,
        name: 'EKTA',
        symbol: 'EKTA',
    },
    rpcUrls: {
        public: { http: ['https://main.ekta.io'] },
        default: { http: ['https://main.ekta.io'] },
    },
    blockExplorers: {
        default: { name: 'Ektascan', url: 'https://ektascan.io' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/ektaTestnet.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/ektaTestnet.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ektaTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.ektaTestnet = (0, defineChain_js_1.defineChain)({
    id: 1004,
    name: 'Ekta Testnet',
    network: 'ekta-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'EKTA',
        symbol: 'EKTA',
    },
    rpcUrls: {
        public: { http: ['https://test.ekta.io:8545'] },
        default: { http: ['https://test.ekta.io:8545'] },
    },
    blockExplorers: {
        default: { name: 'Test Ektascan', url: 'https://test.ektascan.io' },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/eos.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/eos.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.eos = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.eos = (0, defineChain_js_1.defineChain)({
    id: 17777,
    name: 'EOS EVM',
    network: 'eos',
    nativeCurrency: {
        decimals: 18,
        name: 'EOS',
        symbol: 'EOS',
    },
    rpcUrls: {
        default: { http: ['https://api.evm.eosnetwork.com'] },
        public: { http: ['https://api.evm.eosnetwork.com'] },
    },
    blockExplorers: {
        etherscan: {
            name: 'EOS EVM Explorer',
            url: 'https://explorer.evm.eosnetwork.com',
        },
        default: {
            name: 'EOS EVM Explorer',
            url: 'https://explorer.evm.eosnetwork.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 7943933,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/eosTestnet.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/eosTestnet.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.eosTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.eosTestnet = (0, defineChain_js_1.defineChain)({
    id: 15557,
    name: 'EOS EVM Testnet',
    network: 'eos',
    nativeCurrency: {
        decimals: 18,
        name: 'EOS',
        symbol: 'EOS',
    },
    rpcUrls: {
        default: { http: ['https://api.testnet.evm.eosnetwork.com'] },
        public: { http: ['https://api.testnet.evm.eosnetwork.com'] },
    },
    blockExplorers: {
        etherscan: {
            name: 'EOS EVM Testnet Explorer',
            url: 'https://explorer.testnet.evm.eosnetwork.com',
        },
        default: {
            name: 'EOS EVM Testnet Explorer',
            url: 'https://explorer.testnet.evm.eosnetwork.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 9067940,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/evmos.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/evmos.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evmos = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.evmos = (0, defineChain_js_1.defineChain)({
    id: 9001,
    name: 'Evmos',
    network: 'evmos',
    nativeCurrency: {
        decimals: 18,
        name: 'Evmos',
        symbol: 'EVMOS',
    },
    rpcUrls: {
        default: { http: ['https://eth.bd.evmos.org:8545'] },
        public: { http: ['https://eth.bd.evmos.org:8545'] },
    },
    blockExplorers: {
        default: { name: 'Evmos Block Explorer', url: 'https://escan.live' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/evmosTestnet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/evmosTestnet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evmosTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.evmosTestnet = (0, defineChain_js_1.defineChain)({
    id: 9000,
    name: 'Evmos Testnet',
    network: 'evmos-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Evmos',
        symbol: 'EVMOS',
    },
    rpcUrls: {
        default: { http: ['https://eth.bd.evmos.dev:8545'] },
        public: { http: ['https://eth.bd.evmos.dev:8545'] },
    },
    blockExplorers: {
        default: {
            name: 'Evmos Testnet Block Explorer',
            url: 'https://evm.evmos.dev/',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/fantom.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/fantom.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fantom = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.fantom = (0, defineChain_js_1.defineChain)({
    id: 250,
    name: 'Fantom',
    network: 'fantom',
    nativeCurrency: {
        decimals: 18,
        name: 'Fantom',
        symbol: 'FTM',
    },
    rpcUrls: {
        default: { http: ['https://rpc.ankr.com/fantom'] },
        public: { http: ['https://rpc.ankr.com/fantom'] },
    },
    blockExplorers: {
        etherscan: { name: 'FTMScan', url: 'https://ftmscan.com' },
        default: { name: 'FTMScan', url: 'https://ftmscan.com' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 33001987,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/fantomSonicTestnet.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/fantomSonicTestnet.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fantomSonicTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.fantomSonicTestnet = (0, defineChain_js_1.defineChain)({
    id: 64240,
    name: 'Fantom Sonic Open Testnet',
    network: 'fantom-sonic-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Fantom',
        symbol: 'FTM',
    },
    rpcUrls: {
        default: { http: ['https://rpcapi.sonic.fantom.network'] },
        public: { http: ['https://rpcapi.sonic.fantom.network'] },
    },
    blockExplorers: {
        default: {
            name: 'Fantom Sonic Open Testnet Explorer',
            url: 'https://public-sonic.fantom.network',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/fantomTestnet.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/fantomTestnet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fantomTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.fantomTestnet = (0, defineChain_js_1.defineChain)({
    id: 4002,
    name: 'Fantom Testnet',
    network: 'fantom-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Fantom',
        symbol: 'FTM',
    },
    rpcUrls: {
        default: { http: ['https://rpc.testnet.fantom.network'] },
        public: { http: ['https://rpc.testnet.fantom.network'] },
    },
    blockExplorers: {
        etherscan: { name: 'FTMScan', url: 'https://testnet.ftmscan.com' },
        default: { name: 'FTMScan', url: 'https://testnet.ftmscan.com' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 8328688,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/fibo.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/fibo.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fibo = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.fibo = (0, defineChain_js_1.defineChain)({
    id: 12306,
    name: 'Fibo Chain',
    network: 'fibochain',
    nativeCurrency: {
        decimals: 18,
        name: 'fibo',
        symbol: 'FIBO',
    },
    rpcUrls: {
        default: { http: ['https://network.hzroc.art'] },
        public: { http: ['https://network.hzroc.art'] },
    },
    blockExplorers: {
        default: { name: 'FiboScan', url: 'https://scan.fibochain.org' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/filecoin.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/filecoin.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filecoin = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.filecoin = (0, defineChain_js_1.defineChain)({
    id: 314,
    name: 'Filecoin Mainnet',
    network: 'filecoin-mainnet',
    nativeCurrency: {
        decimals: 18,
        name: 'filecoin',
        symbol: 'FIL',
    },
    rpcUrls: {
        default: { http: ['https://api.node.glif.io/rpc/v1'] },
        public: { http: ['https://api.node.glif.io/rpc/v1'] },
    },
    blockExplorers: {
        default: { name: 'Filfox', url: 'https://filfox.info/en' },
        filscan: { name: 'Filscan', url: 'https://filscan.io' },
        filscout: { name: 'Filscout', url: 'https://filscout.io/en' },
        glif: { name: 'Glif', url: 'https://explorer.glif.io' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 3328594,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/filecoinCalibration.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/filecoinCalibration.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filecoinCalibration = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.filecoinCalibration = (0, defineChain_js_1.defineChain)({
    id: 314159,
    name: 'Filecoin Calibration',
    network: 'filecoin-calibration',
    nativeCurrency: {
        decimals: 18,
        name: 'testnet filecoin',
        symbol: 'tFIL',
    },
    rpcUrls: {
        default: { http: ['https://api.calibration.node.glif.io/rpc/v1'] },
        public: { http: ['https://api.calibration.node.glif.io/rpc/v1'] },
    },
    blockExplorers: {
        default: { name: 'Filscan', url: 'https://calibration.filscan.io' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/filecoinHyperspace.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/filecoinHyperspace.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filecoinHyperspace = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.filecoinHyperspace = (0, defineChain_js_1.defineChain)({
    id: 3141,
    name: 'Filecoin Hyperspace',
    network: 'filecoin-hyperspace',
    nativeCurrency: {
        decimals: 18,
        name: 'testnet filecoin',
        symbol: 'tFIL',
    },
    rpcUrls: {
        default: { http: ['https://api.hyperspace.node.glif.io/rpc/v1'] },
        public: { http: ['https://api.hyperspace.node.glif.io/rpc/v1'] },
    },
    blockExplorers: {
        default: { name: 'Filfox', url: 'https://hyperspace.filfox.info/en' },
        filscan: { name: 'Filscan', url: 'https://hyperspace.filscan.io' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/flare.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/flare.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flare = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.flare = (0, defineChain_js_1.defineChain)({
    id: 14,
    name: 'Flare Mainnet',
    network: 'flare-mainnet',
    nativeCurrency: {
        decimals: 18,
        name: 'flare',
        symbol: 'FLR',
    },
    rpcUrls: {
        default: { http: ['https://flare-api.flare.network/ext/C/rpc'] },
        public: { http: ['https://flare-api.flare.network/ext/C/rpc'] },
    },
    blockExplorers: {
        default: {
            name: 'Flare Explorer',
            url: 'https://flare-explorer.flare.network',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/flareTestnet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/flareTestnet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flareTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.flareTestnet = (0, defineChain_js_1.defineChain)({
    id: 114,
    name: 'Coston2',
    network: 'coston2',
    nativeCurrency: {
        decimals: 18,
        name: 'coston2flare',
        symbol: 'C2FLR',
    },
    rpcUrls: {
        default: { http: ['https://coston2-api.flare.network/ext/C/rpc'] },
        public: { http: ['https://coston2-api.flare.network/ext/C/rpc'] },
    },
    blockExplorers: {
        default: {
            name: 'Coston2 Explorer',
            url: 'https://coston2-explorer.flare.network',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/foundry.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/foundry.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.foundry = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.foundry = (0, defineChain_js_1.defineChain)({
    id: 31337,
    name: 'Foundry',
    network: 'foundry',
    nativeCurrency: {
        decimals: 18,
        name: 'Ether',
        symbol: 'ETH',
    },
    rpcUrls: {
        default: {
            http: ['http://127.0.0.1:8545'],
            webSocket: ['ws://127.0.0.1:8545'],
        },
        public: {
            http: ['http://127.0.0.1:8545'],
            webSocket: ['ws://127.0.0.1:8545'],
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/fuse.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/fuse.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fuse = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.fuse = (0, defineChain_js_1.defineChain)({
    id: 122,
    name: 'Fuse',
    network: 'fuse',
    nativeCurrency: { name: 'Fuse', symbol: 'FUSE', decimals: 18 },
    rpcUrls: {
        default: { http: ['https://rpc.fuse.io'] },
        public: { http: ['https://rpc.fuse.io'] },
    },
    blockExplorers: {
        default: { name: 'Fuse Explorer', url: 'https://explorer.fuse.io' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 16146628,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/fuseSparknet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/fuseSparknet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fuseSparknet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.fuseSparknet = (0, defineChain_js_1.defineChain)({
    id: 123,
    name: 'Fuse Sparknet',
    network: 'fuse',
    nativeCurrency: { name: 'Spark', symbol: 'SPARK', decimals: 18 },
    rpcUrls: {
        default: { http: ['https://rpc.fusespark.io'] },
        public: { http: ['https://rpc.fusespark.io'] },
    },
    blockExplorers: {
        default: {
            name: 'Sparkent Explorer',
            url: 'https://explorer.fusespark.io',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/gnosis.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/gnosis.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gnosis = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.gnosis = (0, defineChain_js_1.defineChain)({
    id: 100,
    name: 'Gnosis',
    network: 'gnosis',
    nativeCurrency: {
        decimals: 18,
        name: 'Gnosis',
        symbol: 'xDAI',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.gnosischain.com'],
            webSocket: ['wss://rpc.gnosischain.com/wss'],
        },
        public: {
            http: ['https://rpc.gnosischain.com'],
            webSocket: ['wss://rpc.gnosischain.com/wss'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'Gnosisscan',
            url: 'https://gnosisscan.io',
        },
        default: {
            name: 'Gnosis Chain Explorer',
            url: 'https://blockscout.com/xdai/mainnet',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 21022491,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/gnosisChiado.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/gnosisChiado.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gnosisChiado = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.gnosisChiado = (0, defineChain_js_1.defineChain)({
    id: 10200,
    name: 'Gnosis Chiado',
    network: 'chiado',
    nativeCurrency: {
        decimals: 18,
        name: 'Gnosis',
        symbol: 'xDAI',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.chiadochain.net'],
            webSocket: ['wss://rpc.chiadochain.net/wss'],
        },
        public: {
            http: ['https://rpc.chiadochain.net'],
            webSocket: ['wss://rpc.chiadochain.net/wss'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Blockscout',
            url: 'https://blockscout.chiadochain.net',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 4967313,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/gobi.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/gobi.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gobi = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.gobi = (0, defineChain_js_1.defineChain)({
    id: 1663,
    name: 'Horizen Gobi Testnet',
    network: 'gobi',
    nativeCurrency: {
        decimals: 18,
        name: 'Test ZEN',
        symbol: 'tZEN',
    },
    rpcUrls: {
        public: { http: ['https://gobi-testnet.horizenlabs.io/ethv1'] },
        default: { http: ['https://gobi-testnet.horizenlabs.io/ethv1'] },
    },
    blockExplorers: {
        default: { name: 'Gobi Explorer', url: 'https://gobi-explorer.horizen.io' },
    },
    contracts: {},
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/goerli.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/goerli.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.goerli = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.goerli = (0, defineChain_js_1.defineChain)({
    id: 5,
    network: 'goerli',
    name: 'Goerli',
    nativeCurrency: { name: 'Goerli Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://eth-goerli.g.alchemy.com/v2'],
            webSocket: ['wss://eth-goerli.g.alchemy.com/v2'],
        },
        infura: {
            http: ['https://goerli.infura.io/v3'],
            webSocket: ['wss://goerli.infura.io/ws/v3'],
        },
        default: {
            http: ['https://rpc.ankr.com/eth_goerli'],
        },
        public: {
            http: ['https://rpc.ankr.com/eth_goerli'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'Etherscan',
            url: 'https://goerli.etherscan.io',
        },
        default: {
            name: 'Etherscan',
            url: 'https://goerli.etherscan.io',
        },
    },
    contracts: {
        ensRegistry: {
            address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
        },
        ensUniversalResolver: {
            address: '0x56522D00C410a43BFfDF00a9A569489297385790',
            blockCreated: 8765204,
        },
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 6507670,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/haqqMainnet.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/haqqMainnet.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.haqqMainnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.haqqMainnet = (0, defineChain_js_1.defineChain)({
    id: 11235,
    name: 'HAQQ Mainnet',
    network: 'haqq-mainnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Islamic Coin',
        symbol: 'ISLM',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.eth.haqq.network'],
        },
        public: {
            http: ['https://rpc.eth.haqq.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'HAQQ Explorer',
            url: 'https://explorer.haqq.network',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/haqqTestedge2.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/haqqTestedge2.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.haqqTestedge2 = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.haqqTestedge2 = (0, defineChain_js_1.defineChain)({
    id: 54211,
    name: 'HAQQ Testedge 2',
    network: 'haqq-testedge-2',
    nativeCurrency: {
        decimals: 18,
        name: 'Islamic Coin',
        symbol: 'ISLMT',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.eth.testedge2.haqq.network'],
        },
        public: {
            http: ['https://rpc.eth.testedge2.haqq.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'HAQQ Explorer',
            url: 'https://explorer.testedge2.haqq.network',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/hardhat.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/hardhat.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hardhat = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.hardhat = (0, defineChain_js_1.defineChain)({
    id: 31337,
    name: 'Hardhat',
    network: 'hardhat',
    nativeCurrency: {
        decimals: 18,
        name: 'Ether',
        symbol: 'ETH',
    },
    rpcUrls: {
        default: { http: ['http://127.0.0.1:8545'] },
        public: { http: ['http://127.0.0.1:8545'] },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/harmonyOne.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/harmonyOne.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.harmonyOne = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.harmonyOne = (0, defineChain_js_1.defineChain)({
    id: 1666600000,
    name: 'Harmony One',
    network: 'harmony',
    nativeCurrency: {
        name: 'Harmony',
        symbol: 'ONE',
        decimals: 18,
    },
    rpcUrls: {
        public: { http: ['https://rpc.ankr.com/harmony'] },
        default: { http: ['https://rpc.ankr.com/harmony'] },
    },
    blockExplorers: {
        default: { name: 'Harmony Explorer', url: 'https://explorer.harmony.one' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 24185753,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/holesky.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/holesky.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.holesky = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.holesky = (0, defineChain_js_1.defineChain)({
    id: 17000,
    network: 'holesky',
    name: 'Holesky',
    nativeCurrency: { name: 'Holesky Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://ethereum-holesky.publicnode.com'],
        },
        public: {
            http: ['https://ethereum-holesky.publicnode.com'],
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 77,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/iotex.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/iotex.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iotex = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.iotex = (0, defineChain_js_1.defineChain)({
    id: 4689,
    name: 'IoTeX',
    network: 'iotex',
    nativeCurrency: {
        decimals: 18,
        name: 'IoTeX',
        symbol: 'IOTX',
    },
    rpcUrls: {
        default: {
            http: ['https://babel-api.mainnet.iotex.io'],
            webSocket: ['wss://babel-api.mainnet.iotex.io'],
        },
        public: {
            http: ['https://babel-api.mainnet.iotex.io'],
            webSocket: ['wss://babel-api.mainnet.iotex.io'],
        },
    },
    blockExplorers: {
        default: { name: 'IoTeXScan', url: 'https://iotexscan.io' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/iotexTestnet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/iotexTestnet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iotexTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.iotexTestnet = (0, defineChain_js_1.defineChain)({
    id: 4690,
    name: 'IoTeX Testnet',
    network: 'iotex-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'IoTeX',
        symbol: 'IOTX',
    },
    rpcUrls: {
        default: {
            http: ['https://babel-api.testnet.iotex.io'],
            webSocket: ['wss://babel-api.testnet.iotex.io'],
        },
        public: {
            http: ['https://babel-api.testnet.iotex.io'],
            webSocket: ['wss://babel-api.testnet.iotex.io'],
        },
    },
    blockExplorers: {
        default: { name: 'IoTeXScan', url: 'https://testnet.iotexscan.io' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/jbc.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/jbc.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.jbc = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.jbc = (0, defineChain_js_1.defineChain)({
    id: 8899,
    name: 'JIBCHAIN L1',
    network: 'jbc',
    nativeCurrency: { name: 'JBC', symbol: 'JBC', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc-l1.jibchain.net'],
        },
        public: {
            http: ['https://rpc-l1.jibchain.net'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Blockscout',
            url: 'https://exp-l1.jibchain.net',
        },
    },
    contracts: {
        multicall3: {
            address: '0xc0C8C486D1466C57Efe13C2bf000d4c56F47CBdC',
            blockCreated: 2299048,
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/karura.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/karura.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.karura = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.karura = (0, defineChain_js_1.defineChain)({
    id: 686,
    name: 'Karura',
    network: 'karura',
    nativeCurrency: {
        name: 'Karura',
        symbol: 'KAR',
        decimals: 18,
    },
    rpcUrls: {
        public: {
            http: ['https://eth-rpc-karura.aca-api.network'],
            webSocket: ['wss://eth-rpc-karura.aca-api.network'],
        },
        default: {
            http: ['https://eth-rpc-karura.aca-api.network'],
            webSocket: ['wss://eth-rpc-karura.aca-api.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Karura Blockscout',
            url: 'https://blockscout.karura.network',
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/kava.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/kava.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.kava = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.kava = (0, defineChain_js_1.defineChain)({
    id: 2222,
    name: 'Kava EVM',
    network: 'kava-mainnet',
    nativeCurrency: {
        name: 'Kava',
        symbol: 'KAVA',
        decimals: 18,
    },
    rpcUrls: {
        public: { http: ['https://evm.kava.io'] },
        default: { http: ['https://evm.kava.io'] },
    },
    blockExplorers: {
        default: { name: 'Kava EVM Explorer', url: 'https://kavascan.com' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 3661165,
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/kavaTestnet.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/kavaTestnet.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.kavaTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.kavaTestnet = (0, defineChain_js_1.defineChain)({
    id: 2221,
    name: 'Kava EVM Testnet',
    network: 'kava-testnet',
    nativeCurrency: {
        name: 'Kava',
        symbol: 'KAVA',
        decimals: 18,
    },
    rpcUrls: {
        public: { http: ['https://evm.testnet.kava.io'] },
        default: { http: ['https://evm.testnet.kava.io'] },
    },
    blockExplorers: {
        default: {
            name: 'Kava EVM Testnet Explorer',
            url: 'https://testnet.kavascan.com/',
        },
    },
    contracts: {
        multicall3: {
            address: '0xDf1D724A7166261eEB015418fe8c7679BBEa7fd6',
            blockCreated: 7242179,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/klaytn.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/klaytn.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.klaytn = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.klaytn = (0, defineChain_js_1.defineChain)({
    id: 8217,
    name: 'Klaytn',
    network: 'klaytn',
    nativeCurrency: {
        decimals: 18,
        name: 'Klaytn',
        symbol: 'KLAY',
    },
    rpcUrls: {
        default: { http: ['https://public-en-cypress.klaytn.net'] },
        public: { http: ['https://public-en-cypress.klaytn.net'] },
    },
    blockExplorers: {
        etherscan: { name: 'KlaytnScope', url: 'https://scope.klaytn.com' },
        default: { name: 'KlaytnScope', url: 'https://scope.klaytn.com' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 96002415,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/klaytnBaobab.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/klaytnBaobab.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.klaytnBaobab = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.klaytnBaobab = (0, defineChain_js_1.defineChain)({
    id: 1001,
    name: 'Klaytn Baobab Testnet',
    network: 'klaytn-baobab',
    nativeCurrency: {
        decimals: 18,
        name: 'Baobab Klaytn',
        symbol: 'KLAY',
    },
    rpcUrls: {
        default: { http: ['https://public-en-baobab.klaytn.net'] },
        public: { http: ['https://public-en-baobab.klaytn.net'] },
    },
    blockExplorers: {
        etherscan: { name: 'KlaytnScope', url: 'https://baobab.klaytnscope.com' },
        default: { name: 'KlaytnScope', url: 'https://baobab.klaytnscope.com' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 123390593,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/kroma.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/kroma.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.kroma = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.kroma = (0, defineChain_js_1.defineChain)({
    id: 255,
    network: 'kroma',
    name: 'Kroma',
    nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://api.kroma.network'],
        },
        public: {
            http: ['https://api.kroma.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Kroma Explorer',
            url: 'https://blockscout.kroma.network',
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/kromaSepolia.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/kromaSepolia.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.kromaSepolia = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.kromaSepolia = (0, defineChain_js_1.defineChain)({
    id: 2358,
    network: 'kroma-sepolia',
    name: 'Kroma Sepolia',
    nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://api.sepolia.kroma.network'],
        },
        public: {
            http: ['https://api.sepolia.kroma.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Kroma Sepolia Explorer',
            url: 'https://blockscout.sepolia.kroma.network',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/linea.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/linea.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.linea = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.linea = (0, defineChain_js_1.defineChain)({
    id: 59144,
    name: 'Linea Mainnet',
    network: 'linea-mainnet',
    nativeCurrency: { name: 'Linea Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        infura: {
            http: ['https://linea-mainnet.infura.io/v3'],
            webSocket: ['wss://linea-mainnet.infura.io/ws/v3'],
        },
        default: {
            http: ['https://rpc.linea.build'],
            webSocket: ['wss://rpc.linea.build'],
        },
        public: {
            http: ['https://rpc.linea.build'],
            webSocket: ['wss://rpc.linea.build'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Etherscan',
            url: 'https://lineascan.build',
        },
        etherscan: {
            name: 'Etherscan',
            url: 'https://lineascan.build',
        },
        blockscout: {
            name: 'Blockscout',
            url: 'https://explorer.linea.build',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 42,
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/lineaTestnet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/lineaTestnet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lineaTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.lineaTestnet = (0, defineChain_js_1.defineChain)({
    id: 59140,
    name: 'Linea Goerli Testnet',
    network: 'linea-testnet',
    nativeCurrency: { name: 'Linea Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        infura: {
            http: ['https://linea-goerli.infura.io/v3'],
            webSocket: ['wss://linea-goerli.infura.io/ws/v3'],
        },
        default: {
            http: ['https://rpc.goerli.linea.build'],
            webSocket: ['wss://rpc.goerli.linea.build'],
        },
        public: {
            http: ['https://rpc.goerli.linea.build'],
            webSocket: ['wss://rpc.goerli.linea.build'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Etherscan',
            url: 'https://goerli.lineascan.build',
        },
        etherscan: {
            name: 'Etherscan',
            url: 'https://goerli.lineascan.build',
        },
        blockscout: {
            name: 'Blockscout',
            url: 'https://explorer.goerli.linea.build',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 498623,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/localhost.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/localhost.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.localhost = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.localhost = (0, defineChain_js_1.defineChain)({
    id: 1337,
    name: 'Localhost',
    network: 'localhost',
    nativeCurrency: {
        decimals: 18,
        name: 'Ether',
        symbol: 'ETH',
    },
    rpcUrls: {
        default: { http: ['http://127.0.0.1:8545'] },
        public: { http: ['http://127.0.0.1:8545'] },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/lukso.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/lukso.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lukso = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.lukso = (0, defineChain_js_1.defineChain)({
    id: 42,
    network: 'lukso',
    name: 'LUKSO',
    nativeCurrency: {
        name: 'LUKSO',
        symbol: 'LYX',
        decimals: 18,
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.mainnet.lukso.network'],
            webSocket: ['wss://ws-rpc.mainnet.lukso.network'],
        },
        public: {
            http: ['https://rpc.mainnet.lukso.network'],
            webSocket: ['wss://ws-rpc.mainnet.lukso.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'LUKSO Mainnet Explorer',
            url: 'https://explorer.execution.mainnet.lukso.network',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/mainnet.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/mainnet.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mainnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.mainnet = (0, defineChain_js_1.defineChain)({
    id: 1,
    network: 'homestead',
    name: 'Ethereum',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://eth-mainnet.g.alchemy.com/v2'],
            webSocket: ['wss://eth-mainnet.g.alchemy.com/v2'],
        },
        infura: {
            http: ['https://mainnet.infura.io/v3'],
            webSocket: ['wss://mainnet.infura.io/ws/v3'],
        },
        default: {
            http: ['https://cloudflare-eth.com'],
        },
        public: {
            http: ['https://cloudflare-eth.com'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'Etherscan',
            url: 'https://etherscan.io',
        },
        default: {
            name: 'Etherscan',
            url: 'https://etherscan.io',
        },
    },
    contracts: {
        ensRegistry: {
            address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
        },
        ensUniversalResolver: {
            address: '0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62',
            blockCreated: 16966585,
        },
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 14353601,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/mandala.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/mandala.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mandala = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.mandala = (0, defineChain_js_1.defineChain)({
    id: 595,
    name: 'Mandala TC9',
    network: 'mandala',
    nativeCurrency: {
        name: 'Mandala',
        symbol: 'mACA',
        decimals: 18,
    },
    rpcUrls: {
        public: {
            http: ['https://eth-rpc-tc9.aca-staging.network'],
            webSocket: ['wss://eth-rpc-tc9.aca-staging.network'],
        },
        default: {
            http: ['https://eth-rpc-tc9.aca-staging.network'],
            webSocket: ['wss://eth-rpc-tc9.aca-staging.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Mandala Blockscout',
            url: 'https://blockscout.mandala.aca-staging.network',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/manta.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/manta.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.manta = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.manta = (0, defineChain_js_1.defineChain)({
    id: 169,
    name: 'Manta Pacific Mainnet',
    network: 'manta',
    nativeCurrency: {
        decimals: 18,
        name: 'ETH',
        symbol: 'ETH',
    },
    rpcUrls: {
        default: { http: ['https://pacific-rpc.manta.network/http'] },
        public: { http: ['https://pacific-rpc.manta.network/http'] },
    },
    blockExplorers: {
        etherscan: {
            name: 'Manta Explorer',
            url: 'https://pacific-explorer.manta.network',
        },
        default: {
            name: 'Manta Explorer',
            url: 'https://pacific-explorer.manta.network',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 332890,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/mantaTestnet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/mantaTestnet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mantaTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.mantaTestnet = (0, defineChain_js_1.defineChain)({
    id: 3441005,
    name: 'Manta Pacific Testnet',
    network: 'manta-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'ETH',
        symbol: 'ETH',
    },
    rpcUrls: {
        default: { http: ['https://manta-testnet.calderachain.xyz/http'] },
        public: { http: ['https://manta-testnet.calderachain.xyz/http'] },
    },
    blockExplorers: {
        etherscan: {
            name: 'Manta Testnet Explorer',
            url: 'https://pacific-explorer.testnet.manta.network',
        },
        default: {
            name: 'Manta Testnet Explorer',
            url: 'https://pacific-explorer.testnet.manta.network',
        },
    },
    contracts: {
        multicall3: {
            address: '0x211B1643b95Fe76f11eD8880EE810ABD9A4cf56C',
            blockCreated: 419915,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/mantle.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/mantle.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mantle = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.mantle = (0, defineChain_js_1.defineChain)({
    id: 5000,
    name: 'Mantle',
    network: 'mantle',
    nativeCurrency: {
        decimals: 18,
        name: 'MNT',
        symbol: 'MNT',
    },
    rpcUrls: {
        default: { http: ['https://rpc.mantle.xyz'] },
        public: { http: ['https://rpc.mantle.xyz'] },
    },
    blockExplorers: {
        etherscan: {
            name: 'Mantle Explorer',
            url: 'https://explorer.mantle.xyz',
        },
        default: {
            name: 'Mantle Explorer',
            url: 'https://explorer.mantle.xyz',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 304717,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/mantleTestnet.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/mantleTestnet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mantleTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.mantleTestnet = (0, defineChain_js_1.defineChain)({
    id: 5001,
    name: 'Mantle Testnet',
    network: 'mantle',
    nativeCurrency: {
        decimals: 18,
        name: 'MNT',
        symbol: 'MNT',
    },
    rpcUrls: {
        default: { http: ['https://rpc.testnet.mantle.xyz'] },
        public: { http: ['https://rpc.testnet.mantle.xyz'] },
    },
    blockExplorers: {
        etherscan: {
            name: 'Mantle Testnet Explorer',
            url: 'https://explorer.testnet.mantle.xyz',
        },
        default: {
            name: 'Mantle Testnet Explorer',
            url: 'https://explorer.testnet.mantle.xyz',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/meter.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/meter.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.meter = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.meter = (0, defineChain_js_1.defineChain)({
    id: 82,
    name: 'Meter',
    network: 'meter',
    nativeCurrency: {
        decimals: 18,
        name: 'MTR',
        symbol: 'MTR',
    },
    rpcUrls: {
        default: { http: ['https://rpc.meter.io'] },
        public: { http: ['https://rpc.meter.io'] },
    },
    blockExplorers: {
        default: { name: 'MeterScan', url: 'https://scan.meter.io' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/meterTestnet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/meterTestnet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.meterTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.meterTestnet = (0, defineChain_js_1.defineChain)({
    id: 83,
    name: 'Meter Testnet',
    network: 'meter-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'MTR',
        symbol: 'MTR',
    },
    rpcUrls: {
        default: { http: ['https://rpctest.meter.io'] },
        public: { http: ['https://rpctest.meter.io'] },
    },
    blockExplorers: {
        default: {
            name: 'MeterTestnetScan',
            url: 'https://scan-warringstakes.meter.io',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/metis.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/metis.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.metis = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.metis = (0, defineChain_js_1.defineChain)({
    id: 1088,
    name: 'Metis',
    network: 'andromeda',
    nativeCurrency: {
        decimals: 18,
        name: 'Metis',
        symbol: 'METIS',
    },
    rpcUrls: {
        default: { http: ['https://andromeda.metis.io/?owner=1088'] },
        public: { http: ['https://andromeda.metis.io/?owner=1088'] },
    },
    blockExplorers: {
        default: {
            name: 'Andromeda Explorer',
            url: 'https://andromeda-explorer.metis.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 2338552,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/metisGoerli.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/metisGoerli.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.metisGoerli = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.metisGoerli = (0, defineChain_js_1.defineChain)({
    id: 599,
    name: 'Metis Goerli',
    network: 'metis-goerli',
    nativeCurrency: {
        decimals: 18,
        name: 'Metis Goerli',
        symbol: 'METIS',
    },
    rpcUrls: {
        default: { http: ['https://goerli.gateway.metisdevops.link'] },
        public: { http: ['https://goerli.gateway.metisdevops.link'] },
    },
    blockExplorers: {
        default: {
            name: 'Metis Goerli Explorer',
            url: 'https://goerli.explorer.metisdevops.link',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 1006207,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/mev.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/mev.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mev = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.mev = (0, defineChain_js_1.defineChain)({
    id: 7518,
    network: 'MEVerse',
    name: 'MEVerse Chain Mainnet',
    nativeCurrency: {
        decimals: 18,
        name: 'MEVerse',
        symbol: 'MEV',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.meversemainnet.io'],
        },
        public: {
            http: ['https://rpc.meversemainnet.io'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Explorer',
            url: 'https://www.meversescan.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 86881340,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/mevTestnet.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/mevTestnet.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mevTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.mevTestnet = (0, defineChain_js_1.defineChain)({
    id: 4759,
    network: 'MEVerse Testnet',
    name: 'MEVerse Chain Testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'MEVerse',
        symbol: 'MEV',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.meversetestnet.io'],
        },
        public: {
            http: ['https://rpc.meversetestnet.io'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Explorer',
            url: 'https://testnet.meversescan.io/',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 64371115,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/modeTestnet.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/modeTestnet.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.modeTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.modeTestnet = (0, defineChain_js_1.defineChain)({
    id: 919,
    name: 'Mode Testnet',
    network: 'mode-testnet',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://sepolia.mode.network'],
        },
        public: {
            http: ['https://sepolia.mode.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Blockscout',
            url: 'https://sepolia.explorer.mode.network',
        },
    },
    contracts: {
        multicall3: {
            address: '0xBAba8373113Fb7a68f195deF18732e01aF8eDfCF',
            blockCreated: 3019007,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/moonbaseAlpha.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/moonbaseAlpha.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moonbaseAlpha = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.moonbaseAlpha = (0, defineChain_js_1.defineChain)({
    id: 1287,
    name: 'Moonbase Alpha',
    network: 'moonbase-alpha',
    nativeCurrency: {
        decimals: 18,
        name: 'DEV',
        symbol: 'DEV',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.api.moonbase.moonbeam.network'],
            webSocket: ['wss://wss.api.moonbase.moonbeam.network'],
        },
        public: {
            http: ['https://rpc.api.moonbase.moonbeam.network'],
            webSocket: ['wss://wss.api.moonbase.moonbeam.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Moonscan',
            url: 'https://moonbase.moonscan.io',
        },
        etherscan: {
            name: 'Moonscan',
            url: 'https://moonbase.moonscan.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 1850686,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/moonbeam.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/moonbeam.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moonbeam = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.moonbeam = (0, defineChain_js_1.defineChain)({
    id: 1284,
    name: 'Moonbeam',
    network: 'moonbeam',
    nativeCurrency: {
        decimals: 18,
        name: 'GLMR',
        symbol: 'GLMR',
    },
    rpcUrls: {
        public: {
            http: ['https://moonbeam.public.blastapi.io'],
            webSocket: ['wss://moonbeam.public.blastapi.io'],
        },
        default: {
            http: ['https://moonbeam.public.blastapi.io'],
            webSocket: ['wss://moonbeam.public.blastapi.io'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Moonscan',
            url: 'https://moonscan.io',
        },
        etherscan: {
            name: 'Moonscan',
            url: 'https://moonscan.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 609002,
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/moonbeamDev.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/moonbeamDev.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moonbeamDev = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.moonbeamDev = (0, defineChain_js_1.defineChain)({
    id: 1281,
    name: 'Moonbeam Development Node',
    network: 'development',
    nativeCurrency: {
        decimals: 18,
        name: 'DEV',
        symbol: 'DEV',
    },
    rpcUrls: {
        default: {
            http: ['http://127.0.0.1:9944'],
            webSocket: ['wss://127.0.0.1:9944'],
        },
        public: {
            http: ['http://127.0.0.1:9944'],
            webSocket: ['wss://127.0.0.1:9944'],
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/moonriver.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/moonriver.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moonriver = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.moonriver = (0, defineChain_js_1.defineChain)({
    id: 1285,
    name: 'Moonriver',
    network: 'moonriver',
    nativeCurrency: {
        decimals: 18,
        name: 'MOVR',
        symbol: 'MOVR',
    },
    rpcUrls: {
        public: {
            http: ['https://moonriver.public.blastapi.io'],
            webSocket: ['wss://moonriver.public.blastapi.io'],
        },
        default: {
            http: ['https://moonriver.public.blastapi.io'],
            webSocket: ['wss://moonriver.public.blastapi.io'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Moonscan',
            url: 'https://moonriver.moonscan.io',
        },
        etherscan: {
            name: 'Moonscan',
            url: 'https://moonriver.moonscan.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 1597904,
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/neonDevnet.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/neonDevnet.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.neonDevnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.neonDevnet = (0, defineChain_js_1.defineChain)({
    id: 245022926,
    network: 'neonDevnet',
    name: 'Neon EVM DevNet',
    nativeCurrency: { name: 'NEON', symbol: 'NEON', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://devnet.neonevm.org'],
        },
        public: {
            http: ['https://devnet.neonevm.org'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Neonscan',
            url: 'https://devnet.neonscan.org',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 205206112,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/neonMainnet.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/neonMainnet.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.neonMainnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.neonMainnet = (0, defineChain_js_1.defineChain)({
    id: 245022934,
    network: 'neonMainnet',
    name: 'Neon EVM MainNet',
    nativeCurrency: { name: 'NEON', symbol: 'NEON', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://neon-proxy-mainnet.solana.p2p.org'],
        },
        public: {
            http: ['https://neon-proxy-mainnet.solana.p2p.org'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Neonscan',
            url: 'https://neonscan.org',
        },
    },
    contracts: {},
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/nexi.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/nexi.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nexi = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.nexi = (0, defineChain_js_1.defineChain)({
    id: 4242,
    name: 'Nexi',
    network: 'nexi',
    nativeCurrency: { name: 'Nexi', symbol: 'NEXI', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.chain.nexi.technology'],
        },
        public: {
            http: ['https://rpc.chain.nexi.technology'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'NexiScan',
            url: 'https://www.nexiscan.com',
        },
        default: {
            name: 'NexiScan',
            url: 'https://www.nexiscan.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E',
            blockCreated: 25770160,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/nexilix.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/nexilix.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nexilix = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.nexilix = (0, defineChain_js_1.defineChain)({
    id: 240,
    name: 'Nexilix Smart Chain',
    network: 'nexilix',
    nativeCurrency: {
        decimals: 18,
        name: 'Nexilix',
        symbol: 'NEXILIX',
    },
    rpcUrls: {
        default: { http: ['https://rpcurl.pos.nexilix.com'] },
        public: { http: ['https://rpcurl.pos.nexilix.com'] },
    },
    blockExplorers: {
        etherscan: { name: 'NexilixScan', url: 'https://scan.nexilix.com' },
        default: { name: 'NexilixScan', url: 'https://scan.nexilix.com' },
    },
    contracts: {
        multicall3: {
            address: '0x58381c8e2BF9d0C2C4259cA14BdA9Afe02831244',
            blockCreated: 74448,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/oasisTestnet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/oasisTestnet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oasisTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.oasisTestnet = (0, defineChain_js_1.defineChain)({
    id: 4090,
    network: 'oasis-testnet',
    name: 'Oasis Testnet',
    nativeCurrency: { name: 'Fasttoken', symbol: 'FTN', decimals: 18 },
    rpcUrls: {
        default: { http: ['https://rpc1.oasis.bahamutchain.com'] },
        public: { http: ['https://rpc1.oasis.bahamutchain.com'] },
    },
    blockExplorers: {
        default: {
            name: 'Ftnscan',
            url: 'https://oasis.ftnscan.com',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/oasys.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/oasys.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oasys = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.oasys = (0, defineChain_js_1.defineChain)({
    id: 248,
    name: 'Oasys',
    network: 'oasys',
    nativeCurrency: { name: 'Oasys', symbol: 'OAS', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.mainnet.oasys.games'],
        },
        public: {
            http: ['https://rpc.mainnet.oasys.games'],
        },
    },
    blockExplorers: {
        default: {
            name: 'OasysScan',
            url: 'https://scan.oasys.games',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/okc.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/okc.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.okc = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.okc = (0, defineChain_js_1.defineChain)({
    id: 66,
    name: 'OKC',
    network: 'okc',
    nativeCurrency: {
        decimals: 18,
        name: 'OKT',
        symbol: 'OKT',
    },
    rpcUrls: {
        default: { http: ['https://exchainrpc.okex.org'] },
        public: { http: ['https://exchainrpc.okex.org'] },
    },
    blockExplorers: {
        default: { name: 'oklink', url: 'https://www.oklink.com/okc' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 10364792,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/opBNB.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/opBNB.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.opBNB = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.opBNB = (0, defineChain_js_1.defineChain)({
    id: 204,
    name: 'opBNB',
    network: 'opBNB Mainnet',
    nativeCurrency: {
        name: 'BNB',
        symbol: 'BNB',
        decimals: 18,
    },
    rpcUrls: {
        public: { http: ['https://opbnb-mainnet-rpc.bnbchain.org'] },
        default: { http: ['https://opbnb-mainnet-rpc.bnbchain.org'] },
    },
    blockExplorers: {
        default: { name: 'opbnbscan', url: 'https://mainnet.opbnbscan.com' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 512881,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/opBNBTestnet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/opBNBTestnet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.opBNBTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.opBNBTestnet = (0, defineChain_js_1.defineChain)({
    id: 5611,
    name: 'opBNB Testnet',
    network: 'opBNB Testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'tBNB',
        symbol: 'tBNB',
    },
    rpcUrls: {
        public: { http: ['https://opbnb-testnet-rpc.bnbchain.org'] },
        default: { http: ['https://opbnb-testnet-rpc.bnbchain.org'] },
    },
    blockExplorers: {
        default: { name: 'opbnbscan', url: 'https://testnet.opbnbscan.com' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 3705108,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/optimism.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/optimism.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optimism = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../optimism/formatters.js */ "../../node_modules/viem/_cjs/chains/optimism/formatters.js");
exports.optimism = (0, defineChain_js_1.defineChain)({
    id: 10,
    name: 'OP Mainnet',
    network: 'optimism',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://opt-mainnet.g.alchemy.com/v2'],
            webSocket: ['wss://opt-mainnet.g.alchemy.com/v2'],
        },
        infura: {
            http: ['https://optimism-mainnet.infura.io/v3'],
            webSocket: ['wss://optimism-mainnet.infura.io/ws/v3'],
        },
        default: {
            http: ['https://mainnet.optimism.io'],
        },
        public: {
            http: ['https://mainnet.optimism.io'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'Etherscan',
            url: 'https://optimistic.etherscan.io',
        },
        default: {
            name: 'Optimism Explorer',
            url: 'https://explorer.optimism.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 4286263,
        },
    },
}, {
    formatters: formatters_js_1.formattersOptimism,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/optimismGoerli.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/optimismGoerli.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optimismGoerli = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../optimism/formatters.js */ "../../node_modules/viem/_cjs/chains/optimism/formatters.js");
exports.optimismGoerli = (0, defineChain_js_1.defineChain)({
    id: 420,
    name: 'Optimism Goerli',
    network: 'optimism-goerli',
    nativeCurrency: { name: 'Goerli Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://opt-goerli.g.alchemy.com/v2'],
            webSocket: ['wss://opt-goerli.g.alchemy.com/v2'],
        },
        infura: {
            http: ['https://optimism-goerli.infura.io/v3'],
            webSocket: ['wss://optimism-goerli.infura.io/ws/v3'],
        },
        default: {
            http: ['https://goerli.optimism.io'],
        },
        public: {
            http: ['https://goerli.optimism.io'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'Etherscan',
            url: 'https://goerli-optimism.etherscan.io',
        },
        default: {
            name: 'Etherscan',
            url: 'https://goerli-optimism.etherscan.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 49461,
        },
    },
    testnet: true,
}, {
    formatters: formatters_js_1.formattersOptimism,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/optimismSepolia.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/optimismSepolia.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optimismSepolia = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../optimism/formatters.js */ "../../node_modules/viem/_cjs/chains/optimism/formatters.js");
exports.optimismSepolia = (0, defineChain_js_1.defineChain)({
    id: 11155420,
    name: 'Optimism Sepolia',
    network: 'optimism-sepolia',
    nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://opt-sepolia.g.alchemy.com/v2'],
            webSocket: ['wss://opt-sepolia.g.alchemy.com/v2'],
        },
        default: {
            http: ['https://sepolia.optimism.io'],
        },
        public: {
            http: ['https://sepolia.optimism.io'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'Blockscout',
            url: 'https://optimism-sepolia.blockscout.com',
        },
        default: {
            name: 'Blockscout',
            url: 'https://optimism-sepolia.blockscout.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 1620204,
        },
    },
    testnet: true,
}, {
    formatters: formatters_js_1.formattersOptimism,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/pgn.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/pgn.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pgn = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../optimism/formatters.js */ "../../node_modules/viem/_cjs/chains/optimism/formatters.js");
exports.pgn = (0, defineChain_js_1.defineChain)({
    id: 424,
    network: 'pgn',
    name: 'PGN',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.publicgoods.network'],
        },
        public: {
            http: ['https://rpc.publicgoods.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'PGN Explorer',
            url: 'https://explorer.publicgoods.network',
        },
        blocksout: {
            name: 'PGN Explorer',
            url: 'https://explorer.publicgoods.network',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 3380209,
        },
    },
}, {
    formatters: formatters_js_1.formattersOptimism,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/pgnTestnet.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/pgnTestnet.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pgnTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../optimism/formatters.js */ "../../node_modules/viem/_cjs/chains/optimism/formatters.js");
exports.pgnTestnet = (0, defineChain_js_1.defineChain)({
    id: 58008,
    network: 'pgn-testnet',
    name: 'PGN ',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://sepolia.publicgoods.network'],
        },
        public: {
            http: ['https://sepolia.publicgoods.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'PGN Testnet Explorer',
            url: 'https://explorer.sepolia.publicgoods.network',
        },
        blocksout: {
            name: 'PGN Testnet Explorer',
            url: 'https://explorer.sepolia.publicgoods.network',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 3754925,
        },
    },
    testnet: true,
}, {
    formatters: formatters_js_1.formattersOptimism,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/plinga.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/plinga.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.plinga = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.plinga = (0, defineChain_js_1.defineChain)({
    id: 242,
    name: 'Plinga',
    network: 'plinga',
    nativeCurrency: { name: 'Plinga', symbol: 'PLINGA', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpcurl.mainnet.plgchain.com'],
        },
        public: {
            http: ['https://rpcurl.mainnet.plgchain.com'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Plgscan',
            url: 'https://www.plgscan.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0x0989576160f2e7092908BB9479631b901060b6e4',
            blockCreated: 204489,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/polygon.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/polygon.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.polygon = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.polygon = (0, defineChain_js_1.defineChain)({
    id: 137,
    name: 'Polygon',
    network: 'matic',
    nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://polygon-mainnet.g.alchemy.com/v2'],
            webSocket: ['wss://polygon-mainnet.g.alchemy.com/v2'],
        },
        infura: {
            http: ['https://polygon-mainnet.infura.io/v3'],
            webSocket: ['wss://polygon-mainnet.infura.io/ws/v3'],
        },
        default: {
            http: ['https://polygon-rpc.com'],
        },
        public: {
            http: ['https://polygon-rpc.com'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'PolygonScan',
            url: 'https://polygonscan.com',
        },
        default: {
            name: 'PolygonScan',
            url: 'https://polygonscan.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 25770160,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/polygonMumbai.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/polygonMumbai.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.polygonMumbai = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.polygonMumbai = (0, defineChain_js_1.defineChain)({
    id: 80001,
    name: 'Polygon Mumbai',
    network: 'maticmum',
    nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://polygon-mumbai.g.alchemy.com/v2'],
            webSocket: ['wss://polygon-mumbai.g.alchemy.com/v2'],
        },
        infura: {
            http: ['https://polygon-mumbai.infura.io/v3'],
            webSocket: ['wss://polygon-mumbai.infura.io/ws/v3'],
        },
        default: {
            http: ['https://rpc.ankr.com/polygon_mumbai'],
        },
        public: {
            http: ['https://rpc.ankr.com/polygon_mumbai'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'PolygonScan',
            url: 'https://mumbai.polygonscan.com',
        },
        default: {
            name: 'PolygonScan',
            url: 'https://mumbai.polygonscan.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 25770160,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/polygonZkEvm.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/polygonZkEvm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.polygonZkEvm = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.polygonZkEvm = (0, defineChain_js_1.defineChain)({
    id: 1101,
    name: 'Polygon zkEVM',
    network: 'polygon-zkevm',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://zkevm-rpc.com'],
        },
        public: {
            http: ['https://zkevm-rpc.com'],
        },
    },
    blockExplorers: {
        default: {
            name: 'PolygonScan',
            url: 'https://zkevm.polygonscan.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 57746,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/polygonZkEvmTestnet.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/polygonZkEvmTestnet.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.polygonZkEvmTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.polygonZkEvmTestnet = (0, defineChain_js_1.defineChain)({
    id: 1442,
    name: 'Polygon zkEVM Testnet',
    network: 'polygon-zkevm-testnet',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.public.zkevm-test.net'],
        },
        public: {
            http: ['https://rpc.public.zkevm-test.net'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'Blockscout',
            url: 'https://explorer.public.zkevm-test.net',
        },
        default: {
            name: 'PolygonScan',
            url: 'https://testnet-zkevm.polygonscan.com',
        },
    },
    testnet: true,
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 525686,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/pulsechain.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/pulsechain.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pulsechain = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.pulsechain = (0, defineChain_js_1.defineChain)({
    id: 369,
    network: 'pulsechain',
    name: 'PulseChain',
    nativeCurrency: { name: 'Pulse', symbol: 'PLS', decimals: 18 },
    testnet: false,
    rpcUrls: {
        default: {
            http: ['https://rpc.pulsechain.com'],
            webSocket: ['wss://ws.pulsechain.com'],
        },
        public: {
            http: ['https://rpc.pulsechain.com'],
            webSocket: ['wss://ws.pulsechain.com'],
        },
    },
    blockExplorers: {
        default: {
            name: 'PulseScan',
            url: 'https://scan.pulsechain.com',
        },
    },
    contracts: {
        ensRegistry: {
            address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
        },
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 14353601,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/pulsechainV4.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/pulsechainV4.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pulsechainV4 = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.pulsechainV4 = (0, defineChain_js_1.defineChain)({
    id: 943,
    network: 'pulsechainV4',
    name: 'PulseChain V4',
    testnet: true,
    nativeCurrency: { name: 'V4 Pulse', symbol: 'v4PLS', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.v4.testnet.pulsechain.com'],
            webSocket: ['wss://ws.v4.testnet.pulsechain.com'],
        },
        public: {
            http: ['https://rpc.v4.testnet.pulsechain.com'],
            webSocket: ['wss://ws.v4.testnet.pulsechain.com'],
        },
    },
    blockExplorers: {
        default: {
            name: 'PulseScan',
            url: 'https://scan.v4.testnet.pulsechain.com',
        },
    },
    contracts: {
        ensRegistry: {
            address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
        },
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 14353601,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/qMainnet.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/qMainnet.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.qMainnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.qMainnet = (0, defineChain_js_1.defineChain)({
    id: 35441,
    name: 'Q Mainnet',
    network: 'q-mainnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Q',
        symbol: 'Q',
    },
    rpcUrls: {
        default: { http: ['https://rpc.q.org'] },
        public: { http: ['https://rpc.q.org'] },
    },
    blockExplorers: {
        default: {
            name: 'Q Mainnet Explorer',
            url: 'https://explorer.q.org',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/qTestnet.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/qTestnet.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.qTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.qTestnet = (0, defineChain_js_1.defineChain)({
    id: 35443,
    name: 'Q Testnet',
    network: 'q-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Q',
        symbol: 'Q',
    },
    rpcUrls: {
        default: { http: ['https://rpc.qtestnet.org'] },
        public: { http: ['https://rpc.qtestnet.org'] },
    },
    blockExplorers: {
        default: {
            name: 'Q Testnet Explorer',
            url: 'https://explorer.qtestnet.org',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/rollux.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/rollux.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rollux = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.rollux = (0, defineChain_js_1.defineChain)({
    id: 570,
    name: 'Rollux Mainnet',
    network: 'rollux',
    nativeCurrency: {
        decimals: 18,
        name: 'Syscoin',
        symbol: 'SYS',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.rollux.com'],
            webSocket: ['wss://rpc.rollux.com/wss'],
        },
        public: { http: ['https://rollux.public-rpc.com'] },
    },
    blockExplorers: {
        default: { name: 'RolluxExplorer', url: 'https://explorer.rollux.com' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 119222,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/rolluxTestnet.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/rolluxTestnet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rolluxTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.rolluxTestnet = (0, defineChain_js_1.defineChain)({
    id: 57000,
    name: 'Rollux Testnet',
    network: 'rollux-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Syscoin',
        symbol: 'SYS',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc-tanenbaum.rollux.com/'],
            webSocket: ['wss://rpc-tanenbaum.rollux.com/wss'],
        },
        public: { http: ['https://rpc-tanenbaum.rollux.com/'] },
    },
    blockExplorers: {
        default: {
            name: 'RolluxTestnetExplorer',
            url: 'https://rollux.tanenbaum.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 1813675,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/ronin.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/ronin.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ronin = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.ronin = (0, defineChain_js_1.defineChain)({
    id: 2020,
    name: 'Ronin',
    network: 'ronin',
    nativeCurrency: { name: 'RON', symbol: 'RON', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://api.roninchain.com/rpc'],
        },
        public: {
            http: ['https://api.roninchain.com/rpc'],
        },
    },
    blockExplorers: {
        default: { name: 'Ronin Explorer', url: 'https://app.roninchain.com' },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 26023535,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/rootstock.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/rootstock.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rootstock = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.rootstock = (0, defineChain_js_1.defineChain)({
    id: 30,
    name: 'Rootstock Mainnet',
    network: 'rootstock',
    nativeCurrency: {
        decimals: 18,
        name: 'Rootstock Bitcoin',
        symbol: 'RBTC',
    },
    rpcUrls: {
        public: { http: ['https://public-node.rsk.co'] },
        default: { http: ['https://public-node.rsk.co'] },
    },
    blockExplorers: {
        blockscout: { name: 'Blockscout', url: 'https://rootstock.blockscout.com' },
        default: { name: 'RSK Explorer', url: 'https://explorer.rsk.co' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 4249540,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/saigon.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/saigon.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.saigon = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.saigon = (0, defineChain_js_1.defineChain)({
    id: 2021,
    name: 'Saigon Testnet',
    network: 'saigon',
    nativeCurrency: { name: 'RON', symbol: 'RON', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://saigon-testnet.roninchain.com/rpc'],
        },
        public: {
            http: ['https://saigon-testnet.roninchain.com/rpc'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Saigon Explorer',
            url: 'https://saigon-explorer.roninchain.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 18736871,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/sapphire.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/sapphire.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sapphire = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.sapphire = (0, defineChain_js_1.defineChain)({
    id: 23294,
    name: 'Oasis Sapphire',
    network: 'sapphire',
    nativeCurrency: { name: 'Sapphire Rose', symbol: 'ROSE', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://sapphire.oasis.io'],
            webSocket: ['wss://sapphire.oasis.io/ws'],
        },
        public: {
            http: ['https://sapphire.oasis.io'],
            webSocket: ['wss://sapphire.oasis.io/ws'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Oasis Sapphire Explorer',
            url: 'https://explorer.sapphire.oasis.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 734531,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/sapphireTestnet.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/sapphireTestnet.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sapphireTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.sapphireTestnet = (0, defineChain_js_1.defineChain)({
    id: 23295,
    name: 'Oasis Sapphire Testnet',
    network: 'sapphire-testnet',
    nativeCurrency: { name: 'Sapphire Test Rose', symbol: 'TEST', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://testnet.sapphire.oasis.dev'],
            webSocket: ['wss://testnet.sapphire.oasis.dev/ws'],
        },
        public: {
            http: ['https://testnet.sapphire.oasis.dev'],
            webSocket: ['wss://testnet.sapphire.oasis.dev/ws'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Oasis Sapphire Testnet Explorer',
            url: 'https://testnet.explorer.sapphire.oasis.dev',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/scroll.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/scroll.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scroll = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.scroll = (0, defineChain_js_1.defineChain)({
    id: 534352,
    name: 'Scroll',
    network: 'scroll',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.scroll.io'],
            webSocket: ['wss://wss-rpc.scroll.io/ws'],
        },
        public: {
            http: ['https://rpc.scroll.io'],
            webSocket: ['wss://wss-rpc.scroll.io/ws'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Scrollscan',
            url: 'https://scrollscan.com',
        },
        blockscout: {
            name: 'Blockscout',
            url: 'https://blockscout.scroll.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 14,
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/scrollSepolia.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/scrollSepolia.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scrollSepolia = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.scrollSepolia = (0, defineChain_js_1.defineChain)({
    id: 534351,
    name: 'Scroll Sepolia',
    network: 'scroll-sepolia',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://sepolia-rpc.scroll.io'],
        },
        public: {
            http: ['https://sepolia-rpc.scroll.io'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Blockscout',
            url: 'https://sepolia-blockscout.scroll.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 9473,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/scrollTestnet.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/scrollTestnet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scrollTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.scrollTestnet = (0, defineChain_js_1.defineChain)({
    id: 534353,
    name: 'Scroll Testnet',
    network: 'scroll-testnet',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://alpha-rpc.scroll.io/l2'],
            webSocket: ['wss://alpha-rpc.scroll.io/l2/ws'],
        },
        public: {
            http: ['https://alpha-rpc.scroll.io/l2'],
            webSocket: ['wss://alpha-rpc.scroll.io/l2/ws'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Blockscout',
            url: 'https://blockscout.scroll.io',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/sepolia.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/sepolia.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sepolia = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.sepolia = (0, defineChain_js_1.defineChain)({
    id: 11155111,
    network: 'sepolia',
    name: 'Sepolia',
    nativeCurrency: { name: 'Sepolia Ether', symbol: 'SEP', decimals: 18 },
    rpcUrls: {
        alchemy: {
            http: ['https://eth-sepolia.g.alchemy.com/v2'],
            webSocket: ['wss://eth-sepolia.g.alchemy.com/v2'],
        },
        infura: {
            http: ['https://sepolia.infura.io/v3'],
            webSocket: ['wss://sepolia.infura.io/ws/v3'],
        },
        default: {
            http: ['https://rpc.sepolia.org'],
        },
        public: {
            http: ['https://rpc.sepolia.org'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'Etherscan',
            url: 'https://sepolia.etherscan.io',
        },
        default: {
            name: 'Etherscan',
            url: 'https://sepolia.etherscan.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 751532,
        },
        ensRegistry: { address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e' },
        ensUniversalResolver: {
            address: '0x21B000Fd62a880b2125A61e36a284BB757b76025',
            blockCreated: 3914906,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/shardeumSphinx.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/shardeumSphinx.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shardeumSphinx = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.shardeumSphinx = (0, defineChain_js_1.defineChain)({
    id: 8082,
    name: 'Shardeum Sphinx',
    network: 'shmSphinx',
    nativeCurrency: { name: 'SHARDEUM', symbol: 'SHM', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://sphinx.shardeum.org'],
        },
        public: {
            http: ['https://sphinx.shardeum.org'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Shardeum Explorer',
            url: 'https://explorer-sphinx.shardeum.org',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/shibarium.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/shibarium.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shibarium = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.shibarium = (0, defineChain_js_1.defineChain)({
    id: 109,
    name: 'Shibarium',
    network: 'shibarium',
    nativeCurrency: { name: 'Bone', symbol: 'BONE', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.shibrpc.com'],
        },
        public: {
            http: ['https://rpc.shibrpc.com'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'Blockscout',
            url: 'https://shibariumscan.io',
        },
        default: {
            name: 'Blockscout',
            url: 'https://shibariumscan.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0x864Bf681ADD6052395188A89101A1B37d3B4C961',
            blockCreated: 265900,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/shimmer.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/shimmer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shimmer = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.shimmer = (0, defineChain_js_1.defineChain)({
    id: 148,
    name: 'Shimmer',
    network: 'shimmer',
    nativeCurrency: {
        decimals: 18,
        name: 'Shimmer',
        symbol: 'SMR',
    },
    rpcUrls: {
        public: {
            http: ['https://json-rpc.evm.shimmer.network'],
        },
        default: {
            http: ['https://json-rpc.evm.shimmer.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Shimmer Network Explorer',
            url: 'https://explorer.evm.shimmer.network',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/shimmerTestnet.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/shimmerTestnet.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shimmerTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.shimmerTestnet = (0, defineChain_js_1.defineChain)({
    id: 1073,
    name: 'Shimmer Testnet',
    network: 'shimmer-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Shimmer',
        symbol: 'SMR',
    },
    rpcUrls: {
        public: {
            http: ['https://json-rpc.evm.testnet.shimmer.network'],
        },
        default: {
            http: ['https://json-rpc.evm.testnet.shimmer.network'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Shimmer Network Explorer',
            url: 'https://explorer.evm.testnet.shimmer.network',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/brawl.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/brawl.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleBlockBrawlers = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleBlockBrawlers = (0, defineChain_js_1.defineChain)({
    id: 391845894,
    name: 'SKALE | Block Brawlers',
    network: 'skale-brawl',
    nativeCurrency: { name: 'BRAWL', symbol: 'BRAWL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.skalenodes.com/v1/frayed-decent-antares'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares'],
        },
        public: {
            http: ['https://mainnet.skalenodes.com/v1/frayed-decent-antares'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://frayed-decent-antares.explorer.mainnet.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://frayed-decent-antares.explorer.mainnet.skalenodes.com',
        },
    },
    contracts: {},
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/calypso.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/calypso.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleCalypso = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleCalypso = (0, defineChain_js_1.defineChain)({
    id: 1564830818,
    name: 'SKALE | Calypso NFT Hub',
    network: 'skale-calypso',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague'],
            webSocket: [
                'wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague',
            ],
        },
        public: {
            http: ['https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague'],
            webSocket: [
                'wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague',
            ],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 3107626,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/calypsoTestnet.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/calypsoTestnet.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleCalypsoTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleCalypsoTestnet = (0, defineChain_js_1.defineChain)({
    id: 344106930,
    name: 'SKALE | Calypso NFT Hub Testnet',
    network: 'skale-calypso-testnet',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: [
                'https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar',
            ],
            webSocket: [
                'wss://staging-v3.skalenodes.com/v1/ws/staging-utter-unripe-menkar',
            ],
        },
        public: {
            http: [
                'https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar',
            ],
            webSocket: [
                'wss://staging-v3.skalenodes.com/v1/ws/staging-utter-unripe-menkar',
            ],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 2131424,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/chaosTestnet.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/chaosTestnet.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleChaosTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleChaosTestnet = (0, defineChain_js_1.defineChain)({
    id: 1351057110,
    name: 'SKALE | Chaos Testnet',
    network: 'skale-chaos-testnet',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: [
                'https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix',
            ],
            webSocket: [
                'wss://staging-v3.skalenodes.com/v1/ws/staging-fast-active-bellatrix',
            ],
        },
        public: {
            http: [
                'https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix',
            ],
            webSocket: [
                'wss://staging-v3.skalenodes.com/v1/ws/staging-fast-active-bellatrix',
            ],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 1192202,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/cryptoBlades.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/cryptoBlades.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleCryptoBlades = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleCryptoBlades = (0, defineChain_js_1.defineChain)({
    id: 1026062157,
    name: 'SKALE | CryptoBlades',
    network: 'skale-cryptoblades',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux'],
            webSocket: [
                'wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux',
            ],
        },
        public: {
            http: ['https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux'],
            webSocket: [
                'wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux',
            ],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com',
        },
    },
    contracts: {},
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/cryptoColosseum.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/cryptoColosseum.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleCryptoColosseum = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleCryptoColosseum = (0, defineChain_js_1.defineChain)({
    id: 2046399126,
    name: 'SKALE | Crypto Colosseum',
    network: 'skale-crypto-coloseeum',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.skalenodes.com/v1/haunting-devoted-deneb'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb'],
        },
        public: {
            http: ['https://mainnet.skalenodes.com/v1/haunting-devoted-deneb'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com',
        },
    },
    contracts: {},
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/europa.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/europa.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleEuropa = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleEuropa = (0, defineChain_js_1.defineChain)({
    id: 2046399126,
    name: 'SKALE | Europa Liquidity Hub',
    network: 'skale-europa',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.skalenodes.com/v1/elated-tan-skat'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat'],
        },
        public: {
            http: ['https://mainnet.skalenodes.com/v1/elated-tan-skat'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://elated-tan-skat.explorer.mainnet.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://elated-tan-skat.explorer.mainnet.skalenodes.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 3113495,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/europaTestnet.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/europaTestnet.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleEuropaTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleEuropaTestnet = (0, defineChain_js_1.defineChain)({
    id: 476158412,
    name: 'SKALE | Europa Liquidity Hub Testnet',
    network: 'skale-europa-testnet',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor'],
            webSocket: [
                'wss://staging-v3.skalenodes.com/v1/ws/staging-legal-crazy-castor',
            ],
        },
        public: {
            http: ['https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor'],
            webSocket: [
                'wss://staging-v3.skalenodes.com/v1/ws/staging-legal-crazy-castor',
            ],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 2071911,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/exorde.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/exorde.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleExorde = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleExorde = (0, defineChain_js_1.defineChain)({
    id: 2139927552,
    name: 'SKALE | Exorde',
    network: 'skale-exorde',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.skalenodes.com/v1/light-vast-diphda'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda'],
        },
        public: {
            http: ['https://mainnet.skalenodes.com/v1/light-vast-diphda'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://light-vast-diphda.explorer.mainnet.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://light-vast-diphda.explorer.mainnet.skalenodes.com',
        },
    },
    contracts: {},
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/humanProtocol.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/humanProtocol.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleHumanProtocol = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleHumanProtocol = (0, defineChain_js_1.defineChain)({
    id: 1273227453,
    name: 'SKALE | Human Protocol',
    network: 'skale-human-protocol',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.skalenodes.com/v1/wan-red-ain'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/wan-red-ain'],
        },
        public: {
            http: ['https://mainnet.skalenodes.com/v1/wan-red-ain'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/wan-red-ain'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://wan-red-ain.explorer.mainnet.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://wan-red-ain.explorer.mainnet.skalenodes.com',
        },
    },
    contracts: {},
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/nebula.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/nebula.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleNebula = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleNebula = (0, defineChain_js_1.defineChain)({
    id: 1482601649,
    name: 'SKALE | Nebula Gaming Hub',
    network: 'skale-nebula',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.skalenodes.com/v1/green-giddy-denebola'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola'],
        },
        public: {
            http: ['https://mainnet.skalenodes.com/v1/green-giddy-denebola'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://green-giddy-denebola.explorer.mainnet.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://green-giddy-denebola.explorer.mainnet.skalenodes.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 2372986,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/nebulaTestnet.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/nebulaTestnet.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleNebulaTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleNebulaTestnet = (0, defineChain_js_1.defineChain)({
    id: 503129905,
    name: 'SKALE | Nebula Gaming Hub Testnet',
    network: 'skale-nebula-testnet',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird'],
            webSocket: [
                'wss://staging-v3.skalenodes.com/v1/ws/staging-faint-slimy-achird',
            ],
        },
        public: {
            http: ['https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird'],
            webSocket: [
                'wss://staging-v3.skalenodes.com/v1/ws/staging-faint-slimy-achird',
            ],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 2205882,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/razor.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/razor.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleRazor = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleRazor = (0, defineChain_js_1.defineChain)({
    id: 278611351,
    name: 'SKALE | Razor Network',
    network: 'skale-razor',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.skalenodes.com/v1/turbulent-unique-scheat'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat'],
        },
        public: {
            http: ['https://mainnet.skalenodes.com/v1/turbulent-unique-scheat'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com',
        },
    },
    contracts: {},
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/titan.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/titan.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleTitan = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleTitan = (0, defineChain_js_1.defineChain)({
    id: 1350216234,
    name: 'SKALE | Titan Community Hub',
    network: 'skale-titan',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.skalenodes.com/v1/parallel-stormy-spica'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica'],
        },
        public: {
            http: ['https://mainnet.skalenodes.com/v1/parallel-stormy-spica'],
            webSocket: ['wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica'],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://parallel-stormy-spica.explorer.mainnet.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://parallel-stormy-spica.explorer.mainnet.skalenodes.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 2076458,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/skale/titanTestnet.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/skale/titanTestnet.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skaleTitanTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.skaleTitanTestnet = (0, defineChain_js_1.defineChain)({
    id: 1517929550,
    name: 'SKALE | Titan Community Hub Testnet',
    network: 'skale-titan-testnet',
    nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },
    rpcUrls: {
        default: {
            http: [
                'https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar',
            ],
            webSocket: [
                'wss://staging-v3.skalenodes.com/v1/ws/staging-aware-chief-gianfar',
            ],
        },
        public: {
            http: [
                'https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar',
            ],
            webSocket: [
                'wss://staging-v3.skalenodes.com/v1/ws/staging-aware-chief-gianfar',
            ],
        },
    },
    blockExplorers: {
        blockscout: {
            name: 'SKALE Explorer',
            url: 'https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com',
        },
        default: {
            name: 'SKALE Explorer',
            url: 'https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 2085155,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/songbird.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/songbird.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.songbird = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.songbird = (0, defineChain_js_1.defineChain)({
    id: 19,
    name: 'Songbird Mainnet',
    network: 'songbird-mainnet',
    nativeCurrency: {
        decimals: 18,
        name: 'songbird',
        symbol: 'SGB',
    },
    rpcUrls: {
        default: { http: ['https://songbird-api.flare.network/ext/C/rpc'] },
        public: { http: ['https://songbird-api.flare.network/ext/C/rpc'] },
    },
    blockExplorers: {
        default: {
            name: 'Songbird Explorer',
            url: 'https://songbird-explorer.flare.network',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/songbirdTestnet.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/songbirdTestnet.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.songbirdTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.songbirdTestnet = (0, defineChain_js_1.defineChain)({
    id: 16,
    name: 'Coston',
    network: 'coston',
    nativeCurrency: {
        decimals: 18,
        name: 'costonflare',
        symbol: 'CFLR',
    },
    rpcUrls: {
        default: { http: ['https://coston-api.flare.network/ext/C/rpc'] },
        public: { http: ['https://coston-api.flare.network/ext/C/rpc'] },
    },
    blockExplorers: {
        default: {
            name: 'Coston Explorer',
            url: 'https://coston-explorer.flare.network',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/spicy.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/spicy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.spicy = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.spicy = (0, defineChain_js_1.defineChain)({
    id: 88882,
    name: 'Chiliz Spicy Testnet',
    network: 'chiliz-spicy-Testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'CHZ',
        symbol: 'CHZ',
    },
    rpcUrls: {
        default: {
            http: [
                'https://spicy-rpc.chiliz.com',
                'https://chiliz-spicy.publicnode.com',
            ],
            webSocket: [
                'wss://spicy-rpc-ws.chiliz.com',
                'wss://chiliz-spicy.publicnode.com',
            ],
        },
        public: {
            http: [
                'https://spicy-rpc.chiliz.com',
                'https://chiliz-spicy.publicnode.com',
            ],
            webSocket: [
                'wss://spicy-rpc-ws.chiliz.com',
                'wss://chiliz-spicy.publicnode.com',
            ],
        },
    },
    blockExplorers: {
        default: {
            name: 'Chiliz Explorer',
            url: 'http://spicy-explorer.chiliz.com',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/syscoin.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/syscoin.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.syscoin = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.syscoin = (0, defineChain_js_1.defineChain)({
    id: 57,
    name: 'Syscoin Mainnet',
    network: 'syscoin',
    nativeCurrency: {
        decimals: 18,
        name: 'Syscoin',
        symbol: 'SYS',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.syscoin.org'],
            webSocket: ['wss://rpc.syscoin.org/wss'],
        },
        public: {
            http: ['https://rpc.syscoin.org'],
            webSocket: ['wss://rpc.syscoin.org/wss'],
        },
    },
    blockExplorers: {
        default: { name: 'SyscoinExplorer', url: 'https://explorer.syscoin.org' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 287139,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/syscoinTestnet.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/syscoinTestnet.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.syscoinTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.syscoinTestnet = (0, defineChain_js_1.defineChain)({
    id: 5700,
    name: 'Syscoin Tanenbaum Testnet',
    network: 'syscoin-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Syscoin',
        symbol: 'SYS',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.tanenbaum.io'],
            webSocket: ['wss://rpc.tanenbaum.io/wss'],
        },
        public: {
            http: ['https://rpc.tanenbaum.io'],
            webSocket: ['wss://rpc.tanenbaum.io/wss'],
        },
    },
    blockExplorers: {
        default: { name: 'SyscoinTestnetExplorer', url: 'https://tanenbaum.io' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 271288,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/taikoJolnir.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/taikoJolnir.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.taikoJolnir = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.taikoJolnir = (0, defineChain_js_1.defineChain)({
    id: 167007,
    name: 'Taiko Jolnir (Alpha-5 Testnet)',
    network: 'tko-jolnir',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.jolnir.taiko.xyz'],
        },
        public: {
            http: ['https://rpc.jolnir.taiko.xyz'],
        },
    },
    blockExplorers: {
        default: {
            name: 'blockscout',
            url: 'https://explorer.jolnir.taiko.xyz',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/taikoTestnetSepolia.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/taikoTestnetSepolia.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.taikoTestnetSepolia = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.taikoTestnetSepolia = (0, defineChain_js_1.defineChain)({
    id: 167005,
    name: 'Taiko (Alpha-3 Testnet)',
    network: 'taiko-sepolia',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.test.taiko.xyz'],
        },
        public: {
            http: ['https://rpc.test.taiko.xyz'],
        },
    },
    blockExplorers: {
        default: {
            name: 'blockscout',
            url: 'https://explorer.test.taiko.xyz',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/taraxa.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/taraxa.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.taraxa = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.taraxa = (0, defineChain_js_1.defineChain)({
    id: 841,
    name: 'Taraxa Mainnet',
    network: 'taraxa',
    nativeCurrency: { name: 'Tara', symbol: 'TARA', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.mainnet.taraxa.io'],
        },
        public: {
            http: ['https://rpc.mainnet.taraxa.io'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Taraxa Explorer',
            url: 'https://explorer.mainnet.taraxa.io',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/taraxaTestnet.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/taraxaTestnet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.taraxaTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.taraxaTestnet = (0, defineChain_js_1.defineChain)({
    id: 842,
    name: 'Taraxa Testnet',
    network: 'taraxa-testnet',
    nativeCurrency: { name: 'Tara', symbol: 'TARA', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.testnet.taraxa.io'],
        },
        public: {
            http: ['https://rpc.testnet.taraxa.io'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Taraxa Explorer',
            url: 'https://explorer.testnet.taraxa.io',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/telos.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/telos.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.telos = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.telos = (0, defineChain_js_1.defineChain)({
    id: 40,
    name: 'Telos',
    network: 'telos',
    nativeCurrency: {
        decimals: 18,
        name: 'Telos',
        symbol: 'TLOS',
    },
    rpcUrls: {
        default: { http: ['https://mainnet.telos.net/evm'] },
        public: { http: ['https://mainnet.telos.net/evm'] },
    },
    blockExplorers: {
        default: {
            name: 'Teloscan',
            url: 'https://www.teloscan.io/',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 246530709,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/telosTestnet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/telosTestnet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.telosTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.telosTestnet = (0, defineChain_js_1.defineChain)({
    id: 41,
    name: 'Telos',
    network: 'telosTestnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Telos',
        symbol: 'TLOS',
    },
    rpcUrls: {
        default: { http: ['https://testnet.telos.net/evm'] },
        public: { http: ['https://testnet.telos.net/evm'] },
    },
    blockExplorers: {
        default: {
            name: 'Teloscan (testnet)',
            url: 'https://testnet.teloscan.io/',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/tenet.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/tenet.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tenet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.tenet = (0, defineChain_js_1.defineChain)({
    id: 1559,
    name: 'Tenet',
    network: 'tenet-mainnet',
    nativeCurrency: {
        name: 'TENET',
        symbol: 'TENET',
        decimals: 18,
    },
    rpcUrls: {
        public: { http: ['https://rpc.tenet.org'] },
        default: { http: ['https://rpc.tenet.org'] },
    },
    blockExplorers: {
        default: { name: 'TenetScan Mainnet', url: 'https://tenetscan.io' },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/thunderTestnet.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/thunderTestnet.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.thunderTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.thunderTestnet = (0, defineChain_js_1.defineChain)({
    id: 997,
    name: '5ireChain Thunder Testnet',
    network: '5ireChain',
    nativeCurrency: { name: '5ire Token', symbol: '5IRE', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc-testnet.5ire.network'],
        },
        public: {
            http: ['https://rpc-testnet.5ire.network'],
        },
    },
    blockExplorers: {
        default: {
            name: '5ireChain Explorer',
            url: 'https://explorer.5ire.network',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/vechain.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/vechain.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vechain = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.vechain = (0, defineChain_js_1.defineChain)({
    id: 100009,
    name: 'Vechain',
    network: 'vechain',
    nativeCurrency: { name: 'VeChain', symbol: 'VET', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://mainnet.vechain.org'],
        },
        public: {
            http: ['https://mainnet.vechain.org'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Vechain Explorer',
            url: 'https://explore.vechain.org',
        },
        vechainStats: {
            name: 'Vechain Stats',
            url: 'https://vechainstats.com',
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/wanchain.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/wanchain.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wanchain = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.wanchain = (0, defineChain_js_1.defineChain)({
    id: 888,
    name: 'Wanchain',
    network: 'wanchain',
    nativeCurrency: { name: 'WANCHAIN', symbol: 'WAN', decimals: 18 },
    rpcUrls: {
        default: {
            http: [
                'https://gwan-ssl.wandevs.org:56891',
                'https://gwan2-ssl.wandevs.org',
            ],
        },
        public: {
            http: [
                'https://gwan-ssl.wandevs.org:56891',
                'https://gwan2-ssl.wandevs.org',
            ],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'WanScan',
            url: 'https://wanscan.org',
        },
        default: {
            name: 'WanScan',
            url: 'https://wanscan.org',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB',
            blockCreated: 25312390,
        },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/wanchainTestnet.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/wanchainTestnet.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wanchainTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.wanchainTestnet = (0, defineChain_js_1.defineChain)({
    id: 999,
    name: 'Wanchain Testnet',
    network: 'wanchainTestnet',
    nativeCurrency: { name: 'WANCHAIN', symbol: 'WANt', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://gwan-ssl.wandevs.org:46891'],
        },
        public: {
            http: ['https://gwan-ssl.wandevs.org:46891'],
        },
    },
    blockExplorers: {
        etherscan: {
            name: 'WanScanTest',
            url: 'https://wanscan.org',
        },
        default: {
            name: 'WanScanTest',
            url: 'https://wanscan.org',
        },
    },
    contracts: {
        multicall3: {
            address: '0x11c89bF4496c39FB80535Ffb4c92715839CC5324',
            blockCreated: 24743448,
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/wemix.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/wemix.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wemix = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.wemix = (0, defineChain_js_1.defineChain)({
    id: 1111,
    name: 'WEMIX',
    network: 'wemix-mainnet',
    nativeCurrency: { name: 'WEMIX', symbol: 'WEMIX', decimals: 18 },
    rpcUrls: {
        default: { http: ['https://api.wemix.com'] },
        public: { http: ['https://api.wemix.com'] },
    },
    blockExplorers: {
        etherscan: { name: 'wemixExplorer', url: 'https://explorer.wemix.com' },
        default: { name: 'wemixExplorer', url: 'https://explorer.wemix.com' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/wemixTestnet.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/wemixTestnet.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wemixTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.wemixTestnet = (0, defineChain_js_1.defineChain)({
    id: 1112,
    name: 'WEMIX Testnet',
    network: 'wemix-testnet',
    nativeCurrency: { name: 'WEMIX', symbol: 'tWEMIX', decimals: 18 },
    rpcUrls: {
        default: { http: ['https://api.test.wemix.com'] },
        public: { http: ['https://api.test.wemix.com'] },
    },
    blockExplorers: {
        etherscan: { name: 'wemixExplorer', url: 'https://testnet.wemixscan.com' },
        default: { name: 'wemixExplorer', url: 'https://testnet.wemixscan.com' },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/xdc.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/xdc.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.xdc = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.xdc = (0, defineChain_js_1.defineChain)({
    id: 50,
    name: 'XinFin Network',
    network: 'xdc',
    nativeCurrency: {
        decimals: 18,
        name: 'XDC',
        symbol: 'XDC',
    },
    rpcUrls: {
        default: { http: ['https://rpc.xinfin.network'] },
        public: { http: ['https://rpc.xinfin.network'] },
    },
    blockExplorers: {
        xinfin: { name: 'XinFin', url: 'https://explorer.xinfin.network' },
        default: { name: 'Blocksscan', url: 'https://xdc.blocksscan.io' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/xdcTestnet.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/xdcTestnet.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.xdcTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.xdcTestnet = (0, defineChain_js_1.defineChain)({
    id: 51,
    name: 'Apothem Network',
    network: 'xdc-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'TXDC',
        symbol: 'TXDC',
    },
    rpcUrls: {
        default: { http: ['https://erpc.apothem.network'] },
        public: { http: ['https://erpc.apothem.network'] },
    },
    blockExplorers: {
        xinfin: { name: 'XinFin', url: 'https://explorer.apothem.network' },
        default: { name: 'Blocksscan', url: 'https://apothem.blocksscan.io' },
    },
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zetachainAthensTestnet.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zetachainAthensTestnet.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zetachainAthensTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.zetachainAthensTestnet = (0, defineChain_js_1.defineChain)({
    id: 7001,
    name: 'ZetaChain Athens Testnet',
    network: 'zetachain-athens-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Zeta',
        symbol: 'aZETA',
    },
    rpcUrls: {
        public: {
            http: ['https://zetachain-athens-evm.blockpi.network/v1/rpc/public'],
        },
        default: {
            http: ['https://zetachain-athens-evm.blockpi.network/v1/rpc/public'],
        },
    },
    blockExplorers: {
        default: {
            name: 'ZetaScan',
            url: 'https://athens3.explorer.zetachain.com',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zhejiang.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zhejiang.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zhejiang = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.zhejiang = (0, defineChain_js_1.defineChain)({
    id: 1337803,
    network: 'zhejiang',
    name: 'Zhejiang',
    nativeCurrency: { name: 'Zhejiang Ether', symbol: 'ZhejETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://rpc.zhejiang.ethpandaops.io'],
        },
        public: {
            http: ['https://rpc.zhejiang.ethpandaops.io'],
        },
    },
    blockExplorers: {
        beaconchain: {
            name: 'Etherscan',
            url: 'https://zhejiang.beaconcha.in',
        },
        blockscout: {
            name: 'Blockscout',
            url: 'https://blockscout.com/eth/zhejiang-testnet',
        },
        default: {
            name: 'Beaconchain',
            url: 'https://zhejiang.beaconcha.in',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zilliqa.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zilliqa.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zilliqa = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.zilliqa = (0, defineChain_js_1.defineChain)({
    id: 32769,
    name: 'Zilliqa',
    network: 'zilliqa',
    nativeCurrency: { name: 'Zilliqa', symbol: 'ZIL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://api.zilliqa.com'],
        },
        public: {
            http: ['https://api.zilliqa.com'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Ethernal',
            url: 'https://evmx.zilliqa.com',
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zilliqaTestnet.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zilliqaTestnet.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zilliqaTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.zilliqaTestnet = (0, defineChain_js_1.defineChain)({
    id: 33101,
    name: 'Zilliqa Testnet',
    network: 'zilliqa-testnet',
    nativeCurrency: { name: 'Zilliqa', symbol: 'ZIL', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://dev-api.zilliqa.com'],
        },
        public: {
            http: ['https://dev-api.zilliqa.com'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Ethernal',
            url: 'https://evmx.testnet.zilliqa.com',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zkFair.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zkFair.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zkFair = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.zkFair = (0, defineChain_js_1.defineChain)({
    id: 42766,
    name: 'ZKFair Mainnet',
    network: 'zkfair-mainnet',
    nativeCurrency: {
        decimals: 18,
        name: 'USD Coin',
        symbol: 'USDC',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.zkfair.io'],
        },
        public: {
            http: ['https://rpc.zkfair.io'],
        },
    },
    blockExplorers: {
        default: {
            name: 'zkFair Explorer',
            url: 'https://scan.zkfair.io',
        },
    },
    testnet: false,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zkFairTestnet.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zkFairTestnet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zkFairTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
exports.zkFairTestnet = (0, defineChain_js_1.defineChain)({
    id: 43851,
    name: 'ZKFair Testnet',
    network: 'zkfair-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'USD Coin',
        symbol: 'USDC',
    },
    rpcUrls: {
        default: {
            http: ['https://testnet-rpc.zkfair.io'],
        },
        public: {
            http: ['https://testnet-rpc.zkfair.io'],
        },
    },
    blockExplorers: {
        default: {
            name: 'zkFair Explorer',
            url: 'https://testnet-scan.zkfair.io',
        },
    },
    testnet: true,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zkSync.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zkSync.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zkSync = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../zksync/formatters.js */ "../../node_modules/viem/_cjs/chains/zksync/formatters.js");
const serializers_js_1 = __webpack_require__(/*! ../zksync/serializers.js */ "../../node_modules/viem/_cjs/chains/zksync/serializers.js");
exports.zkSync = (0, defineChain_js_1.defineChain)({
    id: 324,
    name: 'zkSync Era',
    network: 'zksync-era',
    nativeCurrency: {
        decimals: 18,
        name: 'Ether',
        symbol: 'ETH',
    },
    rpcUrls: {
        default: {
            http: ['https://mainnet.era.zksync.io'],
            webSocket: ['wss://mainnet.era.zksync.io/ws'],
        },
        public: {
            http: ['https://mainnet.era.zksync.io'],
            webSocket: ['wss://mainnet.era.zksync.io/ws'],
        },
    },
    blockExplorers: {
        default: {
            name: 'zkExplorer',
            url: 'https://explorer.zksync.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xF9cda624FBC7e059355ce98a31693d299FACd963',
        },
    },
}, {
    serializers: serializers_js_1.serializersZkSync,
    formatters: formatters_js_1.formattersZkSync,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zkSyncSepoliaTestnet.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zkSyncSepoliaTestnet.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zkSyncSepoliaTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../zksync/formatters.js */ "../../node_modules/viem/_cjs/chains/zksync/formatters.js");
const serializers_js_1 = __webpack_require__(/*! ../zksync/serializers.js */ "../../node_modules/viem/_cjs/chains/zksync/serializers.js");
exports.zkSyncSepoliaTestnet = (0, defineChain_js_1.defineChain)({
    id: 300,
    name: 'zkSync Sepolia Testnet',
    network: 'zksync-sepolia-testnet',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://sepolia.era.zksync.dev'],
            webSocket: ['wss://sepolia.era.zksync.dev/ws'],
        },
        public: {
            http: ['https://sepolia.era.zksync.dev'],
            webSocket: ['wss://sepolia.era.zksync.dev/ws'],
        },
    },
    blockExplorers: {
        default: {
            name: 'zkExplorer',
            url: 'https://sepolia.explorer.zksync.io/',
        },
    },
    contracts: {
        multicall3: {
            address: '0xF9cda624FBC7e059355ce98a31693d299FACd963',
        },
    },
    testnet: true,
}, {
    serializers: serializers_js_1.serializersZkSync,
    formatters: formatters_js_1.formattersZkSync,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zkSyncTestnet.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zkSyncTestnet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zkSyncTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../zksync/formatters.js */ "../../node_modules/viem/_cjs/chains/zksync/formatters.js");
const serializers_js_1 = __webpack_require__(/*! ../zksync/serializers.js */ "../../node_modules/viem/_cjs/chains/zksync/serializers.js");
exports.zkSyncTestnet = (0, defineChain_js_1.defineChain)({
    id: 280,
    name: 'zkSync Era Testnet',
    network: 'zksync-era-testnet',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
        default: {
            http: ['https://testnet.era.zksync.dev'],
            webSocket: ['wss://testnet.era.zksync.dev/ws'],
        },
        public: {
            http: ['https://testnet.era.zksync.dev'],
            webSocket: ['wss://testnet.era.zksync.dev/ws'],
        },
    },
    blockExplorers: {
        default: {
            name: 'zkExplorer',
            url: 'https://goerli.explorer.zksync.io',
        },
    },
    contracts: {
        multicall3: {
            address: '0xF9cda624FBC7e059355ce98a31693d299FACd963',
        },
    },
    testnet: true,
}, {
    serializers: serializers_js_1.serializersZkSync,
    formatters: formatters_js_1.formattersZkSync,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zora.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zora.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zora = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../optimism/formatters.js */ "../../node_modules/viem/_cjs/chains/optimism/formatters.js");
exports.zora = (0, defineChain_js_1.defineChain)({
    id: 7777777,
    name: 'Zora',
    network: 'zora',
    nativeCurrency: {
        decimals: 18,
        name: 'Ether',
        symbol: 'ETH',
    },
    rpcUrls: {
        default: {
            http: ['https://rpc.zora.energy'],
            webSocket: ['wss://rpc.zora.energy'],
        },
        public: {
            http: ['https://rpc.zora.energy'],
            webSocket: ['wss://rpc.zora.energy'],
        },
    },
    blockExplorers: {
        default: { name: 'Explorer', url: 'https://explorer.zora.energy' },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 5882,
        },
    },
}, {
    formatters: formatters_js_1.formattersOptimism,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zoraSepolia.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zoraSepolia.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zoraSepolia = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../optimism/formatters.js */ "../../node_modules/viem/_cjs/chains/optimism/formatters.js");
exports.zoraSepolia = (0, defineChain_js_1.defineChain)({
    id: 999999999,
    name: 'Zora Sepolia',
    network: 'zora-sepolia',
    nativeCurrency: {
        decimals: 18,
        name: 'Zora Sepolia',
        symbol: 'ETH',
    },
    rpcUrls: {
        default: {
            http: ['https://sepolia.rpc.zora.energy'],
            webSocket: ['wss://sepolia.rpc.zora.energy'],
        },
        public: {
            http: ['https://sepolia.rpc.zora.energy'],
            webSocket: ['wss://sepolia.rpc.zora.energy'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Zora Sepolia Explorer',
            url: 'https://sepolia.explorer.zora.energy/',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 83160,
        },
    },
    testnet: true,
}, {
    formatters: formatters_js_1.formattersOptimism,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/definitions/zoraTestnet.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/definitions/zoraTestnet.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zoraTestnet = void 0;
const defineChain_js_1 = __webpack_require__(/*! ../../utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
const formatters_js_1 = __webpack_require__(/*! ../optimism/formatters.js */ "../../node_modules/viem/_cjs/chains/optimism/formatters.js");
exports.zoraTestnet = (0, defineChain_js_1.defineChain)({
    id: 999,
    name: 'Zora Goerli Testnet',
    network: 'zora-testnet',
    nativeCurrency: {
        decimals: 18,
        name: 'Zora Goerli',
        symbol: 'ETH',
    },
    rpcUrls: {
        default: {
            http: ['https://testnet.rpc.zora.energy'],
            webSocket: ['wss://testnet.rpc.zora.energy'],
        },
        public: {
            http: ['https://testnet.rpc.zora.energy'],
            webSocket: ['wss://testnet.rpc.zora.energy'],
        },
    },
    blockExplorers: {
        default: {
            name: 'Explorer',
            url: 'https://testnet.explorer.zora.energy',
        },
    },
    contracts: {
        multicall3: {
            address: '0xcA11bde05977b3631167028862bE2a173976CA11',
            blockCreated: 189123,
        },
    },
    testnet: true,
}, {
    formatters: formatters_js_1.formattersOptimism,
});


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fantomSonicTestnet = exports.fantom = exports.ektaTestnet = exports.ekta = exports.evmosTestnet = exports.evmos = exports.eosTestnet = exports.eos = exports.edgewareTestnet = exports.edgeware = exports.dogechain = exports.dfk = exports.crossbell = exports.cronosTestnet = exports.cronos = exports.coreDao = exports.confluxESpaceTestnet = exports.confluxESpace = exports.classic = exports.celoCannoli = exports.chiliz = exports.celoAlfajores = exports.celo = exports.canto = exports.bxnTestnet = exports.bxn = exports.bscTestnet = exports.bsc = exports.bronosTestnet = exports.bronos = exports.boba = exports.bitTorrentTestnet = exports.bitTorrent = exports.bearNetworkChainTestnet = exports.bearNetworkChainMainnet = exports.baseSepolia = exports.baseGoerli = exports.base = exports.bahamut = exports.avalancheFuji = exports.avalanche = exports.auroraTestnet = exports.aurora = exports.astarZkatana = exports.arbitrumSepolia = exports.astar = exports.arbitrumNova = exports.arbitrumGoerli = exports.arbitrum = exports.acala = void 0;
exports.moonriver = exports.moonbeamDev = exports.moonbeam = exports.moonbaseAlpha = exports.modeTestnet = exports.mevTestnet = exports.mev = exports.metisGoerli = exports.metis = exports.meterTestnet = exports.meter = exports.mantleTestnet = exports.mantle = exports.mantaTestnet = exports.manta = exports.mandala = exports.mainnet = exports.lukso = exports.localhost = exports.lineaTestnet = exports.linea = exports.kromaSepolia = exports.kroma = exports.klaytnBaobab = exports.klaytn = exports.kavaTestnet = exports.kava = exports.holesky = exports.haqqTestedge2 = exports.haqqMainnet = exports.harmonyOne = exports.hardhat = exports.gnosisChiado = exports.gnosis = exports.goerli = exports.gobi = exports.karura = exports.jbc = exports.iotexTestnet = exports.iotex = exports.fuseSparknet = exports.fuse = exports.foundry = exports.flareTestnet = exports.flare = exports.filecoinHyperspace = exports.filecoinCalibration = exports.filecoin = exports.fibo = exports.fantomTestnet = void 0;
exports.skaleTitan = exports.skaleRazor = exports.skaleNebulaTestnet = exports.skaleNebula = exports.skaleHumanProtocol = exports.skaleExorde = exports.skaleEuropaTestnet = exports.skaleEuropa = exports.skaleCryptoColosseum = exports.skaleCryptoBlades = exports.skaleChaosTestnet = exports.skaleCalypsoTestnet = exports.skaleCalypso = exports.skaleBlockBrawlers = exports.shimmerTestnet = exports.shimmer = exports.sepolia = exports.scrollTestnet = exports.scrollSepolia = exports.scroll = exports.sapphireTestnet = exports.sapphire = exports.saigon = exports.rootstock = exports.ronin = exports.rolluxTestnet = exports.rollux = exports.qTestnet = exports.qMainnet = exports.pulsechainV4 = exports.pulsechain = exports.polygonZkEvm = exports.polygonZkEvmTestnet = exports.polygonMumbai = exports.polygon = exports.plinga = exports.pgnTestnet = exports.pgn = exports.opBNBTestnet = exports.opBNB = exports.optimismSepolia = exports.optimismGoerli = exports.optimism = exports.okc = exports.oasisTestnet = exports.oasys = exports.nexilix = exports.nexi = exports.neonMainnet = exports.neonDevnet = void 0;
exports.zoraTestnet = exports.zoraSepolia = exports.zora = exports.zilliqaTestnet = exports.zilliqa = exports.zetachainAthensTestnet = exports.zkSyncSepoliaTestnet = exports.zkSyncTestnet = exports.zkSync = exports.zkFairTestnet = exports.zkFair = exports.zhejiang = exports.xdcTestnet = exports.xdc = exports.wemixTestnet = exports.wemix = exports.wanchainTestnet = exports.wanchain = exports.vechain = exports.thunderTestnet = exports.tenet = exports.telosTestnet = exports.telos = exports.taraxaTestnet = exports.taikoTestnetSepolia = exports.taikoJolnir = exports.taraxa = exports.syscoinTestnet = exports.syscoin = exports.shibarium = exports.shardeumSphinx = exports.spicy = exports.songbirdTestnet = exports.songbird = exports.skaleTitanTestnet = void 0;
var acala_js_1 = __webpack_require__(/*! ./definitions/acala.js */ "../../node_modules/viem/_cjs/chains/definitions/acala.js");
Object.defineProperty(exports, "acala", ({ enumerable: true, get: function () { return acala_js_1.acala; } }));
var arbitrum_js_1 = __webpack_require__(/*! ./definitions/arbitrum.js */ "../../node_modules/viem/_cjs/chains/definitions/arbitrum.js");
Object.defineProperty(exports, "arbitrum", ({ enumerable: true, get: function () { return arbitrum_js_1.arbitrum; } }));
var arbitrumGoerli_js_1 = __webpack_require__(/*! ./definitions/arbitrumGoerli.js */ "../../node_modules/viem/_cjs/chains/definitions/arbitrumGoerli.js");
Object.defineProperty(exports, "arbitrumGoerli", ({ enumerable: true, get: function () { return arbitrumGoerli_js_1.arbitrumGoerli; } }));
var arbitrumNova_js_1 = __webpack_require__(/*! ./definitions/arbitrumNova.js */ "../../node_modules/viem/_cjs/chains/definitions/arbitrumNova.js");
Object.defineProperty(exports, "arbitrumNova", ({ enumerable: true, get: function () { return arbitrumNova_js_1.arbitrumNova; } }));
var astar_js_1 = __webpack_require__(/*! ./definitions/astar.js */ "../../node_modules/viem/_cjs/chains/definitions/astar.js");
Object.defineProperty(exports, "astar", ({ enumerable: true, get: function () { return astar_js_1.astar; } }));
var arbitrumSepolia_js_1 = __webpack_require__(/*! ./definitions/arbitrumSepolia.js */ "../../node_modules/viem/_cjs/chains/definitions/arbitrumSepolia.js");
Object.defineProperty(exports, "arbitrumSepolia", ({ enumerable: true, get: function () { return arbitrumSepolia_js_1.arbitrumSepolia; } }));
var astarZkatana_js_1 = __webpack_require__(/*! ./definitions/astarZkatana.js */ "../../node_modules/viem/_cjs/chains/definitions/astarZkatana.js");
Object.defineProperty(exports, "astarZkatana", ({ enumerable: true, get: function () { return astarZkatana_js_1.astarZkatana; } }));
var aurora_js_1 = __webpack_require__(/*! ./definitions/aurora.js */ "../../node_modules/viem/_cjs/chains/definitions/aurora.js");
Object.defineProperty(exports, "aurora", ({ enumerable: true, get: function () { return aurora_js_1.aurora; } }));
var auroraTestnet_js_1 = __webpack_require__(/*! ./definitions/auroraTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/auroraTestnet.js");
Object.defineProperty(exports, "auroraTestnet", ({ enumerable: true, get: function () { return auroraTestnet_js_1.auroraTestnet; } }));
var avalanche_js_1 = __webpack_require__(/*! ./definitions/avalanche.js */ "../../node_modules/viem/_cjs/chains/definitions/avalanche.js");
Object.defineProperty(exports, "avalanche", ({ enumerable: true, get: function () { return avalanche_js_1.avalanche; } }));
var avalancheFuji_js_1 = __webpack_require__(/*! ./definitions/avalancheFuji.js */ "../../node_modules/viem/_cjs/chains/definitions/avalancheFuji.js");
Object.defineProperty(exports, "avalancheFuji", ({ enumerable: true, get: function () { return avalancheFuji_js_1.avalancheFuji; } }));
var bahamut_js_1 = __webpack_require__(/*! ./definitions/bahamut.js */ "../../node_modules/viem/_cjs/chains/definitions/bahamut.js");
Object.defineProperty(exports, "bahamut", ({ enumerable: true, get: function () { return bahamut_js_1.bahamut; } }));
var base_js_1 = __webpack_require__(/*! ./definitions/base.js */ "../../node_modules/viem/_cjs/chains/definitions/base.js");
Object.defineProperty(exports, "base", ({ enumerable: true, get: function () { return base_js_1.base; } }));
var baseGoerli_js_1 = __webpack_require__(/*! ./definitions/baseGoerli.js */ "../../node_modules/viem/_cjs/chains/definitions/baseGoerli.js");
Object.defineProperty(exports, "baseGoerli", ({ enumerable: true, get: function () { return baseGoerli_js_1.baseGoerli; } }));
var baseSepolia_js_1 = __webpack_require__(/*! ./definitions/baseSepolia.js */ "../../node_modules/viem/_cjs/chains/definitions/baseSepolia.js");
Object.defineProperty(exports, "baseSepolia", ({ enumerable: true, get: function () { return baseSepolia_js_1.baseSepolia; } }));
var bearNetworkChainMainnet_js_1 = __webpack_require__(/*! ./definitions/bearNetworkChainMainnet.js */ "../../node_modules/viem/_cjs/chains/definitions/bearNetworkChainMainnet.js");
Object.defineProperty(exports, "bearNetworkChainMainnet", ({ enumerable: true, get: function () { return bearNetworkChainMainnet_js_1.bearNetworkChainMainnet; } }));
var bearNetworkChainTestnet_js_1 = __webpack_require__(/*! ./definitions/bearNetworkChainTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/bearNetworkChainTestnet.js");
Object.defineProperty(exports, "bearNetworkChainTestnet", ({ enumerable: true, get: function () { return bearNetworkChainTestnet_js_1.bearNetworkChainTestnet; } }));
var bitTorrent_js_1 = __webpack_require__(/*! ./definitions/bitTorrent.js */ "../../node_modules/viem/_cjs/chains/definitions/bitTorrent.js");
Object.defineProperty(exports, "bitTorrent", ({ enumerable: true, get: function () { return bitTorrent_js_1.bitTorrent; } }));
var bitTorrentTestnet_js_1 = __webpack_require__(/*! ./definitions/bitTorrentTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/bitTorrentTestnet.js");
Object.defineProperty(exports, "bitTorrentTestnet", ({ enumerable: true, get: function () { return bitTorrentTestnet_js_1.bitTorrentTestnet; } }));
var boba_js_1 = __webpack_require__(/*! ./definitions/boba.js */ "../../node_modules/viem/_cjs/chains/definitions/boba.js");
Object.defineProperty(exports, "boba", ({ enumerable: true, get: function () { return boba_js_1.boba; } }));
var bronos_js_1 = __webpack_require__(/*! ./definitions/bronos.js */ "../../node_modules/viem/_cjs/chains/definitions/bronos.js");
Object.defineProperty(exports, "bronos", ({ enumerable: true, get: function () { return bronos_js_1.bronos; } }));
var bronosTestnet_js_1 = __webpack_require__(/*! ./definitions/bronosTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/bronosTestnet.js");
Object.defineProperty(exports, "bronosTestnet", ({ enumerable: true, get: function () { return bronosTestnet_js_1.bronosTestnet; } }));
var bsc_js_1 = __webpack_require__(/*! ./definitions/bsc.js */ "../../node_modules/viem/_cjs/chains/definitions/bsc.js");
Object.defineProperty(exports, "bsc", ({ enumerable: true, get: function () { return bsc_js_1.bsc; } }));
var bscTestnet_js_1 = __webpack_require__(/*! ./definitions/bscTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/bscTestnet.js");
Object.defineProperty(exports, "bscTestnet", ({ enumerable: true, get: function () { return bscTestnet_js_1.bscTestnet; } }));
var bxn_js_1 = __webpack_require__(/*! ./definitions/bxn.js */ "../../node_modules/viem/_cjs/chains/definitions/bxn.js");
Object.defineProperty(exports, "bxn", ({ enumerable: true, get: function () { return bxn_js_1.bxn; } }));
var bxnTestnet_js_1 = __webpack_require__(/*! ./definitions/bxnTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/bxnTestnet.js");
Object.defineProperty(exports, "bxnTestnet", ({ enumerable: true, get: function () { return bxnTestnet_js_1.bxnTestnet; } }));
var canto_js_1 = __webpack_require__(/*! ./definitions/canto.js */ "../../node_modules/viem/_cjs/chains/definitions/canto.js");
Object.defineProperty(exports, "canto", ({ enumerable: true, get: function () { return canto_js_1.canto; } }));
var celo_js_1 = __webpack_require__(/*! ./definitions/celo.js */ "../../node_modules/viem/_cjs/chains/definitions/celo.js");
Object.defineProperty(exports, "celo", ({ enumerable: true, get: function () { return celo_js_1.celo; } }));
var celoAlfajores_js_1 = __webpack_require__(/*! ./definitions/celoAlfajores.js */ "../../node_modules/viem/_cjs/chains/definitions/celoAlfajores.js");
Object.defineProperty(exports, "celoAlfajores", ({ enumerable: true, get: function () { return celoAlfajores_js_1.celoAlfajores; } }));
var chiliz_js_1 = __webpack_require__(/*! ./definitions/chiliz.js */ "../../node_modules/viem/_cjs/chains/definitions/chiliz.js");
Object.defineProperty(exports, "chiliz", ({ enumerable: true, get: function () { return chiliz_js_1.chiliz; } }));
var celoCannoli_js_1 = __webpack_require__(/*! ./definitions/celoCannoli.js */ "../../node_modules/viem/_cjs/chains/definitions/celoCannoli.js");
Object.defineProperty(exports, "celoCannoli", ({ enumerable: true, get: function () { return celoCannoli_js_1.celoCannoli; } }));
var classic_js_1 = __webpack_require__(/*! ./definitions/classic.js */ "../../node_modules/viem/_cjs/chains/definitions/classic.js");
Object.defineProperty(exports, "classic", ({ enumerable: true, get: function () { return classic_js_1.classic; } }));
var confluxESpace_js_1 = __webpack_require__(/*! ./definitions/confluxESpace.js */ "../../node_modules/viem/_cjs/chains/definitions/confluxESpace.js");
Object.defineProperty(exports, "confluxESpace", ({ enumerable: true, get: function () { return confluxESpace_js_1.confluxESpace; } }));
var confluxESpaceTestnet_js_1 = __webpack_require__(/*! ./definitions/confluxESpaceTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/confluxESpaceTestnet.js");
Object.defineProperty(exports, "confluxESpaceTestnet", ({ enumerable: true, get: function () { return confluxESpaceTestnet_js_1.confluxESpaceTestnet; } }));
var coreDao_js_1 = __webpack_require__(/*! ./definitions/coreDao.js */ "../../node_modules/viem/_cjs/chains/definitions/coreDao.js");
Object.defineProperty(exports, "coreDao", ({ enumerable: true, get: function () { return coreDao_js_1.coreDao; } }));
var cronos_js_1 = __webpack_require__(/*! ./definitions/cronos.js */ "../../node_modules/viem/_cjs/chains/definitions/cronos.js");
Object.defineProperty(exports, "cronos", ({ enumerable: true, get: function () { return cronos_js_1.cronos; } }));
var cronosTestnet_js_1 = __webpack_require__(/*! ./definitions/cronosTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/cronosTestnet.js");
Object.defineProperty(exports, "cronosTestnet", ({ enumerable: true, get: function () { return cronosTestnet_js_1.cronosTestnet; } }));
var crossbell_js_1 = __webpack_require__(/*! ./definitions/crossbell.js */ "../../node_modules/viem/_cjs/chains/definitions/crossbell.js");
Object.defineProperty(exports, "crossbell", ({ enumerable: true, get: function () { return crossbell_js_1.crossbell; } }));
var dfk_js_1 = __webpack_require__(/*! ./definitions/dfk.js */ "../../node_modules/viem/_cjs/chains/definitions/dfk.js");
Object.defineProperty(exports, "dfk", ({ enumerable: true, get: function () { return dfk_js_1.dfk; } }));
var dogechain_js_1 = __webpack_require__(/*! ./definitions/dogechain.js */ "../../node_modules/viem/_cjs/chains/definitions/dogechain.js");
Object.defineProperty(exports, "dogechain", ({ enumerable: true, get: function () { return dogechain_js_1.dogechain; } }));
var edgeware_js_1 = __webpack_require__(/*! ./definitions/edgeware.js */ "../../node_modules/viem/_cjs/chains/definitions/edgeware.js");
Object.defineProperty(exports, "edgeware", ({ enumerable: true, get: function () { return edgeware_js_1.edgeware; } }));
var edgewareTestnet_js_1 = __webpack_require__(/*! ./definitions/edgewareTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/edgewareTestnet.js");
Object.defineProperty(exports, "edgewareTestnet", ({ enumerable: true, get: function () { return edgewareTestnet_js_1.edgewareTestnet; } }));
var eos_js_1 = __webpack_require__(/*! ./definitions/eos.js */ "../../node_modules/viem/_cjs/chains/definitions/eos.js");
Object.defineProperty(exports, "eos", ({ enumerable: true, get: function () { return eos_js_1.eos; } }));
var eosTestnet_js_1 = __webpack_require__(/*! ./definitions/eosTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/eosTestnet.js");
Object.defineProperty(exports, "eosTestnet", ({ enumerable: true, get: function () { return eosTestnet_js_1.eosTestnet; } }));
var evmos_js_1 = __webpack_require__(/*! ./definitions/evmos.js */ "../../node_modules/viem/_cjs/chains/definitions/evmos.js");
Object.defineProperty(exports, "evmos", ({ enumerable: true, get: function () { return evmos_js_1.evmos; } }));
var evmosTestnet_js_1 = __webpack_require__(/*! ./definitions/evmosTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/evmosTestnet.js");
Object.defineProperty(exports, "evmosTestnet", ({ enumerable: true, get: function () { return evmosTestnet_js_1.evmosTestnet; } }));
var ekta_js_1 = __webpack_require__(/*! ./definitions/ekta.js */ "../../node_modules/viem/_cjs/chains/definitions/ekta.js");
Object.defineProperty(exports, "ekta", ({ enumerable: true, get: function () { return ekta_js_1.ekta; } }));
var ektaTestnet_js_1 = __webpack_require__(/*! ./definitions/ektaTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/ektaTestnet.js");
Object.defineProperty(exports, "ektaTestnet", ({ enumerable: true, get: function () { return ektaTestnet_js_1.ektaTestnet; } }));
var fantom_js_1 = __webpack_require__(/*! ./definitions/fantom.js */ "../../node_modules/viem/_cjs/chains/definitions/fantom.js");
Object.defineProperty(exports, "fantom", ({ enumerable: true, get: function () { return fantom_js_1.fantom; } }));
var fantomSonicTestnet_js_1 = __webpack_require__(/*! ./definitions/fantomSonicTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/fantomSonicTestnet.js");
Object.defineProperty(exports, "fantomSonicTestnet", ({ enumerable: true, get: function () { return fantomSonicTestnet_js_1.fantomSonicTestnet; } }));
var fantomTestnet_js_1 = __webpack_require__(/*! ./definitions/fantomTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/fantomTestnet.js");
Object.defineProperty(exports, "fantomTestnet", ({ enumerable: true, get: function () { return fantomTestnet_js_1.fantomTestnet; } }));
var fibo_js_1 = __webpack_require__(/*! ./definitions/fibo.js */ "../../node_modules/viem/_cjs/chains/definitions/fibo.js");
Object.defineProperty(exports, "fibo", ({ enumerable: true, get: function () { return fibo_js_1.fibo; } }));
var filecoin_js_1 = __webpack_require__(/*! ./definitions/filecoin.js */ "../../node_modules/viem/_cjs/chains/definitions/filecoin.js");
Object.defineProperty(exports, "filecoin", ({ enumerable: true, get: function () { return filecoin_js_1.filecoin; } }));
var filecoinCalibration_js_1 = __webpack_require__(/*! ./definitions/filecoinCalibration.js */ "../../node_modules/viem/_cjs/chains/definitions/filecoinCalibration.js");
Object.defineProperty(exports, "filecoinCalibration", ({ enumerable: true, get: function () { return filecoinCalibration_js_1.filecoinCalibration; } }));
var filecoinHyperspace_js_1 = __webpack_require__(/*! ./definitions/filecoinHyperspace.js */ "../../node_modules/viem/_cjs/chains/definitions/filecoinHyperspace.js");
Object.defineProperty(exports, "filecoinHyperspace", ({ enumerable: true, get: function () { return filecoinHyperspace_js_1.filecoinHyperspace; } }));
var flare_js_1 = __webpack_require__(/*! ./definitions/flare.js */ "../../node_modules/viem/_cjs/chains/definitions/flare.js");
Object.defineProperty(exports, "flare", ({ enumerable: true, get: function () { return flare_js_1.flare; } }));
var flareTestnet_js_1 = __webpack_require__(/*! ./definitions/flareTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/flareTestnet.js");
Object.defineProperty(exports, "flareTestnet", ({ enumerable: true, get: function () { return flareTestnet_js_1.flareTestnet; } }));
var foundry_js_1 = __webpack_require__(/*! ./definitions/foundry.js */ "../../node_modules/viem/_cjs/chains/definitions/foundry.js");
Object.defineProperty(exports, "foundry", ({ enumerable: true, get: function () { return foundry_js_1.foundry; } }));
var fuse_js_1 = __webpack_require__(/*! ./definitions/fuse.js */ "../../node_modules/viem/_cjs/chains/definitions/fuse.js");
Object.defineProperty(exports, "fuse", ({ enumerable: true, get: function () { return fuse_js_1.fuse; } }));
var fuseSparknet_js_1 = __webpack_require__(/*! ./definitions/fuseSparknet.js */ "../../node_modules/viem/_cjs/chains/definitions/fuseSparknet.js");
Object.defineProperty(exports, "fuseSparknet", ({ enumerable: true, get: function () { return fuseSparknet_js_1.fuseSparknet; } }));
var iotex_js_1 = __webpack_require__(/*! ./definitions/iotex.js */ "../../node_modules/viem/_cjs/chains/definitions/iotex.js");
Object.defineProperty(exports, "iotex", ({ enumerable: true, get: function () { return iotex_js_1.iotex; } }));
var iotexTestnet_js_1 = __webpack_require__(/*! ./definitions/iotexTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/iotexTestnet.js");
Object.defineProperty(exports, "iotexTestnet", ({ enumerable: true, get: function () { return iotexTestnet_js_1.iotexTestnet; } }));
var jbc_js_1 = __webpack_require__(/*! ./definitions/jbc.js */ "../../node_modules/viem/_cjs/chains/definitions/jbc.js");
Object.defineProperty(exports, "jbc", ({ enumerable: true, get: function () { return jbc_js_1.jbc; } }));
var karura_js_1 = __webpack_require__(/*! ./definitions/karura.js */ "../../node_modules/viem/_cjs/chains/definitions/karura.js");
Object.defineProperty(exports, "karura", ({ enumerable: true, get: function () { return karura_js_1.karura; } }));
var gobi_js_1 = __webpack_require__(/*! ./definitions/gobi.js */ "../../node_modules/viem/_cjs/chains/definitions/gobi.js");
Object.defineProperty(exports, "gobi", ({ enumerable: true, get: function () { return gobi_js_1.gobi; } }));
var goerli_js_1 = __webpack_require__(/*! ./definitions/goerli.js */ "../../node_modules/viem/_cjs/chains/definitions/goerli.js");
Object.defineProperty(exports, "goerli", ({ enumerable: true, get: function () { return goerli_js_1.goerli; } }));
var gnosis_js_1 = __webpack_require__(/*! ./definitions/gnosis.js */ "../../node_modules/viem/_cjs/chains/definitions/gnosis.js");
Object.defineProperty(exports, "gnosis", ({ enumerable: true, get: function () { return gnosis_js_1.gnosis; } }));
var gnosisChiado_js_1 = __webpack_require__(/*! ./definitions/gnosisChiado.js */ "../../node_modules/viem/_cjs/chains/definitions/gnosisChiado.js");
Object.defineProperty(exports, "gnosisChiado", ({ enumerable: true, get: function () { return gnosisChiado_js_1.gnosisChiado; } }));
var hardhat_js_1 = __webpack_require__(/*! ./definitions/hardhat.js */ "../../node_modules/viem/_cjs/chains/definitions/hardhat.js");
Object.defineProperty(exports, "hardhat", ({ enumerable: true, get: function () { return hardhat_js_1.hardhat; } }));
var harmonyOne_js_1 = __webpack_require__(/*! ./definitions/harmonyOne.js */ "../../node_modules/viem/_cjs/chains/definitions/harmonyOne.js");
Object.defineProperty(exports, "harmonyOne", ({ enumerable: true, get: function () { return harmonyOne_js_1.harmonyOne; } }));
var haqqMainnet_js_1 = __webpack_require__(/*! ./definitions/haqqMainnet.js */ "../../node_modules/viem/_cjs/chains/definitions/haqqMainnet.js");
Object.defineProperty(exports, "haqqMainnet", ({ enumerable: true, get: function () { return haqqMainnet_js_1.haqqMainnet; } }));
var haqqTestedge2_js_1 = __webpack_require__(/*! ./definitions/haqqTestedge2.js */ "../../node_modules/viem/_cjs/chains/definitions/haqqTestedge2.js");
Object.defineProperty(exports, "haqqTestedge2", ({ enumerable: true, get: function () { return haqqTestedge2_js_1.haqqTestedge2; } }));
var holesky_js_1 = __webpack_require__(/*! ./definitions/holesky.js */ "../../node_modules/viem/_cjs/chains/definitions/holesky.js");
Object.defineProperty(exports, "holesky", ({ enumerable: true, get: function () { return holesky_js_1.holesky; } }));
var kava_js_1 = __webpack_require__(/*! ./definitions/kava.js */ "../../node_modules/viem/_cjs/chains/definitions/kava.js");
Object.defineProperty(exports, "kava", ({ enumerable: true, get: function () { return kava_js_1.kava; } }));
var kavaTestnet_js_1 = __webpack_require__(/*! ./definitions/kavaTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/kavaTestnet.js");
Object.defineProperty(exports, "kavaTestnet", ({ enumerable: true, get: function () { return kavaTestnet_js_1.kavaTestnet; } }));
var klaytn_js_1 = __webpack_require__(/*! ./definitions/klaytn.js */ "../../node_modules/viem/_cjs/chains/definitions/klaytn.js");
Object.defineProperty(exports, "klaytn", ({ enumerable: true, get: function () { return klaytn_js_1.klaytn; } }));
var klaytnBaobab_js_1 = __webpack_require__(/*! ./definitions/klaytnBaobab.js */ "../../node_modules/viem/_cjs/chains/definitions/klaytnBaobab.js");
Object.defineProperty(exports, "klaytnBaobab", ({ enumerable: true, get: function () { return klaytnBaobab_js_1.klaytnBaobab; } }));
var kroma_js_1 = __webpack_require__(/*! ./definitions/kroma.js */ "../../node_modules/viem/_cjs/chains/definitions/kroma.js");
Object.defineProperty(exports, "kroma", ({ enumerable: true, get: function () { return kroma_js_1.kroma; } }));
var kromaSepolia_js_1 = __webpack_require__(/*! ./definitions/kromaSepolia.js */ "../../node_modules/viem/_cjs/chains/definitions/kromaSepolia.js");
Object.defineProperty(exports, "kromaSepolia", ({ enumerable: true, get: function () { return kromaSepolia_js_1.kromaSepolia; } }));
var linea_js_1 = __webpack_require__(/*! ./definitions/linea.js */ "../../node_modules/viem/_cjs/chains/definitions/linea.js");
Object.defineProperty(exports, "linea", ({ enumerable: true, get: function () { return linea_js_1.linea; } }));
var lineaTestnet_js_1 = __webpack_require__(/*! ./definitions/lineaTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/lineaTestnet.js");
Object.defineProperty(exports, "lineaTestnet", ({ enumerable: true, get: function () { return lineaTestnet_js_1.lineaTestnet; } }));
var localhost_js_1 = __webpack_require__(/*! ./definitions/localhost.js */ "../../node_modules/viem/_cjs/chains/definitions/localhost.js");
Object.defineProperty(exports, "localhost", ({ enumerable: true, get: function () { return localhost_js_1.localhost; } }));
var lukso_js_1 = __webpack_require__(/*! ./definitions/lukso.js */ "../../node_modules/viem/_cjs/chains/definitions/lukso.js");
Object.defineProperty(exports, "lukso", ({ enumerable: true, get: function () { return lukso_js_1.lukso; } }));
var mainnet_js_1 = __webpack_require__(/*! ./definitions/mainnet.js */ "../../node_modules/viem/_cjs/chains/definitions/mainnet.js");
Object.defineProperty(exports, "mainnet", ({ enumerable: true, get: function () { return mainnet_js_1.mainnet; } }));
var mandala_js_1 = __webpack_require__(/*! ./definitions/mandala.js */ "../../node_modules/viem/_cjs/chains/definitions/mandala.js");
Object.defineProperty(exports, "mandala", ({ enumerable: true, get: function () { return mandala_js_1.mandala; } }));
var manta_js_1 = __webpack_require__(/*! ./definitions/manta.js */ "../../node_modules/viem/_cjs/chains/definitions/manta.js");
Object.defineProperty(exports, "manta", ({ enumerable: true, get: function () { return manta_js_1.manta; } }));
var mantaTestnet_js_1 = __webpack_require__(/*! ./definitions/mantaTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/mantaTestnet.js");
Object.defineProperty(exports, "mantaTestnet", ({ enumerable: true, get: function () { return mantaTestnet_js_1.mantaTestnet; } }));
var mantle_js_1 = __webpack_require__(/*! ./definitions/mantle.js */ "../../node_modules/viem/_cjs/chains/definitions/mantle.js");
Object.defineProperty(exports, "mantle", ({ enumerable: true, get: function () { return mantle_js_1.mantle; } }));
var mantleTestnet_js_1 = __webpack_require__(/*! ./definitions/mantleTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/mantleTestnet.js");
Object.defineProperty(exports, "mantleTestnet", ({ enumerable: true, get: function () { return mantleTestnet_js_1.mantleTestnet; } }));
var meter_js_1 = __webpack_require__(/*! ./definitions/meter.js */ "../../node_modules/viem/_cjs/chains/definitions/meter.js");
Object.defineProperty(exports, "meter", ({ enumerable: true, get: function () { return meter_js_1.meter; } }));
var meterTestnet_js_1 = __webpack_require__(/*! ./definitions/meterTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/meterTestnet.js");
Object.defineProperty(exports, "meterTestnet", ({ enumerable: true, get: function () { return meterTestnet_js_1.meterTestnet; } }));
var metis_js_1 = __webpack_require__(/*! ./definitions/metis.js */ "../../node_modules/viem/_cjs/chains/definitions/metis.js");
Object.defineProperty(exports, "metis", ({ enumerable: true, get: function () { return metis_js_1.metis; } }));
var metisGoerli_js_1 = __webpack_require__(/*! ./definitions/metisGoerli.js */ "../../node_modules/viem/_cjs/chains/definitions/metisGoerli.js");
Object.defineProperty(exports, "metisGoerli", ({ enumerable: true, get: function () { return metisGoerli_js_1.metisGoerli; } }));
var mev_js_1 = __webpack_require__(/*! ./definitions/mev.js */ "../../node_modules/viem/_cjs/chains/definitions/mev.js");
Object.defineProperty(exports, "mev", ({ enumerable: true, get: function () { return mev_js_1.mev; } }));
var mevTestnet_js_1 = __webpack_require__(/*! ./definitions/mevTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/mevTestnet.js");
Object.defineProperty(exports, "mevTestnet", ({ enumerable: true, get: function () { return mevTestnet_js_1.mevTestnet; } }));
var modeTestnet_js_1 = __webpack_require__(/*! ./definitions/modeTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/modeTestnet.js");
Object.defineProperty(exports, "modeTestnet", ({ enumerable: true, get: function () { return modeTestnet_js_1.modeTestnet; } }));
var moonbaseAlpha_js_1 = __webpack_require__(/*! ./definitions/moonbaseAlpha.js */ "../../node_modules/viem/_cjs/chains/definitions/moonbaseAlpha.js");
Object.defineProperty(exports, "moonbaseAlpha", ({ enumerable: true, get: function () { return moonbaseAlpha_js_1.moonbaseAlpha; } }));
var moonbeam_js_1 = __webpack_require__(/*! ./definitions/moonbeam.js */ "../../node_modules/viem/_cjs/chains/definitions/moonbeam.js");
Object.defineProperty(exports, "moonbeam", ({ enumerable: true, get: function () { return moonbeam_js_1.moonbeam; } }));
var moonbeamDev_js_1 = __webpack_require__(/*! ./definitions/moonbeamDev.js */ "../../node_modules/viem/_cjs/chains/definitions/moonbeamDev.js");
Object.defineProperty(exports, "moonbeamDev", ({ enumerable: true, get: function () { return moonbeamDev_js_1.moonbeamDev; } }));
var moonriver_js_1 = __webpack_require__(/*! ./definitions/moonriver.js */ "../../node_modules/viem/_cjs/chains/definitions/moonriver.js");
Object.defineProperty(exports, "moonriver", ({ enumerable: true, get: function () { return moonriver_js_1.moonriver; } }));
var neonDevnet_js_1 = __webpack_require__(/*! ./definitions/neonDevnet.js */ "../../node_modules/viem/_cjs/chains/definitions/neonDevnet.js");
Object.defineProperty(exports, "neonDevnet", ({ enumerable: true, get: function () { return neonDevnet_js_1.neonDevnet; } }));
var neonMainnet_js_1 = __webpack_require__(/*! ./definitions/neonMainnet.js */ "../../node_modules/viem/_cjs/chains/definitions/neonMainnet.js");
Object.defineProperty(exports, "neonMainnet", ({ enumerable: true, get: function () { return neonMainnet_js_1.neonMainnet; } }));
var nexi_js_1 = __webpack_require__(/*! ./definitions/nexi.js */ "../../node_modules/viem/_cjs/chains/definitions/nexi.js");
Object.defineProperty(exports, "nexi", ({ enumerable: true, get: function () { return nexi_js_1.nexi; } }));
var nexilix_js_1 = __webpack_require__(/*! ./definitions/nexilix.js */ "../../node_modules/viem/_cjs/chains/definitions/nexilix.js");
Object.defineProperty(exports, "nexilix", ({ enumerable: true, get: function () { return nexilix_js_1.nexilix; } }));
var oasys_js_1 = __webpack_require__(/*! ./definitions/oasys.js */ "../../node_modules/viem/_cjs/chains/definitions/oasys.js");
Object.defineProperty(exports, "oasys", ({ enumerable: true, get: function () { return oasys_js_1.oasys; } }));
var oasisTestnet_js_1 = __webpack_require__(/*! ./definitions/oasisTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/oasisTestnet.js");
Object.defineProperty(exports, "oasisTestnet", ({ enumerable: true, get: function () { return oasisTestnet_js_1.oasisTestnet; } }));
var okc_js_1 = __webpack_require__(/*! ./definitions/okc.js */ "../../node_modules/viem/_cjs/chains/definitions/okc.js");
Object.defineProperty(exports, "okc", ({ enumerable: true, get: function () { return okc_js_1.okc; } }));
var optimism_js_1 = __webpack_require__(/*! ./definitions/optimism.js */ "../../node_modules/viem/_cjs/chains/definitions/optimism.js");
Object.defineProperty(exports, "optimism", ({ enumerable: true, get: function () { return optimism_js_1.optimism; } }));
var optimismGoerli_js_1 = __webpack_require__(/*! ./definitions/optimismGoerli.js */ "../../node_modules/viem/_cjs/chains/definitions/optimismGoerli.js");
Object.defineProperty(exports, "optimismGoerli", ({ enumerable: true, get: function () { return optimismGoerli_js_1.optimismGoerli; } }));
var optimismSepolia_js_1 = __webpack_require__(/*! ./definitions/optimismSepolia.js */ "../../node_modules/viem/_cjs/chains/definitions/optimismSepolia.js");
Object.defineProperty(exports, "optimismSepolia", ({ enumerable: true, get: function () { return optimismSepolia_js_1.optimismSepolia; } }));
var opBNB_js_1 = __webpack_require__(/*! ./definitions/opBNB.js */ "../../node_modules/viem/_cjs/chains/definitions/opBNB.js");
Object.defineProperty(exports, "opBNB", ({ enumerable: true, get: function () { return opBNB_js_1.opBNB; } }));
var opBNBTestnet_js_1 = __webpack_require__(/*! ./definitions/opBNBTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/opBNBTestnet.js");
Object.defineProperty(exports, "opBNBTestnet", ({ enumerable: true, get: function () { return opBNBTestnet_js_1.opBNBTestnet; } }));
var pgn_js_1 = __webpack_require__(/*! ./definitions/pgn.js */ "../../node_modules/viem/_cjs/chains/definitions/pgn.js");
Object.defineProperty(exports, "pgn", ({ enumerable: true, get: function () { return pgn_js_1.pgn; } }));
var pgnTestnet_js_1 = __webpack_require__(/*! ./definitions/pgnTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/pgnTestnet.js");
Object.defineProperty(exports, "pgnTestnet", ({ enumerable: true, get: function () { return pgnTestnet_js_1.pgnTestnet; } }));
var plinga_js_1 = __webpack_require__(/*! ./definitions/plinga.js */ "../../node_modules/viem/_cjs/chains/definitions/plinga.js");
Object.defineProperty(exports, "plinga", ({ enumerable: true, get: function () { return plinga_js_1.plinga; } }));
var polygon_js_1 = __webpack_require__(/*! ./definitions/polygon.js */ "../../node_modules/viem/_cjs/chains/definitions/polygon.js");
Object.defineProperty(exports, "polygon", ({ enumerable: true, get: function () { return polygon_js_1.polygon; } }));
var polygonMumbai_js_1 = __webpack_require__(/*! ./definitions/polygonMumbai.js */ "../../node_modules/viem/_cjs/chains/definitions/polygonMumbai.js");
Object.defineProperty(exports, "polygonMumbai", ({ enumerable: true, get: function () { return polygonMumbai_js_1.polygonMumbai; } }));
var polygonZkEvmTestnet_js_1 = __webpack_require__(/*! ./definitions/polygonZkEvmTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/polygonZkEvmTestnet.js");
Object.defineProperty(exports, "polygonZkEvmTestnet", ({ enumerable: true, get: function () { return polygonZkEvmTestnet_js_1.polygonZkEvmTestnet; } }));
var polygonZkEvm_js_1 = __webpack_require__(/*! ./definitions/polygonZkEvm.js */ "../../node_modules/viem/_cjs/chains/definitions/polygonZkEvm.js");
Object.defineProperty(exports, "polygonZkEvm", ({ enumerable: true, get: function () { return polygonZkEvm_js_1.polygonZkEvm; } }));
var pulsechain_js_1 = __webpack_require__(/*! ./definitions/pulsechain.js */ "../../node_modules/viem/_cjs/chains/definitions/pulsechain.js");
Object.defineProperty(exports, "pulsechain", ({ enumerable: true, get: function () { return pulsechain_js_1.pulsechain; } }));
var pulsechainV4_js_1 = __webpack_require__(/*! ./definitions/pulsechainV4.js */ "../../node_modules/viem/_cjs/chains/definitions/pulsechainV4.js");
Object.defineProperty(exports, "pulsechainV4", ({ enumerable: true, get: function () { return pulsechainV4_js_1.pulsechainV4; } }));
var qMainnet_js_1 = __webpack_require__(/*! ./definitions/qMainnet.js */ "../../node_modules/viem/_cjs/chains/definitions/qMainnet.js");
Object.defineProperty(exports, "qMainnet", ({ enumerable: true, get: function () { return qMainnet_js_1.qMainnet; } }));
var qTestnet_js_1 = __webpack_require__(/*! ./definitions/qTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/qTestnet.js");
Object.defineProperty(exports, "qTestnet", ({ enumerable: true, get: function () { return qTestnet_js_1.qTestnet; } }));
var rollux_js_1 = __webpack_require__(/*! ./definitions/rollux.js */ "../../node_modules/viem/_cjs/chains/definitions/rollux.js");
Object.defineProperty(exports, "rollux", ({ enumerable: true, get: function () { return rollux_js_1.rollux; } }));
var rolluxTestnet_js_1 = __webpack_require__(/*! ./definitions/rolluxTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/rolluxTestnet.js");
Object.defineProperty(exports, "rolluxTestnet", ({ enumerable: true, get: function () { return rolluxTestnet_js_1.rolluxTestnet; } }));
var ronin_js_1 = __webpack_require__(/*! ./definitions/ronin.js */ "../../node_modules/viem/_cjs/chains/definitions/ronin.js");
Object.defineProperty(exports, "ronin", ({ enumerable: true, get: function () { return ronin_js_1.ronin; } }));
var rootstock_js_1 = __webpack_require__(/*! ./definitions/rootstock.js */ "../../node_modules/viem/_cjs/chains/definitions/rootstock.js");
Object.defineProperty(exports, "rootstock", ({ enumerable: true, get: function () { return rootstock_js_1.rootstock; } }));
var saigon_js_1 = __webpack_require__(/*! ./definitions/saigon.js */ "../../node_modules/viem/_cjs/chains/definitions/saigon.js");
Object.defineProperty(exports, "saigon", ({ enumerable: true, get: function () { return saigon_js_1.saigon; } }));
var sapphire_js_1 = __webpack_require__(/*! ./definitions/sapphire.js */ "../../node_modules/viem/_cjs/chains/definitions/sapphire.js");
Object.defineProperty(exports, "sapphire", ({ enumerable: true, get: function () { return sapphire_js_1.sapphire; } }));
var sapphireTestnet_js_1 = __webpack_require__(/*! ./definitions/sapphireTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/sapphireTestnet.js");
Object.defineProperty(exports, "sapphireTestnet", ({ enumerable: true, get: function () { return sapphireTestnet_js_1.sapphireTestnet; } }));
var scroll_js_1 = __webpack_require__(/*! ./definitions/scroll.js */ "../../node_modules/viem/_cjs/chains/definitions/scroll.js");
Object.defineProperty(exports, "scroll", ({ enumerable: true, get: function () { return scroll_js_1.scroll; } }));
var scrollSepolia_js_1 = __webpack_require__(/*! ./definitions/scrollSepolia.js */ "../../node_modules/viem/_cjs/chains/definitions/scrollSepolia.js");
Object.defineProperty(exports, "scrollSepolia", ({ enumerable: true, get: function () { return scrollSepolia_js_1.scrollSepolia; } }));
var scrollTestnet_js_1 = __webpack_require__(/*! ./definitions/scrollTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/scrollTestnet.js");
Object.defineProperty(exports, "scrollTestnet", ({ enumerable: true, get: function () { return scrollTestnet_js_1.scrollTestnet; } }));
var sepolia_js_1 = __webpack_require__(/*! ./definitions/sepolia.js */ "../../node_modules/viem/_cjs/chains/definitions/sepolia.js");
Object.defineProperty(exports, "sepolia", ({ enumerable: true, get: function () { return sepolia_js_1.sepolia; } }));
var shimmer_js_1 = __webpack_require__(/*! ./definitions/shimmer.js */ "../../node_modules/viem/_cjs/chains/definitions/shimmer.js");
Object.defineProperty(exports, "shimmer", ({ enumerable: true, get: function () { return shimmer_js_1.shimmer; } }));
var shimmerTestnet_js_1 = __webpack_require__(/*! ./definitions/shimmerTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/shimmerTestnet.js");
Object.defineProperty(exports, "shimmerTestnet", ({ enumerable: true, get: function () { return shimmerTestnet_js_1.shimmerTestnet; } }));
var brawl_js_1 = __webpack_require__(/*! ./definitions/skale/brawl.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/brawl.js");
Object.defineProperty(exports, "skaleBlockBrawlers", ({ enumerable: true, get: function () { return brawl_js_1.skaleBlockBrawlers; } }));
var calypso_js_1 = __webpack_require__(/*! ./definitions/skale/calypso.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/calypso.js");
Object.defineProperty(exports, "skaleCalypso", ({ enumerable: true, get: function () { return calypso_js_1.skaleCalypso; } }));
var calypsoTestnet_js_1 = __webpack_require__(/*! ./definitions/skale/calypsoTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/calypsoTestnet.js");
Object.defineProperty(exports, "skaleCalypsoTestnet", ({ enumerable: true, get: function () { return calypsoTestnet_js_1.skaleCalypsoTestnet; } }));
var chaosTestnet_js_1 = __webpack_require__(/*! ./definitions/skale/chaosTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/chaosTestnet.js");
Object.defineProperty(exports, "skaleChaosTestnet", ({ enumerable: true, get: function () { return chaosTestnet_js_1.skaleChaosTestnet; } }));
var cryptoBlades_js_1 = __webpack_require__(/*! ./definitions/skale/cryptoBlades.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/cryptoBlades.js");
Object.defineProperty(exports, "skaleCryptoBlades", ({ enumerable: true, get: function () { return cryptoBlades_js_1.skaleCryptoBlades; } }));
var cryptoColosseum_js_1 = __webpack_require__(/*! ./definitions/skale/cryptoColosseum.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/cryptoColosseum.js");
Object.defineProperty(exports, "skaleCryptoColosseum", ({ enumerable: true, get: function () { return cryptoColosseum_js_1.skaleCryptoColosseum; } }));
var europa_js_1 = __webpack_require__(/*! ./definitions/skale/europa.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/europa.js");
Object.defineProperty(exports, "skaleEuropa", ({ enumerable: true, get: function () { return europa_js_1.skaleEuropa; } }));
var europaTestnet_js_1 = __webpack_require__(/*! ./definitions/skale/europaTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/europaTestnet.js");
Object.defineProperty(exports, "skaleEuropaTestnet", ({ enumerable: true, get: function () { return europaTestnet_js_1.skaleEuropaTestnet; } }));
var exorde_js_1 = __webpack_require__(/*! ./definitions/skale/exorde.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/exorde.js");
Object.defineProperty(exports, "skaleExorde", ({ enumerable: true, get: function () { return exorde_js_1.skaleExorde; } }));
var humanProtocol_js_1 = __webpack_require__(/*! ./definitions/skale/humanProtocol.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/humanProtocol.js");
Object.defineProperty(exports, "skaleHumanProtocol", ({ enumerable: true, get: function () { return humanProtocol_js_1.skaleHumanProtocol; } }));
var nebula_js_1 = __webpack_require__(/*! ./definitions/skale/nebula.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/nebula.js");
Object.defineProperty(exports, "skaleNebula", ({ enumerable: true, get: function () { return nebula_js_1.skaleNebula; } }));
var nebulaTestnet_js_1 = __webpack_require__(/*! ./definitions/skale/nebulaTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/nebulaTestnet.js");
Object.defineProperty(exports, "skaleNebulaTestnet", ({ enumerable: true, get: function () { return nebulaTestnet_js_1.skaleNebulaTestnet; } }));
var razor_js_1 = __webpack_require__(/*! ./definitions/skale/razor.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/razor.js");
Object.defineProperty(exports, "skaleRazor", ({ enumerable: true, get: function () { return razor_js_1.skaleRazor; } }));
var titan_js_1 = __webpack_require__(/*! ./definitions/skale/titan.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/titan.js");
Object.defineProperty(exports, "skaleTitan", ({ enumerable: true, get: function () { return titan_js_1.skaleTitan; } }));
var titanTestnet_js_1 = __webpack_require__(/*! ./definitions/skale/titanTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/skale/titanTestnet.js");
Object.defineProperty(exports, "skaleTitanTestnet", ({ enumerable: true, get: function () { return titanTestnet_js_1.skaleTitanTestnet; } }));
var songbird_js_1 = __webpack_require__(/*! ./definitions/songbird.js */ "../../node_modules/viem/_cjs/chains/definitions/songbird.js");
Object.defineProperty(exports, "songbird", ({ enumerable: true, get: function () { return songbird_js_1.songbird; } }));
var songbirdTestnet_js_1 = __webpack_require__(/*! ./definitions/songbirdTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/songbirdTestnet.js");
Object.defineProperty(exports, "songbirdTestnet", ({ enumerable: true, get: function () { return songbirdTestnet_js_1.songbirdTestnet; } }));
var spicy_js_1 = __webpack_require__(/*! ./definitions/spicy.js */ "../../node_modules/viem/_cjs/chains/definitions/spicy.js");
Object.defineProperty(exports, "spicy", ({ enumerable: true, get: function () { return spicy_js_1.spicy; } }));
var shardeumSphinx_js_1 = __webpack_require__(/*! ./definitions/shardeumSphinx.js */ "../../node_modules/viem/_cjs/chains/definitions/shardeumSphinx.js");
Object.defineProperty(exports, "shardeumSphinx", ({ enumerable: true, get: function () { return shardeumSphinx_js_1.shardeumSphinx; } }));
var shibarium_js_1 = __webpack_require__(/*! ./definitions/shibarium.js */ "../../node_modules/viem/_cjs/chains/definitions/shibarium.js");
Object.defineProperty(exports, "shibarium", ({ enumerable: true, get: function () { return shibarium_js_1.shibarium; } }));
var syscoin_js_1 = __webpack_require__(/*! ./definitions/syscoin.js */ "../../node_modules/viem/_cjs/chains/definitions/syscoin.js");
Object.defineProperty(exports, "syscoin", ({ enumerable: true, get: function () { return syscoin_js_1.syscoin; } }));
var syscoinTestnet_js_1 = __webpack_require__(/*! ./definitions/syscoinTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/syscoinTestnet.js");
Object.defineProperty(exports, "syscoinTestnet", ({ enumerable: true, get: function () { return syscoinTestnet_js_1.syscoinTestnet; } }));
var taraxa_js_1 = __webpack_require__(/*! ./definitions/taraxa.js */ "../../node_modules/viem/_cjs/chains/definitions/taraxa.js");
Object.defineProperty(exports, "taraxa", ({ enumerable: true, get: function () { return taraxa_js_1.taraxa; } }));
var taikoJolnir_js_1 = __webpack_require__(/*! ./definitions/taikoJolnir.js */ "../../node_modules/viem/_cjs/chains/definitions/taikoJolnir.js");
Object.defineProperty(exports, "taikoJolnir", ({ enumerable: true, get: function () { return taikoJolnir_js_1.taikoJolnir; } }));
var taikoTestnetSepolia_js_1 = __webpack_require__(/*! ./definitions/taikoTestnetSepolia.js */ "../../node_modules/viem/_cjs/chains/definitions/taikoTestnetSepolia.js");
Object.defineProperty(exports, "taikoTestnetSepolia", ({ enumerable: true, get: function () { return taikoTestnetSepolia_js_1.taikoTestnetSepolia; } }));
var taraxaTestnet_js_1 = __webpack_require__(/*! ./definitions/taraxaTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/taraxaTestnet.js");
Object.defineProperty(exports, "taraxaTestnet", ({ enumerable: true, get: function () { return taraxaTestnet_js_1.taraxaTestnet; } }));
var telos_js_1 = __webpack_require__(/*! ./definitions/telos.js */ "../../node_modules/viem/_cjs/chains/definitions/telos.js");
Object.defineProperty(exports, "telos", ({ enumerable: true, get: function () { return telos_js_1.telos; } }));
var telosTestnet_js_1 = __webpack_require__(/*! ./definitions/telosTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/telosTestnet.js");
Object.defineProperty(exports, "telosTestnet", ({ enumerable: true, get: function () { return telosTestnet_js_1.telosTestnet; } }));
var tenet_js_1 = __webpack_require__(/*! ./definitions/tenet.js */ "../../node_modules/viem/_cjs/chains/definitions/tenet.js");
Object.defineProperty(exports, "tenet", ({ enumerable: true, get: function () { return tenet_js_1.tenet; } }));
var thunderTestnet_js_1 = __webpack_require__(/*! ./definitions/thunderTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/thunderTestnet.js");
Object.defineProperty(exports, "thunderTestnet", ({ enumerable: true, get: function () { return thunderTestnet_js_1.thunderTestnet; } }));
var vechain_js_1 = __webpack_require__(/*! ./definitions/vechain.js */ "../../node_modules/viem/_cjs/chains/definitions/vechain.js");
Object.defineProperty(exports, "vechain", ({ enumerable: true, get: function () { return vechain_js_1.vechain; } }));
var wanchain_js_1 = __webpack_require__(/*! ./definitions/wanchain.js */ "../../node_modules/viem/_cjs/chains/definitions/wanchain.js");
Object.defineProperty(exports, "wanchain", ({ enumerable: true, get: function () { return wanchain_js_1.wanchain; } }));
var wanchainTestnet_js_1 = __webpack_require__(/*! ./definitions/wanchainTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/wanchainTestnet.js");
Object.defineProperty(exports, "wanchainTestnet", ({ enumerable: true, get: function () { return wanchainTestnet_js_1.wanchainTestnet; } }));
var wemix_js_1 = __webpack_require__(/*! ./definitions/wemix.js */ "../../node_modules/viem/_cjs/chains/definitions/wemix.js");
Object.defineProperty(exports, "wemix", ({ enumerable: true, get: function () { return wemix_js_1.wemix; } }));
var wemixTestnet_js_1 = __webpack_require__(/*! ./definitions/wemixTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/wemixTestnet.js");
Object.defineProperty(exports, "wemixTestnet", ({ enumerable: true, get: function () { return wemixTestnet_js_1.wemixTestnet; } }));
var xdc_js_1 = __webpack_require__(/*! ./definitions/xdc.js */ "../../node_modules/viem/_cjs/chains/definitions/xdc.js");
Object.defineProperty(exports, "xdc", ({ enumerable: true, get: function () { return xdc_js_1.xdc; } }));
var xdcTestnet_js_1 = __webpack_require__(/*! ./definitions/xdcTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/xdcTestnet.js");
Object.defineProperty(exports, "xdcTestnet", ({ enumerable: true, get: function () { return xdcTestnet_js_1.xdcTestnet; } }));
var zhejiang_js_1 = __webpack_require__(/*! ./definitions/zhejiang.js */ "../../node_modules/viem/_cjs/chains/definitions/zhejiang.js");
Object.defineProperty(exports, "zhejiang", ({ enumerable: true, get: function () { return zhejiang_js_1.zhejiang; } }));
var zkFair_js_1 = __webpack_require__(/*! ./definitions/zkFair.js */ "../../node_modules/viem/_cjs/chains/definitions/zkFair.js");
Object.defineProperty(exports, "zkFair", ({ enumerable: true, get: function () { return zkFair_js_1.zkFair; } }));
var zkFairTestnet_js_1 = __webpack_require__(/*! ./definitions/zkFairTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/zkFairTestnet.js");
Object.defineProperty(exports, "zkFairTestnet", ({ enumerable: true, get: function () { return zkFairTestnet_js_1.zkFairTestnet; } }));
var zkSync_js_1 = __webpack_require__(/*! ./definitions/zkSync.js */ "../../node_modules/viem/_cjs/chains/definitions/zkSync.js");
Object.defineProperty(exports, "zkSync", ({ enumerable: true, get: function () { return zkSync_js_1.zkSync; } }));
var zkSyncTestnet_js_1 = __webpack_require__(/*! ./definitions/zkSyncTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/zkSyncTestnet.js");
Object.defineProperty(exports, "zkSyncTestnet", ({ enumerable: true, get: function () { return zkSyncTestnet_js_1.zkSyncTestnet; } }));
var zkSyncSepoliaTestnet_js_1 = __webpack_require__(/*! ./definitions/zkSyncSepoliaTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/zkSyncSepoliaTestnet.js");
Object.defineProperty(exports, "zkSyncSepoliaTestnet", ({ enumerable: true, get: function () { return zkSyncSepoliaTestnet_js_1.zkSyncSepoliaTestnet; } }));
var zetachainAthensTestnet_js_1 = __webpack_require__(/*! ./definitions/zetachainAthensTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/zetachainAthensTestnet.js");
Object.defineProperty(exports, "zetachainAthensTestnet", ({ enumerable: true, get: function () { return zetachainAthensTestnet_js_1.zetachainAthensTestnet; } }));
var zilliqa_js_1 = __webpack_require__(/*! ./definitions/zilliqa.js */ "../../node_modules/viem/_cjs/chains/definitions/zilliqa.js");
Object.defineProperty(exports, "zilliqa", ({ enumerable: true, get: function () { return zilliqa_js_1.zilliqa; } }));
var zilliqaTestnet_js_1 = __webpack_require__(/*! ./definitions/zilliqaTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/zilliqaTestnet.js");
Object.defineProperty(exports, "zilliqaTestnet", ({ enumerable: true, get: function () { return zilliqaTestnet_js_1.zilliqaTestnet; } }));
var zora_js_1 = __webpack_require__(/*! ./definitions/zora.js */ "../../node_modules/viem/_cjs/chains/definitions/zora.js");
Object.defineProperty(exports, "zora", ({ enumerable: true, get: function () { return zora_js_1.zora; } }));
var zoraSepolia_js_1 = __webpack_require__(/*! ./definitions/zoraSepolia.js */ "../../node_modules/viem/_cjs/chains/definitions/zoraSepolia.js");
Object.defineProperty(exports, "zoraSepolia", ({ enumerable: true, get: function () { return zoraSepolia_js_1.zoraSepolia; } }));
var zoraTestnet_js_1 = __webpack_require__(/*! ./definitions/zoraTestnet.js */ "../../node_modules/viem/_cjs/chains/definitions/zoraTestnet.js");
Object.defineProperty(exports, "zoraTestnet", ({ enumerable: true, get: function () { return zoraTestnet_js_1.zoraTestnet; } }));


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/optimism/formatters.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/optimism/formatters.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formattersOptimism = void 0;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const block_js_1 = __webpack_require__(/*! ../../utils/formatters/block.js */ "../../node_modules/viem/_cjs/utils/formatters/block.js");
const transaction_js_1 = __webpack_require__(/*! ../../utils/formatters/transaction.js */ "../../node_modules/viem/_cjs/utils/formatters/transaction.js");
const transactionReceipt_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionReceipt.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionReceipt.js");
exports.formattersOptimism = {
    block: (0, block_js_1.defineBlock)({
        format(args) {
            const transactions = args.transactions?.map((transaction) => {
                if (typeof transaction === 'string')
                    return transaction;
                const formatted = (0, transaction_js_1.formatTransaction)(transaction);
                if (formatted.typeHex === '0x7e') {
                    formatted.isSystemTx = transaction.isSystemTx;
                    formatted.mint = transaction.mint
                        ? (0, fromHex_js_1.hexToBigInt)(transaction.mint)
                        : undefined;
                    formatted.sourceHash = transaction.sourceHash;
                    formatted.type = 'deposit';
                }
                return formatted;
            });
            return {
                transactions,
                stateRoot: args.stateRoot,
            };
        },
    }),
    transaction: (0, transaction_js_1.defineTransaction)({
        format(args) {
            const transaction = {};
            if (args.type === '0x7e') {
                transaction.isSystemTx = args.isSystemTx;
                transaction.mint = args.mint ? (0, fromHex_js_1.hexToBigInt)(args.mint) : undefined;
                transaction.sourceHash = args.sourceHash;
                transaction.type = 'deposit';
            }
            return transaction;
        },
    }),
    transactionReceipt: (0, transactionReceipt_js_1.defineTransactionReceipt)({
        format(args) {
            return {
                l1GasPrice: args.l1GasPrice ? (0, fromHex_js_1.hexToBigInt)(args.l1GasPrice) : null,
                l1GasUsed: args.l1GasUsed ? (0, fromHex_js_1.hexToBigInt)(args.l1GasUsed) : null,
                l1Fee: args.l1Fee ? (0, fromHex_js_1.hexToBigInt)(args.l1Fee) : null,
                l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null,
            };
        },
    }),
};


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/zksync/formatters.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/zksync/formatters.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formattersZkSync = void 0;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toBytes_js_1 = __webpack_require__(/*! ../../utils/encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const block_js_1 = __webpack_require__(/*! ../../utils/formatters/block.js */ "../../node_modules/viem/_cjs/utils/formatters/block.js");
const log_js_1 = __webpack_require__(/*! ../../utils/formatters/log.js */ "../../node_modules/viem/_cjs/utils/formatters/log.js");
const transaction_js_1 = __webpack_require__(/*! ../../utils/formatters/transaction.js */ "../../node_modules/viem/_cjs/utils/formatters/transaction.js");
const transactionReceipt_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionReceipt.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionReceipt.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
exports.formattersZkSync = {
    block: (0, block_js_1.defineBlock)({
        format(args) {
            const transactions = args.transactions?.map((transaction) => {
                if (typeof transaction === 'string')
                    return transaction;
                const formatted = exports.formattersZkSync.transaction.format(transaction);
                if (formatted.typeHex === '0x71')
                    formatted.type = 'eip712';
                else if (formatted.typeHex === '0xff')
                    formatted.type = 'priority';
                return formatted;
            });
            return {
                l1BatchNumber: args.l1BatchNumber
                    ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchNumber)
                    : null,
                l1BatchTimestamp: args.l1BatchTimestamp
                    ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchTimestamp)
                    : null,
                transactions,
            };
        },
    }),
    transaction: (0, transaction_js_1.defineTransaction)({
        format(args) {
            const transaction = {};
            if (args.type === '0x71')
                transaction.type = 'eip712';
            else if (args.type === '0xff')
                transaction.type = 'priority';
            return {
                ...transaction,
                l1BatchNumber: args.l1BatchNumber
                    ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchNumber)
                    : null,
                l1BatchTxIndex: args.l1BatchTxIndex
                    ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchTxIndex)
                    : null,
            };
        },
    }),
    transactionReceipt: (0, transactionReceipt_js_1.defineTransactionReceipt)({
        format(args) {
            return {
                l1BatchNumber: args.l1BatchNumber
                    ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchNumber)
                    : null,
                l1BatchTxIndex: args.l1BatchTxIndex
                    ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchTxIndex)
                    : null,
                logs: args.logs.map((log) => {
                    return {
                        ...(0, log_js_1.formatLog)(log),
                        l1BatchNumber: log.l1BatchNumber
                            ? (0, fromHex_js_1.hexToBigInt)(log.l1BatchNumber)
                            : null,
                        transactionLogIndex: (0, fromHex_js_1.hexToNumber)(log.transactionLogIndex),
                        logType: log.logType,
                    };
                }),
                l2ToL1Logs: args.l2ToL1Logs.map((l2ToL1Log) => {
                    return {
                        blockNumber: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.blockHash),
                        blockHash: l2ToL1Log.blockHash,
                        l1BatchNumber: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.l1BatchNumber),
                        transactionIndex: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.transactionIndex),
                        shardId: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.shardId),
                        isService: l2ToL1Log.isService,
                        sender: l2ToL1Log.sender,
                        key: l2ToL1Log.key,
                        value: l2ToL1Log.value,
                        transactionHash: l2ToL1Log.transactionHash,
                        logIndex: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.logIndex),
                    };
                }),
            };
        },
    }),
    transactionRequest: (0, transactionRequest_js_1.defineTransactionRequest)({
        exclude: [
            'customSignature',
            'factoryDeps',
            'gasPerPubdata',
            'paymaster',
            'paymasterInput',
        ],
        format(args) {
            if (args.gasPerPubdata ||
                (args.paymaster && args.paymasterInput) ||
                args.factoryDeps ||
                args.customSignature)
                return {
                    eip712Meta: {
                        ...(args.gasPerPubdata
                            ? { gasPerPubdata: (0, toHex_js_1.toHex)(args.gasPerPubdata) }
                            : {}),
                        ...(args.paymaster && args.paymasterInput
                            ? {
                                paymasterParams: {
                                    paymaster: args.paymaster,
                                    paymasterInput: Array.from((0, toBytes_js_1.hexToBytes)(args.paymasterInput)),
                                },
                            }
                            : {}),
                        ...(args.factoryDeps ? { factoryDeps: args.factoryDeps } : {}),
                        ...(args.customSignature
                            ? { customSignature: args.customSignature }
                            : {}),
                    },
                    type: args.type === 'eip712' ? '0x71' : '0xff',
                };
            return {};
        },
    }),
};


/***/ }),

/***/ "../../node_modules/viem/_cjs/chains/zksync/serializers.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/chains/zksync/serializers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertTransactionEIP712 = exports.serializersZkSync = exports.serializeTransactionZkSync = void 0;
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const chain_js_1 = __webpack_require__(/*! ../../errors/chain.js */ "../../node_modules/viem/_cjs/errors/chain.js");
const isAddress_js_1 = __webpack_require__(/*! ../../utils/address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
const concat_js_1 = __webpack_require__(/*! ../../utils/data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const toRlp_js_1 = __webpack_require__(/*! ../../utils/encoding/toRlp.js */ "../../node_modules/viem/_cjs/utils/encoding/toRlp.js");
const serializeTransaction_js_1 = __webpack_require__(/*! ../../utils/transaction/serializeTransaction.js */ "../../node_modules/viem/_cjs/utils/transaction/serializeTransaction.js");
const serializeTransactionZkSync = (tx, signature) => {
    if (isEIP712(tx))
        return serializeTransactionZkSyncEIP712(tx);
    return (0, serializeTransaction_js_1.serializeTransaction)(tx, signature);
};
exports.serializeTransactionZkSync = serializeTransactionZkSync;
exports.serializersZkSync = {
    transaction: exports.serializeTransactionZkSync,
};
function serializeTransactionZkSyncEIP712(transaction) {
    const { chainId, gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data, } = transaction;
    assertTransactionEIP712(transaction);
    const serializedTransaction = [
        nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : '0x',
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : '0x',
        gas ? (0, toHex_js_1.toHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, toHex_js_1.toHex)(value) : '0x',
        data ?? '0x',
        (0, toHex_js_1.toHex)(chainId),
        (0, toHex_js_1.toHex)(''),
        (0, toHex_js_1.toHex)(''),
        (0, toHex_js_1.toHex)(chainId),
        from ?? '0x',
        gasPerPubdata ? (0, toHex_js_1.toHex)(gasPerPubdata) : '0x',
        factoryDeps ?? [],
        customSignature ?? '0x',
        paymaster && paymasterInput ? [paymaster, paymasterInput] : [],
    ];
    return (0, concat_js_1.concatHex)([
        '0x71',
        (0, toRlp_js_1.toRlp)(serializedTransaction),
    ]);
}
function isEIP712(transaction) {
    if ('customSignature' in transaction ||
        'paymaster' in transaction ||
        'paymasterInput' in transaction ||
        'gasPerPubdata' in transaction ||
        'factoryDeps' in transaction)
        return true;
    return false;
}
function assertTransactionEIP712(transaction) {
    const { chainId, to, from, paymaster, paymasterInput } = transaction;
    if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
    if (from && !(0, isAddress_js_1.isAddress)(from))
        throw new address_js_1.InvalidAddressError({ address: from });
    if (paymaster && !(0, isAddress_js_1.isAddress)(paymaster))
        throw new address_js_1.InvalidAddressError({ address: paymaster });
    if (paymaster && !paymasterInput) {
        throw new base_js_1.BaseError('`paymasterInput` must be provided when `paymaster` is defined');
    }
    if (!paymaster && paymasterInput) {
        throw new base_js_1.BaseError('`paymaster` must be provided when `paymasterInput` is defined');
    }
}
exports.assertTransactionEIP712 = assertTransactionEIP712;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/createClient.js":
/*!************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/createClient.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createClient = void 0;
const accounts_js_1 = __webpack_require__(/*! ../utils/accounts.js */ "../../node_modules/viem/_cjs/utils/accounts.js");
const uid_js_1 = __webpack_require__(/*! ../utils/uid.js */ "../../node_modules/viem/_cjs/utils/uid.js");
function createClient(parameters) {
    const { batch, cacheTime = parameters.pollingInterval ?? 4000, key = 'base', name = 'Base Client', pollingInterval = 4000, type = 'base', } = parameters;
    const chain = parameters.chain;
    const account = parameters.account
        ? (0, accounts_js_1.parseAccount)(parameters.account)
        : undefined;
    const { config, request, value } = parameters.transport({
        chain,
        pollingInterval,
    });
    const transport = { ...config, ...value };
    const client = {
        account,
        batch,
        cacheTime,
        chain,
        key,
        name,
        pollingInterval,
        request,
        transport,
        type,
        uid: (0, uid_js_1.uid)(),
    };
    function extend(base) {
        return (extendFn) => {
            const extended = extendFn(base);
            for (const key in client)
                delete extended[key];
            const combined = { ...base, ...extended };
            return Object.assign(combined, { extend: extend(combined) });
        };
    }
    return Object.assign(client, { extend: extend(client) });
}
exports.createClient = createClient;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/createPublicClient.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/createPublicClient.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPublicClient = void 0;
const createClient_js_1 = __webpack_require__(/*! ./createClient.js */ "../../node_modules/viem/_cjs/clients/createClient.js");
const public_js_1 = __webpack_require__(/*! ./decorators/public.js */ "../../node_modules/viem/_cjs/clients/decorators/public.js");
function createPublicClient(parameters) {
    const { key = 'public', name = 'Public Client' } = parameters;
    const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: 'publicClient',
    });
    return client.extend(public_js_1.publicActions);
}
exports.createPublicClient = createPublicClient;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/createTestClient.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/createTestClient.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createTestClient = void 0;
const createClient_js_1 = __webpack_require__(/*! ./createClient.js */ "../../node_modules/viem/_cjs/clients/createClient.js");
const test_js_1 = __webpack_require__(/*! ./decorators/test.js */ "../../node_modules/viem/_cjs/clients/decorators/test.js");
function createTestClient(parameters) {
    const { key = 'test', name = 'Test Client', mode } = parameters;
    const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: 'testClient',
    });
    return client.extend((config) => ({
        mode,
        ...(0, test_js_1.testActions)({ mode })(config),
    }));
}
exports.createTestClient = createTestClient;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/createWalletClient.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/createWalletClient.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createWalletClient = void 0;
const createClient_js_1 = __webpack_require__(/*! ./createClient.js */ "../../node_modules/viem/_cjs/clients/createClient.js");
const wallet_js_1 = __webpack_require__(/*! ./decorators/wallet.js */ "../../node_modules/viem/_cjs/clients/decorators/wallet.js");
function createWalletClient(parameters) {
    const { key = 'wallet', name = 'Wallet Client', transport } = parameters;
    const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        transport: (opts) => transport({ ...opts, retryCount: 0 }),
        type: 'walletClient',
    });
    return client.extend(wallet_js_1.walletActions);
}
exports.createWalletClient = createWalletClient;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/decorators/public.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/decorators/public.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.publicActions = void 0;
const getEnsAddress_js_1 = __webpack_require__(/*! ../../actions/ens/getEnsAddress.js */ "../../node_modules/viem/_cjs/actions/ens/getEnsAddress.js");
const getEnsAvatar_js_1 = __webpack_require__(/*! ../../actions/ens/getEnsAvatar.js */ "../../node_modules/viem/_cjs/actions/ens/getEnsAvatar.js");
const getEnsName_js_1 = __webpack_require__(/*! ../../actions/ens/getEnsName.js */ "../../node_modules/viem/_cjs/actions/ens/getEnsName.js");
const getEnsResolver_js_1 = __webpack_require__(/*! ../../actions/ens/getEnsResolver.js */ "../../node_modules/viem/_cjs/actions/ens/getEnsResolver.js");
const getEnsText_js_1 = __webpack_require__(/*! ../../actions/ens/getEnsText.js */ "../../node_modules/viem/_cjs/actions/ens/getEnsText.js");
const call_js_1 = __webpack_require__(/*! ../../actions/public/call.js */ "../../node_modules/viem/_cjs/actions/public/call.js");
const createBlockFilter_js_1 = __webpack_require__(/*! ../../actions/public/createBlockFilter.js */ "../../node_modules/viem/_cjs/actions/public/createBlockFilter.js");
const createContractEventFilter_js_1 = __webpack_require__(/*! ../../actions/public/createContractEventFilter.js */ "../../node_modules/viem/_cjs/actions/public/createContractEventFilter.js");
const createEventFilter_js_1 = __webpack_require__(/*! ../../actions/public/createEventFilter.js */ "../../node_modules/viem/_cjs/actions/public/createEventFilter.js");
const createPendingTransactionFilter_js_1 = __webpack_require__(/*! ../../actions/public/createPendingTransactionFilter.js */ "../../node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js");
const estimateContractGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateContractGas.js */ "../../node_modules/viem/_cjs/actions/public/estimateContractGas.js");
const estimateFeesPerGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateFeesPerGas.js */ "../../node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js");
const estimateGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateGas.js */ "../../node_modules/viem/_cjs/actions/public/estimateGas.js");
const estimateMaxPriorityFeePerGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateMaxPriorityFeePerGas.js */ "../../node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js");
const getBalance_js_1 = __webpack_require__(/*! ../../actions/public/getBalance.js */ "../../node_modules/viem/_cjs/actions/public/getBalance.js");
const getBlock_js_1 = __webpack_require__(/*! ../../actions/public/getBlock.js */ "../../node_modules/viem/_cjs/actions/public/getBlock.js");
const getBlockNumber_js_1 = __webpack_require__(/*! ../../actions/public/getBlockNumber.js */ "../../node_modules/viem/_cjs/actions/public/getBlockNumber.js");
const getBlockTransactionCount_js_1 = __webpack_require__(/*! ../../actions/public/getBlockTransactionCount.js */ "../../node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js");
const getBytecode_js_1 = __webpack_require__(/*! ../../actions/public/getBytecode.js */ "../../node_modules/viem/_cjs/actions/public/getBytecode.js");
const getChainId_js_1 = __webpack_require__(/*! ../../actions/public/getChainId.js */ "../../node_modules/viem/_cjs/actions/public/getChainId.js");
const getContractEvents_js_1 = __webpack_require__(/*! ../../actions/public/getContractEvents.js */ "../../node_modules/viem/_cjs/actions/public/getContractEvents.js");
const getFeeHistory_js_1 = __webpack_require__(/*! ../../actions/public/getFeeHistory.js */ "../../node_modules/viem/_cjs/actions/public/getFeeHistory.js");
const getFilterChanges_js_1 = __webpack_require__(/*! ../../actions/public/getFilterChanges.js */ "../../node_modules/viem/_cjs/actions/public/getFilterChanges.js");
const getFilterLogs_js_1 = __webpack_require__(/*! ../../actions/public/getFilterLogs.js */ "../../node_modules/viem/_cjs/actions/public/getFilterLogs.js");
const getGasPrice_js_1 = __webpack_require__(/*! ../../actions/public/getGasPrice.js */ "../../node_modules/viem/_cjs/actions/public/getGasPrice.js");
const getLogs_js_1 = __webpack_require__(/*! ../../actions/public/getLogs.js */ "../../node_modules/viem/_cjs/actions/public/getLogs.js");
const getProof_js_1 = __webpack_require__(/*! ../../actions/public/getProof.js */ "../../node_modules/viem/_cjs/actions/public/getProof.js");
const getStorageAt_js_1 = __webpack_require__(/*! ../../actions/public/getStorageAt.js */ "../../node_modules/viem/_cjs/actions/public/getStorageAt.js");
const getTransaction_js_1 = __webpack_require__(/*! ../../actions/public/getTransaction.js */ "../../node_modules/viem/_cjs/actions/public/getTransaction.js");
const getTransactionConfirmations_js_1 = __webpack_require__(/*! ../../actions/public/getTransactionConfirmations.js */ "../../node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js");
const getTransactionCount_js_1 = __webpack_require__(/*! ../../actions/public/getTransactionCount.js */ "../../node_modules/viem/_cjs/actions/public/getTransactionCount.js");
const getTransactionReceipt_js_1 = __webpack_require__(/*! ../../actions/public/getTransactionReceipt.js */ "../../node_modules/viem/_cjs/actions/public/getTransactionReceipt.js");
const multicall_js_1 = __webpack_require__(/*! ../../actions/public/multicall.js */ "../../node_modules/viem/_cjs/actions/public/multicall.js");
const readContract_js_1 = __webpack_require__(/*! ../../actions/public/readContract.js */ "../../node_modules/viem/_cjs/actions/public/readContract.js");
const simulateContract_js_1 = __webpack_require__(/*! ../../actions/public/simulateContract.js */ "../../node_modules/viem/_cjs/actions/public/simulateContract.js");
const uninstallFilter_js_1 = __webpack_require__(/*! ../../actions/public/uninstallFilter.js */ "../../node_modules/viem/_cjs/actions/public/uninstallFilter.js");
const verifyMessage_js_1 = __webpack_require__(/*! ../../actions/public/verifyMessage.js */ "../../node_modules/viem/_cjs/actions/public/verifyMessage.js");
const verifyTypedData_js_1 = __webpack_require__(/*! ../../actions/public/verifyTypedData.js */ "../../node_modules/viem/_cjs/actions/public/verifyTypedData.js");
const waitForTransactionReceipt_js_1 = __webpack_require__(/*! ../../actions/public/waitForTransactionReceipt.js */ "../../node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js");
const watchBlockNumber_js_1 = __webpack_require__(/*! ../../actions/public/watchBlockNumber.js */ "../../node_modules/viem/_cjs/actions/public/watchBlockNumber.js");
const watchBlocks_js_1 = __webpack_require__(/*! ../../actions/public/watchBlocks.js */ "../../node_modules/viem/_cjs/actions/public/watchBlocks.js");
const watchContractEvent_js_1 = __webpack_require__(/*! ../../actions/public/watchContractEvent.js */ "../../node_modules/viem/_cjs/actions/public/watchContractEvent.js");
const watchEvent_js_1 = __webpack_require__(/*! ../../actions/public/watchEvent.js */ "../../node_modules/viem/_cjs/actions/public/watchEvent.js");
const watchPendingTransactions_js_1 = __webpack_require__(/*! ../../actions/public/watchPendingTransactions.js */ "../../node_modules/viem/_cjs/actions/public/watchPendingTransactions.js");
const prepareTransactionRequest_js_1 = __webpack_require__(/*! ../../actions/wallet/prepareTransactionRequest.js */ "../../node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js");
const sendRawTransaction_js_1 = __webpack_require__(/*! ../../actions/wallet/sendRawTransaction.js */ "../../node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js");
function publicActions(client) {
    return {
        call: (args) => (0, call_js_1.call)(client, args),
        createBlockFilter: () => (0, createBlockFilter_js_1.createBlockFilter)(client),
        createContractEventFilter: (args) => (0, createContractEventFilter_js_1.createContractEventFilter)(client, args),
        createEventFilter: (args) => (0, createEventFilter_js_1.createEventFilter)(client, args),
        createPendingTransactionFilter: () => (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client),
        estimateContractGas: (args) => (0, estimateContractGas_js_1.estimateContractGas)(client, args),
        estimateGas: (args) => (0, estimateGas_js_1.estimateGas)(client, args),
        getBalance: (args) => (0, getBalance_js_1.getBalance)(client, args),
        getBlock: (args) => (0, getBlock_js_1.getBlock)(client, args),
        getBlockNumber: (args) => (0, getBlockNumber_js_1.getBlockNumber)(client, args),
        getBlockTransactionCount: (args) => (0, getBlockTransactionCount_js_1.getBlockTransactionCount)(client, args),
        getBytecode: (args) => (0, getBytecode_js_1.getBytecode)(client, args),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getContractEvents: (args) => (0, getContractEvents_js_1.getContractEvents)(client, args),
        getEnsAddress: (args) => (0, getEnsAddress_js_1.getEnsAddress)(client, args),
        getEnsAvatar: (args) => (0, getEnsAvatar_js_1.getEnsAvatar)(client, args),
        getEnsName: (args) => (0, getEnsName_js_1.getEnsName)(client, args),
        getEnsResolver: (args) => (0, getEnsResolver_js_1.getEnsResolver)(client, args),
        getEnsText: (args) => (0, getEnsText_js_1.getEnsText)(client, args),
        getFeeHistory: (args) => (0, getFeeHistory_js_1.getFeeHistory)(client, args),
        estimateFeesPerGas: (args) => (0, estimateFeesPerGas_js_1.estimateFeesPerGas)(client, args),
        getFilterChanges: (args) => (0, getFilterChanges_js_1.getFilterChanges)(client, args),
        getFilterLogs: (args) => (0, getFilterLogs_js_1.getFilterLogs)(client, args),
        getGasPrice: () => (0, getGasPrice_js_1.getGasPrice)(client),
        getLogs: (args) => (0, getLogs_js_1.getLogs)(client, args),
        getProof: (args) => (0, getProof_js_1.getProof)(client, args),
        estimateMaxPriorityFeePerGas: (args) => (0, estimateMaxPriorityFeePerGas_js_1.estimateMaxPriorityFeePerGas)(client, args),
        getStorageAt: (args) => (0, getStorageAt_js_1.getStorageAt)(client, args),
        getTransaction: (args) => (0, getTransaction_js_1.getTransaction)(client, args),
        getTransactionConfirmations: (args) => (0, getTransactionConfirmations_js_1.getTransactionConfirmations)(client, args),
        getTransactionCount: (args) => (0, getTransactionCount_js_1.getTransactionCount)(client, args),
        getTransactionReceipt: (args) => (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, args),
        multicall: (args) => (0, multicall_js_1.multicall)(client, args),
        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
        readContract: (args) => (0, readContract_js_1.readContract)(client, args),
        sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
        simulateContract: (args) => (0, simulateContract_js_1.simulateContract)(client, args),
        verifyMessage: (args) => (0, verifyMessage_js_1.verifyMessage)(client, args),
        verifyTypedData: (args) => (0, verifyTypedData_js_1.verifyTypedData)(client, args),
        uninstallFilter: (args) => (0, uninstallFilter_js_1.uninstallFilter)(client, args),
        waitForTransactionReceipt: (args) => (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)(client, args),
        watchBlocks: (args) => (0, watchBlocks_js_1.watchBlocks)(client, args),
        watchBlockNumber: (args) => (0, watchBlockNumber_js_1.watchBlockNumber)(client, args),
        watchContractEvent: (args) => (0, watchContractEvent_js_1.watchContractEvent)(client, args),
        watchEvent: (args) => (0, watchEvent_js_1.watchEvent)(client, args),
        watchPendingTransactions: (args) => (0, watchPendingTransactions_js_1.watchPendingTransactions)(client, args),
    };
}
exports.publicActions = publicActions;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/decorators/test.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/decorators/test.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.testActions = void 0;
const dropTransaction_js_1 = __webpack_require__(/*! ../../actions/test/dropTransaction.js */ "../../node_modules/viem/_cjs/actions/test/dropTransaction.js");
const dumpState_js_1 = __webpack_require__(/*! ../../actions/test/dumpState.js */ "../../node_modules/viem/_cjs/actions/test/dumpState.js");
const getAutomine_js_1 = __webpack_require__(/*! ../../actions/test/getAutomine.js */ "../../node_modules/viem/_cjs/actions/test/getAutomine.js");
const getTxpoolContent_js_1 = __webpack_require__(/*! ../../actions/test/getTxpoolContent.js */ "../../node_modules/viem/_cjs/actions/test/getTxpoolContent.js");
const getTxpoolStatus_js_1 = __webpack_require__(/*! ../../actions/test/getTxpoolStatus.js */ "../../node_modules/viem/_cjs/actions/test/getTxpoolStatus.js");
const impersonateAccount_js_1 = __webpack_require__(/*! ../../actions/test/impersonateAccount.js */ "../../node_modules/viem/_cjs/actions/test/impersonateAccount.js");
const increaseTime_js_1 = __webpack_require__(/*! ../../actions/test/increaseTime.js */ "../../node_modules/viem/_cjs/actions/test/increaseTime.js");
const inspectTxpool_js_1 = __webpack_require__(/*! ../../actions/test/inspectTxpool.js */ "../../node_modules/viem/_cjs/actions/test/inspectTxpool.js");
const loadState_js_1 = __webpack_require__(/*! ../../actions/test/loadState.js */ "../../node_modules/viem/_cjs/actions/test/loadState.js");
const mine_js_1 = __webpack_require__(/*! ../../actions/test/mine.js */ "../../node_modules/viem/_cjs/actions/test/mine.js");
const removeBlockTimestampInterval_js_1 = __webpack_require__(/*! ../../actions/test/removeBlockTimestampInterval.js */ "../../node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js");
const reset_js_1 = __webpack_require__(/*! ../../actions/test/reset.js */ "../../node_modules/viem/_cjs/actions/test/reset.js");
const revert_js_1 = __webpack_require__(/*! ../../actions/test/revert.js */ "../../node_modules/viem/_cjs/actions/test/revert.js");
const sendUnsignedTransaction_js_1 = __webpack_require__(/*! ../../actions/test/sendUnsignedTransaction.js */ "../../node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js");
const setAutomine_js_1 = __webpack_require__(/*! ../../actions/test/setAutomine.js */ "../../node_modules/viem/_cjs/actions/test/setAutomine.js");
const setBalance_js_1 = __webpack_require__(/*! ../../actions/test/setBalance.js */ "../../node_modules/viem/_cjs/actions/test/setBalance.js");
const setBlockGasLimit_js_1 = __webpack_require__(/*! ../../actions/test/setBlockGasLimit.js */ "../../node_modules/viem/_cjs/actions/test/setBlockGasLimit.js");
const setBlockTimestampInterval_js_1 = __webpack_require__(/*! ../../actions/test/setBlockTimestampInterval.js */ "../../node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js");
const setCode_js_1 = __webpack_require__(/*! ../../actions/test/setCode.js */ "../../node_modules/viem/_cjs/actions/test/setCode.js");
const setCoinbase_js_1 = __webpack_require__(/*! ../../actions/test/setCoinbase.js */ "../../node_modules/viem/_cjs/actions/test/setCoinbase.js");
const setIntervalMining_js_1 = __webpack_require__(/*! ../../actions/test/setIntervalMining.js */ "../../node_modules/viem/_cjs/actions/test/setIntervalMining.js");
const setLoggingEnabled_js_1 = __webpack_require__(/*! ../../actions/test/setLoggingEnabled.js */ "../../node_modules/viem/_cjs/actions/test/setLoggingEnabled.js");
const setMinGasPrice_js_1 = __webpack_require__(/*! ../../actions/test/setMinGasPrice.js */ "../../node_modules/viem/_cjs/actions/test/setMinGasPrice.js");
const setNextBlockBaseFeePerGas_js_1 = __webpack_require__(/*! ../../actions/test/setNextBlockBaseFeePerGas.js */ "../../node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js");
const setNextBlockTimestamp_js_1 = __webpack_require__(/*! ../../actions/test/setNextBlockTimestamp.js */ "../../node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js");
const setNonce_js_1 = __webpack_require__(/*! ../../actions/test/setNonce.js */ "../../node_modules/viem/_cjs/actions/test/setNonce.js");
const setRpcUrl_js_1 = __webpack_require__(/*! ../../actions/test/setRpcUrl.js */ "../../node_modules/viem/_cjs/actions/test/setRpcUrl.js");
const setStorageAt_js_1 = __webpack_require__(/*! ../../actions/test/setStorageAt.js */ "../../node_modules/viem/_cjs/actions/test/setStorageAt.js");
const snapshot_js_1 = __webpack_require__(/*! ../../actions/test/snapshot.js */ "../../node_modules/viem/_cjs/actions/test/snapshot.js");
const stopImpersonatingAccount_js_1 = __webpack_require__(/*! ../../actions/test/stopImpersonatingAccount.js */ "../../node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js");
function testActions({ mode, }) {
    return (client_) => {
        const client = client_.extend(() => ({
            mode,
        }));
        return {
            dropTransaction: (args) => (0, dropTransaction_js_1.dropTransaction)(client, args),
            dumpState: () => (0, dumpState_js_1.dumpState)(client),
            getAutomine: () => (0, getAutomine_js_1.getAutomine)(client),
            getTxpoolContent: () => (0, getTxpoolContent_js_1.getTxpoolContent)(client),
            getTxpoolStatus: () => (0, getTxpoolStatus_js_1.getTxpoolStatus)(client),
            impersonateAccount: (args) => (0, impersonateAccount_js_1.impersonateAccount)(client, args),
            increaseTime: (args) => (0, increaseTime_js_1.increaseTime)(client, args),
            inspectTxpool: () => (0, inspectTxpool_js_1.inspectTxpool)(client),
            loadState: (args) => (0, loadState_js_1.loadState)(client, args),
            mine: (args) => (0, mine_js_1.mine)(client, args),
            removeBlockTimestampInterval: () => (0, removeBlockTimestampInterval_js_1.removeBlockTimestampInterval)(client),
            reset: (args) => (0, reset_js_1.reset)(client, args),
            revert: (args) => (0, revert_js_1.revert)(client, args),
            sendUnsignedTransaction: (args) => (0, sendUnsignedTransaction_js_1.sendUnsignedTransaction)(client, args),
            setAutomine: (args) => (0, setAutomine_js_1.setAutomine)(client, args),
            setBalance: (args) => (0, setBalance_js_1.setBalance)(client, args),
            setBlockGasLimit: (args) => (0, setBlockGasLimit_js_1.setBlockGasLimit)(client, args),
            setBlockTimestampInterval: (args) => (0, setBlockTimestampInterval_js_1.setBlockTimestampInterval)(client, args),
            setCode: (args) => (0, setCode_js_1.setCode)(client, args),
            setCoinbase: (args) => (0, setCoinbase_js_1.setCoinbase)(client, args),
            setIntervalMining: (args) => (0, setIntervalMining_js_1.setIntervalMining)(client, args),
            setLoggingEnabled: (args) => (0, setLoggingEnabled_js_1.setLoggingEnabled)(client, args),
            setMinGasPrice: (args) => (0, setMinGasPrice_js_1.setMinGasPrice)(client, args),
            setNextBlockBaseFeePerGas: (args) => (0, setNextBlockBaseFeePerGas_js_1.setNextBlockBaseFeePerGas)(client, args),
            setNextBlockTimestamp: (args) => (0, setNextBlockTimestamp_js_1.setNextBlockTimestamp)(client, args),
            setNonce: (args) => (0, setNonce_js_1.setNonce)(client, args),
            setRpcUrl: (args) => (0, setRpcUrl_js_1.setRpcUrl)(client, args),
            setStorageAt: (args) => (0, setStorageAt_js_1.setStorageAt)(client, args),
            snapshot: () => (0, snapshot_js_1.snapshot)(client),
            stopImpersonatingAccount: (args) => (0, stopImpersonatingAccount_js_1.stopImpersonatingAccount)(client, args),
        };
    };
}
exports.testActions = testActions;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/decorators/wallet.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/decorators/wallet.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.walletActions = void 0;
const getChainId_js_1 = __webpack_require__(/*! ../../actions/public/getChainId.js */ "../../node_modules/viem/_cjs/actions/public/getChainId.js");
const addChain_js_1 = __webpack_require__(/*! ../../actions/wallet/addChain.js */ "../../node_modules/viem/_cjs/actions/wallet/addChain.js");
const deployContract_js_1 = __webpack_require__(/*! ../../actions/wallet/deployContract.js */ "../../node_modules/viem/_cjs/actions/wallet/deployContract.js");
const getAddresses_js_1 = __webpack_require__(/*! ../../actions/wallet/getAddresses.js */ "../../node_modules/viem/_cjs/actions/wallet/getAddresses.js");
const getPermissions_js_1 = __webpack_require__(/*! ../../actions/wallet/getPermissions.js */ "../../node_modules/viem/_cjs/actions/wallet/getPermissions.js");
const prepareTransactionRequest_js_1 = __webpack_require__(/*! ../../actions/wallet/prepareTransactionRequest.js */ "../../node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js");
const requestAddresses_js_1 = __webpack_require__(/*! ../../actions/wallet/requestAddresses.js */ "../../node_modules/viem/_cjs/actions/wallet/requestAddresses.js");
const requestPermissions_js_1 = __webpack_require__(/*! ../../actions/wallet/requestPermissions.js */ "../../node_modules/viem/_cjs/actions/wallet/requestPermissions.js");
const sendRawTransaction_js_1 = __webpack_require__(/*! ../../actions/wallet/sendRawTransaction.js */ "../../node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js");
const sendTransaction_js_1 = __webpack_require__(/*! ../../actions/wallet/sendTransaction.js */ "../../node_modules/viem/_cjs/actions/wallet/sendTransaction.js");
const signMessage_js_1 = __webpack_require__(/*! ../../actions/wallet/signMessage.js */ "../../node_modules/viem/_cjs/actions/wallet/signMessage.js");
const signTransaction_js_1 = __webpack_require__(/*! ../../actions/wallet/signTransaction.js */ "../../node_modules/viem/_cjs/actions/wallet/signTransaction.js");
const signTypedData_js_1 = __webpack_require__(/*! ../../actions/wallet/signTypedData.js */ "../../node_modules/viem/_cjs/actions/wallet/signTypedData.js");
const switchChain_js_1 = __webpack_require__(/*! ../../actions/wallet/switchChain.js */ "../../node_modules/viem/_cjs/actions/wallet/switchChain.js");
const watchAsset_js_1 = __webpack_require__(/*! ../../actions/wallet/watchAsset.js */ "../../node_modules/viem/_cjs/actions/wallet/watchAsset.js");
const writeContract_js_1 = __webpack_require__(/*! ../../actions/wallet/writeContract.js */ "../../node_modules/viem/_cjs/actions/wallet/writeContract.js");
function walletActions(client) {
    return {
        addChain: (args) => (0, addChain_js_1.addChain)(client, args),
        deployContract: (args) => (0, deployContract_js_1.deployContract)(client, args),
        getAddresses: () => (0, getAddresses_js_1.getAddresses)(client),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getPermissions: () => (0, getPermissions_js_1.getPermissions)(client),
        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
        requestAddresses: () => (0, requestAddresses_js_1.requestAddresses)(client),
        requestPermissions: (args) => (0, requestPermissions_js_1.requestPermissions)(client, args),
        sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
        sendTransaction: (args) => (0, sendTransaction_js_1.sendTransaction)(client, args),
        signMessage: (args) => (0, signMessage_js_1.signMessage)(client, args),
        signTransaction: (args) => (0, signTransaction_js_1.signTransaction)(client, args),
        signTypedData: (args) => (0, signTypedData_js_1.signTypedData)(client, args),
        switchChain: (args) => (0, switchChain_js_1.switchChain)(client, args),
        watchAsset: (args) => (0, watchAsset_js_1.watchAsset)(client, args),
        writeContract: (args) => (0, writeContract_js_1.writeContract)(client, args),
    };
}
exports.walletActions = walletActions;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/transports/createTransport.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/transports/createTransport.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createTransport = void 0;
const buildRequest_js_1 = __webpack_require__(/*! ../../utils/buildRequest.js */ "../../node_modules/viem/_cjs/utils/buildRequest.js");
function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type, }, value) {
    return {
        config: { key, name, request, retryCount, retryDelay, timeout, type },
        request: (0, buildRequest_js_1.buildRequest)(request, { retryCount, retryDelay }),
        value,
    };
}
exports.createTransport = createTransport;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/transports/custom.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/transports/custom.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.custom = void 0;
const createTransport_js_1 = __webpack_require__(/*! ./createTransport.js */ "../../node_modules/viem/_cjs/clients/transports/createTransport.js");
function custom(provider, config = {}) {
    const { key = 'custom', name = 'Custom Provider', retryDelay } = config;
    return ({ retryCount: defaultRetryCount }) => (0, createTransport_js_1.createTransport)({
        key,
        name,
        request: provider.request.bind(provider),
        retryCount: config.retryCount ?? defaultRetryCount,
        retryDelay,
        type: 'custom',
    });
}
exports.custom = custom;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/transports/fallback.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/transports/fallback.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rankTransports = exports.fallback = void 0;
const buildRequest_js_1 = __webpack_require__(/*! ../../utils/buildRequest.js */ "../../node_modules/viem/_cjs/utils/buildRequest.js");
const wait_js_1 = __webpack_require__(/*! ../../utils/wait.js */ "../../node_modules/viem/_cjs/utils/wait.js");
const createTransport_js_1 = __webpack_require__(/*! ./createTransport.js */ "../../node_modules/viem/_cjs/clients/transports/createTransport.js");
function fallback(transports_, config = {}) {
    const { key = 'fallback', name = 'Fallback', rank = false, retryCount, retryDelay, } = config;
    return ({ chain, pollingInterval = 4000, timeout }) => {
        let transports = transports_;
        let onResponse = () => { };
        const transport = (0, createTransport_js_1.createTransport)({
            key,
            name,
            async request({ method, params }) {
                const fetch = async (i = 0) => {
                    const transport = transports[i]({ chain, retryCount: 0, timeout });
                    try {
                        const response = await transport.request({
                            method,
                            params,
                        });
                        onResponse({
                            method,
                            params: params,
                            response,
                            transport,
                            status: 'success',
                        });
                        return response;
                    }
                    catch (err) {
                        onResponse({
                            error: err,
                            method,
                            params: params,
                            transport,
                            status: 'error',
                        });
                        if ((0, buildRequest_js_1.isDeterministicError)(err))
                            throw err;
                        if (i === transports.length - 1)
                            throw err;
                        return fetch(i + 1);
                    }
                };
                return fetch();
            },
            retryCount,
            retryDelay,
            type: 'fallback',
        }, {
            onResponse: (fn) => (onResponse = fn),
            transports: transports.map((fn) => fn({ chain, retryCount: 0 })),
        });
        if (rank) {
            const rankOptions = (typeof rank === 'object' ? rank : {});
            rankTransports({
                chain,
                interval: rankOptions.interval ?? pollingInterval,
                onTransports: (transports_) => (transports = transports_),
                sampleCount: rankOptions.sampleCount,
                timeout: rankOptions.timeout,
                transports,
                weights: rankOptions.weights,
            });
        }
        return transport;
    };
}
exports.fallback = fallback;
function rankTransports({ chain, interval = 4000, onTransports, sampleCount = 10, timeout = 1000, transports, weights = {}, }) {
    const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
    const samples = [];
    const rankTransports_ = async () => {
        const sample = await Promise.all(transports.map(async (transport) => {
            const transport_ = transport({ chain, retryCount: 0, timeout });
            const start = Date.now();
            let end;
            let success;
            try {
                await transport_.request({ method: 'net_listening' });
                success = 1;
            }
            catch {
                success = 0;
            }
            finally {
                end = Date.now();
            }
            const latency = end - start;
            return { latency, success };
        }));
        samples.push(sample);
        if (samples.length > sampleCount)
            samples.shift();
        const maxLatency = Math.max(...samples.map((sample) => Math.max(...sample.map(({ latency }) => latency))));
        const scores = transports
            .map((_, i) => {
            const latencies = samples.map((sample) => sample[i].latency);
            const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) /
                latencies.length;
            const latencyScore = 1 - meanLatency / maxLatency;
            const successes = samples.map((sample) => sample[i].success);
            const stabilityScore = successes.reduce((acc, success) => acc + success, 0) /
                successes.length;
            if (stabilityScore === 0)
                return [0, i];
            return [
                latencyWeight * latencyScore + stabilityWeight * stabilityScore,
                i,
            ];
        })
            .sort((a, b) => b[0] - a[0]);
        onTransports(scores.map(([, i]) => transports[i]));
        await (0, wait_js_1.wait)(interval);
        rankTransports_();
    };
    rankTransports_();
}
exports.rankTransports = rankTransports;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/transports/http.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/transports/http.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.http = void 0;
const request_js_1 = __webpack_require__(/*! ../../errors/request.js */ "../../node_modules/viem/_cjs/errors/request.js");
const transport_js_1 = __webpack_require__(/*! ../../errors/transport.js */ "../../node_modules/viem/_cjs/errors/transport.js");
const createBatchScheduler_js_1 = __webpack_require__(/*! ../../utils/promise/createBatchScheduler.js */ "../../node_modules/viem/_cjs/utils/promise/createBatchScheduler.js");
const rpc_js_1 = __webpack_require__(/*! ../../utils/rpc.js */ "../../node_modules/viem/_cjs/utils/rpc.js");
const createTransport_js_1 = __webpack_require__(/*! ./createTransport.js */ "../../node_modules/viem/_cjs/clients/transports/createTransport.js");
function http(url, config = {}) {
    const { batch, fetchOptions, key = 'http', name = 'HTTP JSON-RPC', retryDelay, } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const { batchSize = 1000, wait = 0 } = typeof batch === 'object' ? batch : {};
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 10000;
        const url_ = url || chain?.rpcUrls.default.http[0];
        if (!url_)
            throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
            key,
            name,
            async request({ method, params }) {
                const body = { method, params };
                const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
                    id: `${url}`,
                    wait,
                    shouldSplitBatch(requests) {
                        return requests.length > batchSize;
                    },
                    fn: (body) => rpc_js_1.rpc.http(url_, {
                        body,
                        fetchOptions,
                        timeout,
                    }),
                    sort: (a, b) => a.id - b.id,
                });
                const fn = async (body) => batch
                    ? schedule(body)
                    : [await rpc_js_1.rpc.http(url_, { body, fetchOptions, timeout })];
                const [{ error, result }] = await fn(body);
                if (error)
                    throw new request_js_1.RpcRequestError({
                        body,
                        error,
                        url: url_,
                    });
                return result;
            },
            retryCount,
            retryDelay,
            timeout,
            type: 'http',
        }, {
            fetchOptions,
            url,
        });
    };
}
exports.http = http;


/***/ }),

/***/ "../../node_modules/viem/_cjs/clients/transports/webSocket.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/clients/transports/webSocket.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.webSocket = void 0;
const request_js_1 = __webpack_require__(/*! ../../errors/request.js */ "../../node_modules/viem/_cjs/errors/request.js");
const transport_js_1 = __webpack_require__(/*! ../../errors/transport.js */ "../../node_modules/viem/_cjs/errors/transport.js");
const rpc_js_1 = __webpack_require__(/*! ../../utils/rpc.js */ "../../node_modules/viem/_cjs/utils/rpc.js");
const createTransport_js_1 = __webpack_require__(/*! ./createTransport.js */ "../../node_modules/viem/_cjs/clients/transports/createTransport.js");
function webSocket(url, config = {}) {
    const { key = 'webSocket', name = 'WebSocket JSON-RPC', retryDelay } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 10000;
        const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
        if (!url_)
            throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
            key,
            name,
            async request({ method, params }) {
                const body = { method, params };
                const socket = await (0, rpc_js_1.getSocket)(url_);
                const { error, result } = await rpc_js_1.rpc.webSocketAsync(socket, {
                    body,
                    timeout,
                });
                if (error)
                    throw new request_js_1.RpcRequestError({
                        body,
                        error,
                        url: url_,
                    });
                return result;
            },
            retryCount,
            retryDelay,
            timeout,
            type: 'webSocket',
        }, {
            getSocket() {
                return (0, rpc_js_1.getSocket)(url_);
            },
            async subscribe({ params, onData, onError }) {
                const socket = await (0, rpc_js_1.getSocket)(url_);
                const { result: subscriptionId } = await new Promise((resolve, reject) => rpc_js_1.rpc.webSocket(socket, {
                    body: {
                        method: 'eth_subscribe',
                        params,
                    },
                    onResponse(response) {
                        if (response.error) {
                            reject(response.error);
                            onError?.(response.error);
                            return;
                        }
                        if (typeof response.id === 'number') {
                            resolve(response);
                            return;
                        }
                        if (response.method !== 'eth_subscription')
                            return;
                        onData(response.params);
                    },
                }));
                return {
                    subscriptionId,
                    async unsubscribe() {
                        return new Promise((resolve) => rpc_js_1.rpc.webSocket(socket, {
                            body: {
                                method: 'eth_unsubscribe',
                                params: [subscriptionId],
                            },
                            onResponse: resolve,
                        }));
                    },
                };
            },
        });
    };
}
exports.webSocket = webSocket;


/***/ }),

/***/ "../../node_modules/viem/_cjs/constants/abis.js":
/*!******************************************************!*\
  !*** ../../node_modules/viem/_cjs/constants/abis.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.universalSignatureValidatorAbi = exports.smartAccountAbi = exports.addressResolverAbi = exports.textResolverAbi = exports.universalResolverReverseAbi = exports.universalResolverResolveAbi = exports.multicall3Abi = void 0;
exports.multicall3Abi = [
    {
        inputs: [
            {
                components: [
                    {
                        name: 'target',
                        type: 'address',
                    },
                    {
                        name: 'allowFailure',
                        type: 'bool',
                    },
                    {
                        name: 'callData',
                        type: 'bytes',
                    },
                ],
                name: 'calls',
                type: 'tuple[]',
            },
        ],
        name: 'aggregate3',
        outputs: [
            {
                components: [
                    {
                        name: 'success',
                        type: 'bool',
                    },
                    {
                        name: 'returnData',
                        type: 'bytes',
                    },
                ],
                name: 'returnData',
                type: 'tuple[]',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];
const universalResolverErrors = [
    {
        inputs: [],
        name: 'ResolverNotFound',
        type: 'error',
    },
    {
        inputs: [],
        name: 'ResolverWildcardNotSupported',
        type: 'error',
    },
];
exports.universalResolverResolveAbi = [
    ...universalResolverErrors,
    {
        name: 'resolve',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            { name: 'name', type: 'bytes' },
            { name: 'data', type: 'bytes' },
        ],
        outputs: [
            { name: '', type: 'bytes' },
            { name: 'address', type: 'address' },
        ],
    },
];
exports.universalResolverReverseAbi = [
    ...universalResolverErrors,
    {
        name: 'reverse',
        type: 'function',
        stateMutability: 'view',
        inputs: [{ type: 'bytes', name: 'reverseName' }],
        outputs: [
            { type: 'string', name: 'resolvedName' },
            { type: 'address', name: 'resolvedAddress' },
            { type: 'address', name: 'reverseResolver' },
            { type: 'address', name: 'resolver' },
        ],
    },
];
exports.textResolverAbi = [
    {
        name: 'text',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            { name: 'name', type: 'bytes32' },
            { name: 'key', type: 'string' },
        ],
        outputs: [{ name: '', type: 'string' }],
    },
];
exports.addressResolverAbi = [
    {
        name: 'addr',
        type: 'function',
        stateMutability: 'view',
        inputs: [{ name: 'name', type: 'bytes32' }],
        outputs: [{ name: '', type: 'address' }],
    },
    {
        name: 'addr',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            { name: 'name', type: 'bytes32' },
            { name: 'coinType', type: 'uint256' },
        ],
        outputs: [{ name: '', type: 'bytes' }],
    },
];
exports.smartAccountAbi = [
    {
        name: 'isValidSignature',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            { name: 'hash', type: 'bytes32' },
            { name: 'signature', type: 'bytes' },
        ],
        outputs: [{ name: '', type: 'bytes4' }],
    },
];
exports.universalSignatureValidatorAbi = [
    {
        inputs: [
            {
                internalType: 'address',
                name: '_signer',
                type: 'address',
            },
            {
                internalType: 'bytes32',
                name: '_hash',
                type: 'bytes32',
            },
            {
                internalType: 'bytes',
                name: '_signature',
                type: 'bytes',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'constructor',
    },
];


/***/ }),

/***/ "../../node_modules/viem/_cjs/constants/address.js":
/*!*********************************************************!*\
  !*** ../../node_modules/viem/_cjs/constants/address.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zeroAddress = void 0;
exports.zeroAddress = '0x0000000000000000000000000000000000000000';


/***/ }),

/***/ "../../node_modules/viem/_cjs/constants/bytes.js":
/*!*******************************************************!*\
  !*** ../../node_modules/viem/_cjs/constants/bytes.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zeroHash = void 0;
exports.zeroHash = '0x0000000000000000000000000000000000000000000000000000000000000000';


/***/ }),

/***/ "../../node_modules/viem/_cjs/constants/contract.js":
/*!**********************************************************!*\
  !*** ../../node_modules/viem/_cjs/constants/contract.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aggregate3Signature = void 0;
exports.aggregate3Signature = '0x82ad56cb';


/***/ }),

/***/ "../../node_modules/viem/_cjs/constants/contracts.js":
/*!***********************************************************!*\
  !*** ../../node_modules/viem/_cjs/constants/contracts.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.universalSignatureValidatorByteCode = void 0;
exports.universalSignatureValidatorByteCode = '0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';


/***/ }),

/***/ "../../node_modules/viem/_cjs/constants/number.js":
/*!********************************************************!*\
  !*** ../../node_modules/viem/_cjs/constants/number.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = void 0;
exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = void 0;
exports.maxInt8 = 2n ** (8n - 1n) - 1n;
exports.maxInt16 = 2n ** (16n - 1n) - 1n;
exports.maxInt24 = 2n ** (24n - 1n) - 1n;
exports.maxInt32 = 2n ** (32n - 1n) - 1n;
exports.maxInt40 = 2n ** (40n - 1n) - 1n;
exports.maxInt48 = 2n ** (48n - 1n) - 1n;
exports.maxInt56 = 2n ** (56n - 1n) - 1n;
exports.maxInt64 = 2n ** (64n - 1n) - 1n;
exports.maxInt72 = 2n ** (72n - 1n) - 1n;
exports.maxInt80 = 2n ** (80n - 1n) - 1n;
exports.maxInt88 = 2n ** (88n - 1n) - 1n;
exports.maxInt96 = 2n ** (96n - 1n) - 1n;
exports.maxInt104 = 2n ** (104n - 1n) - 1n;
exports.maxInt112 = 2n ** (112n - 1n) - 1n;
exports.maxInt120 = 2n ** (120n - 1n) - 1n;
exports.maxInt128 = 2n ** (128n - 1n) - 1n;
exports.maxInt136 = 2n ** (136n - 1n) - 1n;
exports.maxInt144 = 2n ** (144n - 1n) - 1n;
exports.maxInt152 = 2n ** (152n - 1n) - 1n;
exports.maxInt160 = 2n ** (160n - 1n) - 1n;
exports.maxInt168 = 2n ** (168n - 1n) - 1n;
exports.maxInt176 = 2n ** (176n - 1n) - 1n;
exports.maxInt184 = 2n ** (184n - 1n) - 1n;
exports.maxInt192 = 2n ** (192n - 1n) - 1n;
exports.maxInt200 = 2n ** (200n - 1n) - 1n;
exports.maxInt208 = 2n ** (208n - 1n) - 1n;
exports.maxInt216 = 2n ** (216n - 1n) - 1n;
exports.maxInt224 = 2n ** (224n - 1n) - 1n;
exports.maxInt232 = 2n ** (232n - 1n) - 1n;
exports.maxInt240 = 2n ** (240n - 1n) - 1n;
exports.maxInt248 = 2n ** (248n - 1n) - 1n;
exports.maxInt256 = 2n ** (256n - 1n) - 1n;
exports.minInt8 = -(2n ** (8n - 1n));
exports.minInt16 = -(2n ** (16n - 1n));
exports.minInt24 = -(2n ** (24n - 1n));
exports.minInt32 = -(2n ** (32n - 1n));
exports.minInt40 = -(2n ** (40n - 1n));
exports.minInt48 = -(2n ** (48n - 1n));
exports.minInt56 = -(2n ** (56n - 1n));
exports.minInt64 = -(2n ** (64n - 1n));
exports.minInt72 = -(2n ** (72n - 1n));
exports.minInt80 = -(2n ** (80n - 1n));
exports.minInt88 = -(2n ** (88n - 1n));
exports.minInt96 = -(2n ** (96n - 1n));
exports.minInt104 = -(2n ** (104n - 1n));
exports.minInt112 = -(2n ** (112n - 1n));
exports.minInt120 = -(2n ** (120n - 1n));
exports.minInt128 = -(2n ** (128n - 1n));
exports.minInt136 = -(2n ** (136n - 1n));
exports.minInt144 = -(2n ** (144n - 1n));
exports.minInt152 = -(2n ** (152n - 1n));
exports.minInt160 = -(2n ** (160n - 1n));
exports.minInt168 = -(2n ** (168n - 1n));
exports.minInt176 = -(2n ** (176n - 1n));
exports.minInt184 = -(2n ** (184n - 1n));
exports.minInt192 = -(2n ** (192n - 1n));
exports.minInt200 = -(2n ** (200n - 1n));
exports.minInt208 = -(2n ** (208n - 1n));
exports.minInt216 = -(2n ** (216n - 1n));
exports.minInt224 = -(2n ** (224n - 1n));
exports.minInt232 = -(2n ** (232n - 1n));
exports.minInt240 = -(2n ** (240n - 1n));
exports.minInt248 = -(2n ** (248n - 1n));
exports.minInt256 = -(2n ** (256n - 1n));
exports.maxUint8 = 2n ** 8n - 1n;
exports.maxUint16 = 2n ** 16n - 1n;
exports.maxUint24 = 2n ** 24n - 1n;
exports.maxUint32 = 2n ** 32n - 1n;
exports.maxUint40 = 2n ** 40n - 1n;
exports.maxUint48 = 2n ** 48n - 1n;
exports.maxUint56 = 2n ** 56n - 1n;
exports.maxUint64 = 2n ** 64n - 1n;
exports.maxUint72 = 2n ** 72n - 1n;
exports.maxUint80 = 2n ** 80n - 1n;
exports.maxUint88 = 2n ** 88n - 1n;
exports.maxUint96 = 2n ** 96n - 1n;
exports.maxUint104 = 2n ** 104n - 1n;
exports.maxUint112 = 2n ** 112n - 1n;
exports.maxUint120 = 2n ** 120n - 1n;
exports.maxUint128 = 2n ** 128n - 1n;
exports.maxUint136 = 2n ** 136n - 1n;
exports.maxUint144 = 2n ** 144n - 1n;
exports.maxUint152 = 2n ** 152n - 1n;
exports.maxUint160 = 2n ** 160n - 1n;
exports.maxUint168 = 2n ** 168n - 1n;
exports.maxUint176 = 2n ** 176n - 1n;
exports.maxUint184 = 2n ** 184n - 1n;
exports.maxUint192 = 2n ** 192n - 1n;
exports.maxUint200 = 2n ** 200n - 1n;
exports.maxUint208 = 2n ** 208n - 1n;
exports.maxUint216 = 2n ** 216n - 1n;
exports.maxUint224 = 2n ** 224n - 1n;
exports.maxUint232 = 2n ** 232n - 1n;
exports.maxUint240 = 2n ** 240n - 1n;
exports.maxUint248 = 2n ** 248n - 1n;
exports.maxUint256 = 2n ** 256n - 1n;


/***/ }),

/***/ "../../node_modules/viem/_cjs/constants/solidity.js":
/*!**********************************************************!*\
  !*** ../../node_modules/viem/_cjs/constants/solidity.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.solidityPanic = exports.solidityError = exports.panicReasons = void 0;
exports.panicReasons = {
    1: 'An `assert` condition failed.',
    17: 'Arithmic operation resulted in underflow or overflow.',
    18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',
    33: 'Attempted to convert to an invalid type.',
    34: 'Attempted to access a storage byte array that is incorrectly encoded.',
    49: 'Performed `.pop()` on an empty array',
    50: 'Array index is out of bounds.',
    65: 'Allocated too much memory or created an array which is too large.',
    81: 'Attempted to call a zero-initialized variable of internal function type.',
};
exports.solidityError = {
    inputs: [
        {
            name: 'message',
            type: 'string',
        },
    ],
    name: 'Error',
    type: 'error',
};
exports.solidityPanic = {
    inputs: [
        {
            name: 'reason',
            type: 'uint256',
        },
    ],
    name: 'Panic',
    type: 'error',
};


/***/ }),

/***/ "../../node_modules/viem/_cjs/constants/strings.js":
/*!*********************************************************!*\
  !*** ../../node_modules/viem/_cjs/constants/strings.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.presignMessagePrefix = void 0;
exports.presignMessagePrefix = '\x19Ethereum Signed Message:\n';


/***/ }),

/***/ "../../node_modules/viem/_cjs/constants/unit.js":
/*!******************************************************!*\
  !*** ../../node_modules/viem/_cjs/constants/unit.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.weiUnits = exports.gweiUnits = exports.etherUnits = void 0;
exports.etherUnits = {
    gwei: 9,
    wei: 18,
};
exports.gweiUnits = {
    ether: -9,
    wei: 9,
};
exports.weiUnits = {
    ether: -18,
    gwei: -9,
};


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/abi.js":
/*!**************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/abi.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiDecodingTypeError = exports.InvalidAbiEncodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiItemAmbiguityError = exports.AbiFunctionSignatureNotFoundError = exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingBytesSizeMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeTooSmallError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = void 0;
const formatAbiItem_js_1 = __webpack_require__(/*! ../utils/abi/formatAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const size_js_1 = __webpack_require__(/*! ../utils/data/size.js */ "../../node_modules/viem/_cjs/utils/data/size.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class AbiConstructorNotFoundError extends base_js_1.BaseError {
    constructor({ docsPath }) {
        super([
            'A constructor was not found on the ABI.',
            'Make sure you are using the correct ABI and that the constructor exists on it.',
        ].join('\n'), {
            docsPath,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiConstructorNotFoundError'
        });
    }
}
exports.AbiConstructorNotFoundError = AbiConstructorNotFoundError;
class AbiConstructorParamsNotFoundError extends base_js_1.BaseError {
    constructor({ docsPath }) {
        super([
            'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',
            'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',
        ].join('\n'), {
            docsPath,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiConstructorParamsNotFoundError'
        });
    }
}
exports.AbiConstructorParamsNotFoundError = AbiConstructorParamsNotFoundError;
class AbiDecodingDataSizeInvalidError extends base_js_1.BaseError {
    constructor({ data, size }) {
        super([
            `Data size of ${size} bytes is invalid.`,
            'Size must be in increments of 32 bytes (size % 32 === 0).',
        ].join('\n'), { metaMessages: [`Data: ${data} (${size} bytes)`] });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiDecodingDataSizeInvalidError'
        });
    }
}
exports.AbiDecodingDataSizeInvalidError = AbiDecodingDataSizeInvalidError;
class AbiDecodingDataSizeTooSmallError extends base_js_1.BaseError {
    constructor({ data, params, size, }) {
        super([`Data size of ${size} bytes is too small for given parameters.`].join('\n'), {
            metaMessages: [
                `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
                `Data:   ${data} (${size} bytes)`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiDecodingDataSizeTooSmallError'
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = data;
        this.params = params;
        this.size = size;
    }
}
exports.AbiDecodingDataSizeTooSmallError = AbiDecodingDataSizeTooSmallError;
class AbiDecodingZeroDataError extends base_js_1.BaseError {
    constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiDecodingZeroDataError'
        });
    }
}
exports.AbiDecodingZeroDataError = AbiDecodingZeroDataError;
class AbiEncodingArrayLengthMismatchError extends base_js_1.BaseError {
    constructor({ expectedLength, givenLength, type, }) {
        super([
            `ABI encoding array length mismatch for type ${type}.`,
            `Expected length: ${expectedLength}`,
            `Given length: ${givenLength}`,
        ].join('\n'));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiEncodingArrayLengthMismatchError'
        });
    }
}
exports.AbiEncodingArrayLengthMismatchError = AbiEncodingArrayLengthMismatchError;
class AbiEncodingBytesSizeMismatchError extends base_js_1.BaseError {
    constructor({ expectedSize, value }) {
        super(`Size of bytes "${value}" (bytes${(0, size_js_1.size)(value)}) does not match expected size (bytes${expectedSize}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiEncodingBytesSizeMismatchError'
        });
    }
}
exports.AbiEncodingBytesSizeMismatchError = AbiEncodingBytesSizeMismatchError;
class AbiEncodingLengthMismatchError extends base_js_1.BaseError {
    constructor({ expectedLength, givenLength, }) {
        super([
            'ABI encoding params/values length mismatch.',
            `Expected length (params): ${expectedLength}`,
            `Given length (values): ${givenLength}`,
        ].join('\n'));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiEncodingLengthMismatchError'
        });
    }
}
exports.AbiEncodingLengthMismatchError = AbiEncodingLengthMismatchError;
class AbiErrorInputsNotFoundError extends base_js_1.BaseError {
    constructor(errorName, { docsPath }) {
        super([
            `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
            'Cannot encode error result without knowing what the parameter types are.',
            'Make sure you are using the correct ABI and that the inputs exist on it.',
        ].join('\n'), {
            docsPath,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiErrorInputsNotFoundError'
        });
    }
}
exports.AbiErrorInputsNotFoundError = AbiErrorInputsNotFoundError;
class AbiErrorNotFoundError extends base_js_1.BaseError {
    constructor(errorName, { docsPath } = {}) {
        super([
            `Error ${errorName ? `"${errorName}" ` : ''}not found on ABI.`,
            'Make sure you are using the correct ABI and that the error exists on it.',
        ].join('\n'), {
            docsPath,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiErrorNotFoundError'
        });
    }
}
exports.AbiErrorNotFoundError = AbiErrorNotFoundError;
class AbiErrorSignatureNotFoundError extends base_js_1.BaseError {
    constructor(signature, { docsPath }) {
        super([
            `Encoded error signature "${signature}" not found on ABI.`,
            'Make sure you are using the correct ABI and that the error exists on it.',
            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
        ].join('\n'), {
            docsPath,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiErrorSignatureNotFoundError'
        });
        Object.defineProperty(this, "signature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.signature = signature;
    }
}
exports.AbiErrorSignatureNotFoundError = AbiErrorSignatureNotFoundError;
class AbiEventSignatureEmptyTopicsError extends base_js_1.BaseError {
    constructor({ docsPath }) {
        super('Cannot extract event signature from empty topics.', {
            docsPath,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiEventSignatureEmptyTopicsError'
        });
    }
}
exports.AbiEventSignatureEmptyTopicsError = AbiEventSignatureEmptyTopicsError;
class AbiEventSignatureNotFoundError extends base_js_1.BaseError {
    constructor(signature, { docsPath }) {
        super([
            `Encoded event signature "${signature}" not found on ABI.`,
            'Make sure you are using the correct ABI and that the event exists on it.',
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,
        ].join('\n'), {
            docsPath,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiEventSignatureNotFoundError'
        });
    }
}
exports.AbiEventSignatureNotFoundError = AbiEventSignatureNotFoundError;
class AbiEventNotFoundError extends base_js_1.BaseError {
    constructor(eventName, { docsPath } = {}) {
        super([
            `Event ${eventName ? `"${eventName}" ` : ''}not found on ABI.`,
            'Make sure you are using the correct ABI and that the event exists on it.',
        ].join('\n'), {
            docsPath,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiEventNotFoundError'
        });
    }
}
exports.AbiEventNotFoundError = AbiEventNotFoundError;
class AbiFunctionNotFoundError extends base_js_1.BaseError {
    constructor(functionName, { docsPath } = {}) {
        super([
            `Function ${functionName ? `"${functionName}" ` : ''}not found on ABI.`,
            'Make sure you are using the correct ABI and that the function exists on it.',
        ].join('\n'), {
            docsPath,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiFunctionNotFoundError'
        });
    }
}
exports.AbiFunctionNotFoundError = AbiFunctionNotFoundError;
class AbiFunctionOutputsNotFoundError extends base_js_1.BaseError {
    constructor(functionName, { docsPath }) {
        super([
            `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
            'Cannot decode function result without knowing what the parameter types are.',
            'Make sure you are using the correct ABI and that the function exists on it.',
        ].join('\n'), {
            docsPath,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiFunctionOutputsNotFoundError'
        });
    }
}
exports.AbiFunctionOutputsNotFoundError = AbiFunctionOutputsNotFoundError;
class AbiFunctionSignatureNotFoundError extends base_js_1.BaseError {
    constructor(signature, { docsPath }) {
        super([
            `Encoded function signature "${signature}" not found on ABI.`,
            'Make sure you are using the correct ABI and that the function exists on it.',
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,
        ].join('\n'), {
            docsPath,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiFunctionSignatureNotFoundError'
        });
    }
}
exports.AbiFunctionSignatureNotFoundError = AbiFunctionSignatureNotFoundError;
class AbiItemAmbiguityError extends base_js_1.BaseError {
    constructor(x, y) {
        super('Found ambiguous types in overloaded ABI items.', {
            metaMessages: [
                `\`${x.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(x.abiItem)}\`, and`,
                `\`${y.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(y.abiItem)}\``,
                '',
                'These types encode differently and cannot be distinguished at runtime.',
                'Remove one of the ambiguous items in the ABI.',
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiItemAmbiguityError'
        });
    }
}
exports.AbiItemAmbiguityError = AbiItemAmbiguityError;
class BytesSizeMismatchError extends base_js_1.BaseError {
    constructor({ expectedSize, givenSize, }) {
        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BytesSizeMismatchError'
        });
    }
}
exports.BytesSizeMismatchError = BytesSizeMismatchError;
class DecodeLogDataMismatch extends base_js_1.BaseError {
    constructor({ abiItem, data, params, size, }) {
        super([
            `Data size of ${size} bytes is too small for non-indexed event parameters.`,
        ].join('\n'), {
            metaMessages: [
                `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
                `Data:   ${data} (${size} bytes)`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'DecodeLogDataMismatch'
        });
        Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abiItem = abiItem;
        this.data = data;
        this.params = params;
        this.size = size;
    }
}
exports.DecodeLogDataMismatch = DecodeLogDataMismatch;
class DecodeLogTopicsMismatch extends base_js_1.BaseError {
    constructor({ abiItem, param, }) {
        super([
            `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ''} on event "${(0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })}".`,
        ].join('\n'));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'DecodeLogTopicsMismatch'
        });
        Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abiItem = abiItem;
    }
}
exports.DecodeLogTopicsMismatch = DecodeLogTopicsMismatch;
class InvalidAbiEncodingTypeError extends base_js_1.BaseError {
    constructor(type, { docsPath }) {
        super([
            `Type "${type}" is not a valid encoding type.`,
            'Please provide a valid ABI type.',
        ].join('\n'), { docsPath });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiEncodingType'
        });
    }
}
exports.InvalidAbiEncodingTypeError = InvalidAbiEncodingTypeError;
class InvalidAbiDecodingTypeError extends base_js_1.BaseError {
    constructor(type, { docsPath }) {
        super([
            `Type "${type}" is not a valid decoding type.`,
            'Please provide a valid ABI type.',
        ].join('\n'), { docsPath });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiDecodingType'
        });
    }
}
exports.InvalidAbiDecodingTypeError = InvalidAbiDecodingTypeError;
class InvalidArrayError extends base_js_1.BaseError {
    constructor(value) {
        super([`Value "${value}" is not a valid array.`].join('\n'));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidArrayError'
        });
    }
}
exports.InvalidArrayError = InvalidArrayError;
class InvalidDefinitionTypeError extends base_js_1.BaseError {
    constructor(type) {
        super([
            `"${type}" is not a valid definition type.`,
            'Valid types: "function", "event", "error"',
        ].join('\n'));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidDefinitionTypeError'
        });
    }
}
exports.InvalidDefinitionTypeError = InvalidDefinitionTypeError;
class UnsupportedPackedAbiType extends base_js_1.BaseError {
    constructor(type) {
        super(`Type "${type}" is not supported for packed encoding.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnsupportedPackedAbiType'
        });
    }
}
exports.UnsupportedPackedAbiType = UnsupportedPackedAbiType;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/account.js":
/*!******************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/account.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccountNotFoundError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class AccountNotFoundError extends base_js_1.BaseError {
    constructor({ docsPath } = {}) {
        super([
            'Could not find an Account to execute with this Action.',
            'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient.',
        ].join('\n'), {
            docsPath,
            docsSlug: 'account',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AccountNotFoundError'
        });
    }
}
exports.AccountNotFoundError = AccountNotFoundError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/address.js":
/*!******************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/address.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidAddressError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class InvalidAddressError extends base_js_1.BaseError {
    constructor({ address }) {
        super(`Address "${address}" is invalid.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAddressError'
        });
    }
}
exports.InvalidAddressError = InvalidAddressError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/base.js":
/*!***************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/base.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseError = void 0;
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/viem/_cjs/errors/utils.js");
class BaseError extends Error {
    constructor(shortMessage, args = {}) {
        super();
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ViemError'
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0, utils_js_1.getVersion)()
        });
        const details = args.cause instanceof BaseError
            ? args.cause.details
            : args.cause?.message
                ? args.cause.message
                : args.details;
        const docsPath = args.cause instanceof BaseError
            ? args.cause.docsPath || args.docsPath
            : args.docsPath;
        this.message = [
            shortMessage || 'An error occurred.',
            '',
            ...(args.metaMessages ? [...args.metaMessages, ''] : []),
            ...(docsPath
                ? [
                    `Docs: https://viem.sh${docsPath}.html${args.docsSlug ? `#${args.docsSlug}` : ''}`,
                ]
                : []),
            ...(details ? [`Details: ${details}`] : []),
            `Version: ${this.version}`,
        ].join('\n');
        if (args.cause)
            this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
    }
    walk(fn) {
        return walk(this, fn);
    }
}
exports.BaseError = BaseError;
function walk(err, fn) {
    if (fn?.(err))
        return err;
    if (err && typeof err === 'object' && 'cause' in err)
        return walk(err.cause, fn);
    return fn ? null : err;
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/block.js":
/*!****************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/block.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BlockNotFoundError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class BlockNotFoundError extends base_js_1.BaseError {
    constructor({ blockHash, blockNumber, }) {
        let identifier = 'Block';
        if (blockHash)
            identifier = `Block at hash "${blockHash}"`;
        if (blockNumber)
            identifier = `Block at number "${blockNumber}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BlockNotFoundError'
        });
    }
}
exports.BlockNotFoundError = BlockNotFoundError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/ccip.js":
/*!***************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/ccip.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OffchainLookupSenderMismatchError = exports.OffchainLookupResponseMalformedError = exports.OffchainLookupError = void 0;
const stringify_js_1 = __webpack_require__(/*! ../utils/stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/viem/_cjs/errors/utils.js");
class OffchainLookupError extends base_js_1.BaseError {
    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {
        super(cause.shortMessage ||
            'An error occurred while fetching for an offchain result.', {
            cause,
            metaMessages: [
                ...(cause.metaMessages || []),
                cause.metaMessages?.length ? '' : [],
                'Offchain Gateway Call:',
                urls && [
                    '  Gateway URL(s):',
                    ...urls.map((url) => `    ${(0, utils_js_1.getUrl)(url)}`),
                ],
                `  Sender: ${sender}`,
                `  Data: ${data}`,
                `  Callback selector: ${callbackSelector}`,
                `  Extra data: ${extraData}`,
            ].flat(),
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'OffchainLookupError'
        });
    }
}
exports.OffchainLookupError = OffchainLookupError;
class OffchainLookupResponseMalformedError extends base_js_1.BaseError {
    constructor({ result, url }) {
        super('Offchain gateway response is malformed. Response data must be a hex value.', {
            metaMessages: [
                `Gateway URL: ${(0, utils_js_1.getUrl)(url)}`,
                `Response: ${(0, stringify_js_1.stringify)(result)}`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'OffchainLookupResponseMalformedError'
        });
    }
}
exports.OffchainLookupResponseMalformedError = OffchainLookupResponseMalformedError;
class OffchainLookupSenderMismatchError extends base_js_1.BaseError {
    constructor({ sender, to }) {
        super('Reverted sender address does not match target contract address (`to`).', {
            metaMessages: [
                `Contract address: ${to}`,
                `OffchainLookup sender address: ${sender}`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'OffchainLookupSenderMismatchError'
        });
    }
}
exports.OffchainLookupSenderMismatchError = OffchainLookupSenderMismatchError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/chain.js":
/*!****************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/chain.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class ChainDoesNotSupportContract extends base_js_1.BaseError {
    constructor({ blockNumber, chain, contract, }) {
        super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
            metaMessages: [
                'This could be due to any of the following:',
                ...(blockNumber &&
                    contract.blockCreated &&
                    contract.blockCreated > blockNumber
                    ? [
                        `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,
                    ]
                    : [
                        `- The chain does not have the contract "${contract.name}" configured.`,
                    ]),
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ChainDoesNotSupportContract'
        });
    }
}
exports.ChainDoesNotSupportContract = ChainDoesNotSupportContract;
class ChainMismatchError extends base_js_1.BaseError {
    constructor({ chain, currentChainId, }) {
        super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} – ${chain.name}).`, {
            metaMessages: [
                `Current Chain ID:  ${currentChainId}`,
                `Expected Chain ID: ${chain.id} – ${chain.name}`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ChainMismatchError'
        });
    }
}
exports.ChainMismatchError = ChainMismatchError;
class ChainNotFoundError extends base_js_1.BaseError {
    constructor() {
        super([
            'No chain was provided to the request.',
            'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',
        ].join('\n'));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ChainNotFoundError'
        });
    }
}
exports.ChainNotFoundError = ChainNotFoundError;
class ClientChainNotConfiguredError extends base_js_1.BaseError {
    constructor() {
        super('No chain was provided to the Client.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ClientChainNotConfiguredError'
        });
    }
}
exports.ClientChainNotConfiguredError = ClientChainNotConfiguredError;
class InvalidChainIdError extends base_js_1.BaseError {
    constructor({ chainId }) {
        super(`Chain ID "${chainId}" is invalid.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidChainIdError'
        });
    }
}
exports.InvalidChainIdError = InvalidChainIdError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/contract.js":
/*!*******************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/contract.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const solidity_js_1 = __webpack_require__(/*! ../constants/solidity.js */ "../../node_modules/viem/_cjs/constants/solidity.js");
const decodeErrorResult_js_1 = __webpack_require__(/*! ../utils/abi/decodeErrorResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeErrorResult.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ../utils/abi/formatAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const formatAbiItemWithArgs_js_1 = __webpack_require__(/*! ../utils/abi/formatAbiItemWithArgs.js */ "../../node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js");
const getAbiItem_js_1 = __webpack_require__(/*! ../utils/abi/getAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const formatEther_js_1 = __webpack_require__(/*! ../utils/unit/formatEther.js */ "../../node_modules/viem/_cjs/utils/unit/formatEther.js");
const formatGwei_js_1 = __webpack_require__(/*! ../utils/unit/formatGwei.js */ "../../node_modules/viem/_cjs/utils/unit/formatGwei.js");
const abi_js_1 = __webpack_require__(/*! ./abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const transaction_js_1 = __webpack_require__(/*! ./transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/viem/_cjs/errors/utils.js");
class CallExecutionError extends base_js_1.BaseError {
    constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
        const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
            from: account?.address,
            to,
            value: typeof value !== 'undefined' &&
                `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== 'undefined' && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce,
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                'Raw Call Arguments:',
                prettyArgs,
            ].filter(Boolean),
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'CallExecutionError'
        });
        this.cause = cause;
    }
}
exports.CallExecutionError = CallExecutionError;
class ContractFunctionExecutionError extends base_js_1.BaseError {
    constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender, }) {
        const abiItem = (0, getAbiItem_js_1.getAbiItem)({ abi, args, name: functionName });
        const formattedArgs = abiItem
            ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
                abiItem,
                args,
                includeFunctionName: false,
                includeName: false,
            })
            : undefined;
        const functionWithParams = abiItem
            ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })
            : undefined;
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
            address: contractAddress && (0, utils_js_1.getContractAddress)(contractAddress),
            function: functionWithParams,
            args: formattedArgs &&
                formattedArgs !== '()' &&
                `${[...Array(functionName?.length ?? 0).keys()]
                    .map(() => ' ')
                    .join('')}${formattedArgs}`,
            sender,
        });
        super(cause.shortMessage ||
            `An unknown error occurred while executing the contract function "${functionName}".`, {
            cause,
            docsPath,
            metaMessages: [
                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                'Contract Call:',
                prettyArgs,
            ].filter(Boolean),
        });
        Object.defineProperty(this, "abi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "contractAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "formattedArgs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ContractFunctionExecutionError'
        });
        this.abi = abi;
        this.args = args;
        this.cause = cause;
        this.contractAddress = contractAddress;
        this.functionName = functionName;
        this.sender = sender;
    }
}
exports.ContractFunctionExecutionError = ContractFunctionExecutionError;
class ContractFunctionRevertedError extends base_js_1.BaseError {
    constructor({ abi, data, functionName, message, }) {
        let cause;
        let decodedData = undefined;
        let metaMessages;
        let reason;
        if (data && data !== '0x') {
            try {
                decodedData = (0, decodeErrorResult_js_1.decodeErrorResult)({ abi, data });
                const { abiItem, errorName, args: errorArgs } = decodedData;
                if (errorName === 'Error') {
                    reason = errorArgs[0];
                }
                else if (errorName === 'Panic') {
                    const [firstArg] = errorArgs;
                    reason = solidity_js_1.panicReasons[firstArg];
                }
                else {
                    const errorWithParams = abiItem
                        ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })
                        : undefined;
                    const formattedArgs = abiItem && errorArgs
                        ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
                            abiItem,
                            args: errorArgs,
                            includeFunctionName: false,
                            includeName: false,
                        })
                        : undefined;
                    metaMessages = [
                        errorWithParams ? `Error: ${errorWithParams}` : '',
                        formattedArgs && formattedArgs !== '()'
                            ? `       ${[...Array(errorName?.length ?? 0).keys()]
                                .map(() => ' ')
                                .join('')}${formattedArgs}`
                            : '',
                    ];
                }
            }
            catch (err) {
                cause = err;
            }
        }
        else if (message)
            reason = message;
        let signature;
        if (cause instanceof abi_js_1.AbiErrorSignatureNotFoundError) {
            signature = cause.signature;
            metaMessages = [
                `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
                'Make sure you are using the correct ABI and that the error exists on it.',
                `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
            ];
        }
        super((reason && reason !== 'execution reverted') || signature
            ? [
                `The contract function "${functionName}" reverted with the following ${signature ? 'signature' : 'reason'}:`,
                reason || signature,
            ].join('\n')
            : `The contract function "${functionName}" reverted.`, {
            cause,
            metaMessages,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ContractFunctionRevertedError'
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "signature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = decodedData;
        this.reason = reason;
        this.signature = signature;
    }
}
exports.ContractFunctionRevertedError = ContractFunctionRevertedError;
class ContractFunctionZeroDataError extends base_js_1.BaseError {
    constructor({ functionName }) {
        super(`The contract function "${functionName}" returned no data ("0x").`, {
            metaMessages: [
                'This could be due to any of the following:',
                `  - The contract does not have the function "${functionName}",`,
                '  - The parameters passed to the contract function may be invalid, or',
                '  - The address is not a contract.',
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ContractFunctionZeroDataError'
        });
    }
}
exports.ContractFunctionZeroDataError = ContractFunctionZeroDataError;
class RawContractError extends base_js_1.BaseError {
    constructor({ data, message, }) {
        super(message || '');
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 3
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'RawContractError'
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = data;
    }
}
exports.RawContractError = RawContractError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/cursor.js":
/*!*****************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/cursor.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PositionOutOfBoundsError = exports.NegativeOffsetError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class NegativeOffsetError extends base_js_1.BaseError {
    constructor({ offset }) {
        super(`Offset \`${offset}\` cannot be negative.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'NegativeOffsetError'
        });
    }
}
exports.NegativeOffsetError = NegativeOffsetError;
class PositionOutOfBoundsError extends base_js_1.BaseError {
    constructor({ length, position }) {
        super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PositionOutOfBoundsError'
        });
    }
}
exports.PositionOutOfBoundsError = PositionOutOfBoundsError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/data.js":
/*!***************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/data.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class SliceOffsetOutOfBoundsError extends base_js_1.BaseError {
    constructor({ offset, position, size, }) {
        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset "${offset}" is out-of-bounds (size: ${size}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'SliceOffsetOutOfBoundsError'
        });
    }
}
exports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;
class SizeExceedsPaddingSizeError extends base_js_1.BaseError {
    constructor({ size, targetSize, type, }) {
        super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'SizeExceedsPaddingSizeError'
        });
    }
}
exports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/encoding.js":
/*!*******************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/encoding.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SizeOverflowError = exports.OffsetOutOfBoundsError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.InvalidBytesBooleanError = exports.IntegerOutOfRangeError = exports.DataLengthTooShortError = exports.DataLengthTooLongError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class DataLengthTooLongError extends base_js_1.BaseError {
    constructor({ consumed, length }) {
        super(`Consumed bytes (${consumed}) is shorter than data length (${length - 1}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'DataLengthTooLongError'
        });
    }
}
exports.DataLengthTooLongError = DataLengthTooLongError;
class DataLengthTooShortError extends base_js_1.BaseError {
    constructor({ length, dataLength }) {
        super(`Data length (${dataLength - 1}) is shorter than consumed bytes length (${length - 1}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'DataLengthTooShortError'
        });
    }
}
exports.DataLengthTooShortError = DataLengthTooShortError;
class IntegerOutOfRangeError extends base_js_1.BaseError {
    constructor({ max, min, signed, size, value, }) {
        super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'IntegerOutOfRangeError'
        });
    }
}
exports.IntegerOutOfRangeError = IntegerOutOfRangeError;
class InvalidBytesBooleanError extends base_js_1.BaseError {
    constructor(bytes) {
        super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidBytesBooleanError'
        });
    }
}
exports.InvalidBytesBooleanError = InvalidBytesBooleanError;
class InvalidHexBooleanError extends base_js_1.BaseError {
    constructor(hex) {
        super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidHexBooleanError'
        });
    }
}
exports.InvalidHexBooleanError = InvalidHexBooleanError;
class InvalidHexValueError extends base_js_1.BaseError {
    constructor(value) {
        super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidHexValueError'
        });
    }
}
exports.InvalidHexValueError = InvalidHexValueError;
class OffsetOutOfBoundsError extends base_js_1.BaseError {
    constructor({ nextOffset, offset }) {
        super(`Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'OffsetOutOfBoundsError'
        });
    }
}
exports.OffsetOutOfBoundsError = OffsetOutOfBoundsError;
class SizeOverflowError extends base_js_1.BaseError {
    constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'SizeOverflowError'
        });
    }
}
exports.SizeOverflowError = SizeOverflowError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/ens.js":
/*!**************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/ens.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarUriResolutionError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarInvalidMetadataError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class EnsAvatarInvalidMetadataError extends base_js_1.BaseError {
    constructor({ data }) {
        super('Unable to extract image from metadata. The metadata may be malformed or invalid.', {
            metaMessages: [
                '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',
                '',
                `Provided data: ${JSON.stringify(data)}`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'EnsAvatarInvalidMetadataError'
        });
    }
}
exports.EnsAvatarInvalidMetadataError = EnsAvatarInvalidMetadataError;
class EnsAvatarInvalidNftUriError extends base_js_1.BaseError {
    constructor({ reason }) {
        super(`ENS NFT avatar URI is invalid. ${reason}`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'EnsAvatarInvalidNftUriError'
        });
    }
}
exports.EnsAvatarInvalidNftUriError = EnsAvatarInvalidNftUriError;
class EnsAvatarUriResolutionError extends base_js_1.BaseError {
    constructor({ uri }) {
        super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'EnsAvatarUriResolutionError'
        });
    }
}
exports.EnsAvatarUriResolutionError = EnsAvatarUriResolutionError;
class EnsAvatarUnsupportedNamespaceError extends base_js_1.BaseError {
    constructor({ namespace }) {
        super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'EnsAvatarUnsupportedNamespaceError'
        });
    }
}
exports.EnsAvatarUnsupportedNamespaceError = EnsAvatarUnsupportedNamespaceError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/estimateGas.js":
/*!**********************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/estimateGas.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EstimateGasExecutionError = void 0;
const formatEther_js_1 = __webpack_require__(/*! ../utils/unit/formatEther.js */ "../../node_modules/viem/_cjs/utils/unit/formatEther.js");
const formatGwei_js_1 = __webpack_require__(/*! ../utils/unit/formatGwei.js */ "../../node_modules/viem/_cjs/utils/unit/formatGwei.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const transaction_js_1 = __webpack_require__(/*! ./transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
class EstimateGasExecutionError extends base_js_1.BaseError {
    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
            from: account?.address,
            to,
            value: typeof value !== 'undefined' &&
                `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== 'undefined' && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce,
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                'Estimate Gas Arguments:',
                prettyArgs,
            ].filter(Boolean),
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'EstimateGasExecutionError'
        });
        this.cause = cause;
    }
}
exports.EstimateGasExecutionError = EstimateGasExecutionError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/fee.js":
/*!**************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/fee.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = void 0;
const formatGwei_js_1 = __webpack_require__(/*! ../utils/unit/formatGwei.js */ "../../node_modules/viem/_cjs/utils/unit/formatGwei.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class BaseFeeScalarError extends base_js_1.BaseError {
    constructor() {
        super('`baseFeeMultiplier` must be greater than 1.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BaseFeeScalarError'
        });
    }
}
exports.BaseFeeScalarError = BaseFeeScalarError;
class Eip1559FeesNotSupportedError extends base_js_1.BaseError {
    constructor() {
        super('Chain does not support EIP-1559 fees.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Eip1559FeesNotSupportedError'
        });
    }
}
exports.Eip1559FeesNotSupportedError = Eip1559FeesNotSupportedError;
class MaxFeePerGasTooLowError extends base_js_1.BaseError {
    constructor({ maxPriorityFeePerGas }) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'MaxFeePerGasTooLowError'
        });
    }
}
exports.MaxFeePerGasTooLowError = MaxFeePerGasTooLowError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/log.js":
/*!**************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/log.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterTypeNotSupportedError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class FilterTypeNotSupportedError extends base_js_1.BaseError {
    constructor(type) {
        super(`Filter type "${type}" is not supported.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'FilterTypeNotSupportedError'
        });
    }
}
exports.FilterTypeNotSupportedError = FilterTypeNotSupportedError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/node.js":
/*!***************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/node.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnknownNodeError = exports.TipAboveFeeCapError = exports.TransactionTypeNotSupportedError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.NonceMaxValueError = exports.NonceTooLowError = exports.NonceTooHighError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = void 0;
const formatGwei_js_1 = __webpack_require__(/*! ../utils/unit/formatGwei.js */ "../../node_modules/viem/_cjs/utils/unit/formatGwei.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class ExecutionRevertedError extends base_js_1.BaseError {
    constructor({ cause, message, } = {}) {
        const reason = message
            ?.replace('execution reverted: ', '')
            ?.replace('execution reverted', '');
        super(`Execution reverted ${reason ? `with reason: ${reason}` : 'for an unknown reason'}.`, {
            cause,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ExecutionRevertedError'
        });
    }
}
Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /execution reverted/
});
exports.ExecutionRevertedError = ExecutionRevertedError;
class FeeCapTooHighError extends base_js_1.BaseError {
    constructor({ cause, maxFeePerGas, } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'FeeCapTooHigh'
        });
    }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
exports.FeeCapTooHighError = FeeCapTooHighError;
class FeeCapTooLowError extends base_js_1.BaseError {
    constructor({ cause, maxFeePerGas, } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)}` : ''} gwei) cannot be lower than the block base fee.`, {
            cause,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'FeeCapTooLow'
        });
    }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
exports.FeeCapTooLowError = FeeCapTooLowError;
class NonceTooHighError extends base_js_1.BaseError {
    constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is higher than the next one expected.`, { cause });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'NonceTooHighError'
        });
    }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too high/
});
exports.NonceTooHighError = NonceTooHighError;
class NonceTooLowError extends base_js_1.BaseError {
    constructor({ cause, nonce } = {}) {
        super([
            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is lower than the current nonce of the account.`,
            'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',
        ].join('\n'), { cause });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'NonceTooLowError'
        });
    }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too low|transaction already imported|already known/
});
exports.NonceTooLowError = NonceTooLowError;
class NonceMaxValueError extends base_js_1.BaseError {
    constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}exceeds the maximum allowed nonce.`, { cause });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'NonceMaxValueError'
        });
    }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce has max value/
});
exports.NonceMaxValueError = NonceMaxValueError;
class InsufficientFundsError extends base_js_1.BaseError {
    constructor({ cause } = {}) {
        super([
            'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',
        ].join('\n'), {
            cause,
            metaMessages: [
                'This error could arise when the account does not have enough funds to:',
                ' - pay for the total gas fee,',
                ' - pay for the value to send.',
                ' ',
                'The cost of the transaction is calculated as `gas * gas fee + value`, where:',
                ' - `gas` is the amount of gas needed for transaction to execute,',
                ' - `gas fee` is the gas fee,',
                ' - `value` is the amount of ether to send to the recipient.',
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InsufficientFundsError'
        });
    }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /insufficient funds/
});
exports.InsufficientFundsError = InsufficientFundsError;
class IntrinsicGasTooHighError extends base_js_1.BaseError {
    constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction exceeds the limit allowed for the block.`, {
            cause,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'IntrinsicGasTooHighError'
        });
    }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too high|gas limit reached/
});
exports.IntrinsicGasTooHighError = IntrinsicGasTooHighError;
class IntrinsicGasTooLowError extends base_js_1.BaseError {
    constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction is too low.`, {
            cause,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'IntrinsicGasTooLowError'
        });
    }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too low/
});
exports.IntrinsicGasTooLowError = IntrinsicGasTooLowError;
class TransactionTypeNotSupportedError extends base_js_1.BaseError {
    constructor({ cause }) {
        super('The transaction type is not supported for this chain.', {
            cause,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'TransactionTypeNotSupportedError'
        });
    }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /transaction type not valid/
});
exports.TransactionTypeNotSupportedError = TransactionTypeNotSupportedError;
class TipAboveFeeCapError extends base_js_1.BaseError {
    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas, } = {}) {
        super([
            `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas
                ? ` = ${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`
                : ''}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ''}).`,
        ].join('\n'), {
            cause,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'TipAboveFeeCapError'
        });
    }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
exports.TipAboveFeeCapError = TipAboveFeeCapError;
class UnknownNodeError extends base_js_1.BaseError {
    constructor({ cause }) {
        super(`An error occurred while executing: ${cause?.shortMessage}`, {
            cause,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownNodeError'
        });
    }
}
exports.UnknownNodeError = UnknownNodeError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/request.js":
/*!******************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/request.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutError = exports.RpcRequestError = exports.WebSocketRequestError = exports.HttpRequestError = void 0;
const stringify_js_1 = __webpack_require__(/*! ../utils/stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/viem/_cjs/errors/utils.js");
class HttpRequestError extends base_js_1.BaseError {
    constructor({ body, details, headers, status, url, }) {
        super('HTTP request failed.', {
            details,
            metaMessages: [
                status && `Status: ${status}`,
                `URL: ${(0, utils_js_1.getUrl)(url)}`,
                body && `Request body: ${(0, stringify_js_1.stringify)(body)}`,
            ].filter(Boolean),
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'HttpRequestError'
        });
        Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.body = body;
        this.headers = headers;
        this.status = status;
        this.url = url;
    }
}
exports.HttpRequestError = HttpRequestError;
class WebSocketRequestError extends base_js_1.BaseError {
    constructor({ body, details, url, }) {
        super('WebSocket request failed.', {
            details,
            metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'WebSocketRequestError'
        });
    }
}
exports.WebSocketRequestError = WebSocketRequestError;
class RpcRequestError extends base_js_1.BaseError {
    constructor({ body, error, url, }) {
        super('RPC Request failed.', {
            cause: error,
            details: error.message,
            metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'RpcRequestError'
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.code = error.code;
    }
}
exports.RpcRequestError = RpcRequestError;
class TimeoutError extends base_js_1.BaseError {
    constructor({ body, url, }) {
        super('The request took too long to respond.', {
            details: 'The request timed out.',
            metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'TimeoutError'
        });
    }
}
exports.TimeoutError = TimeoutError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/rpc.js":
/*!**************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/rpc.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnknownRpcError = exports.SwitchChainError = exports.ChainDisconnectedError = exports.ProviderDisconnectedError = exports.UnsupportedProviderMethodError = exports.UnauthorizedProviderError = exports.UserRejectedRequestError = exports.JsonRpcVersionUnsupportedError = exports.LimitExceededRpcError = exports.MethodNotSupportedRpcError = exports.TransactionRejectedRpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.InvalidParamsRpcError = exports.MethodNotFoundRpcError = exports.InvalidRequestRpcError = exports.ParseRpcError = exports.ProviderRpcError = exports.RpcError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const request_js_1 = __webpack_require__(/*! ./request.js */ "../../node_modules/viem/_cjs/errors/request.js");
const unknownErrorCode = -1;
class RpcError extends base_js_1.BaseError {
    constructor(cause, { code, docsPath, metaMessages, shortMessage }) {
        super(shortMessage, {
            cause,
            docsPath,
            metaMessages: metaMessages || cause?.metaMessages,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'RpcError'
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = cause.name;
        this.code = (cause instanceof request_js_1.RpcRequestError ? cause.code : code ?? unknownErrorCode);
    }
}
exports.RpcError = RpcError;
class ProviderRpcError extends RpcError {
    constructor(cause, options) {
        super(cause, options);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ProviderRpcError'
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = options.data;
    }
}
exports.ProviderRpcError = ProviderRpcError;
class ParseRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: ParseRpcError.code,
            shortMessage: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ParseRpcError'
        });
    }
}
Object.defineProperty(ParseRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32700
});
exports.ParseRpcError = ParseRpcError;
class InvalidRequestRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: InvalidRequestRpcError.code,
            shortMessage: 'JSON is not a valid request object.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidRequestRpcError'
        });
    }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32600
});
exports.InvalidRequestRpcError = InvalidRequestRpcError;
class MethodNotFoundRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: MethodNotFoundRpcError.code,
            shortMessage: 'The method does not exist / is not available.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'MethodNotFoundRpcError'
        });
    }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32601
});
exports.MethodNotFoundRpcError = MethodNotFoundRpcError;
class InvalidParamsRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: InvalidParamsRpcError.code,
            shortMessage: [
                'Invalid parameters were provided to the RPC method.',
                'Double check you have provided the correct parameters.',
            ].join('\n'),
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidParamsRpcError'
        });
    }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32602
});
exports.InvalidParamsRpcError = InvalidParamsRpcError;
class InternalRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: InternalRpcError.code,
            shortMessage: 'An internal error was received.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InternalRpcError'
        });
    }
}
Object.defineProperty(InternalRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32603
});
exports.InternalRpcError = InternalRpcError;
class InvalidInputRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: InvalidInputRpcError.code,
            shortMessage: [
                'Missing or invalid parameters.',
                'Double check you have provided the correct parameters.',
            ].join('\n'),
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidInputRpcError'
        });
    }
}
Object.defineProperty(InvalidInputRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32000
});
exports.InvalidInputRpcError = InvalidInputRpcError;
class ResourceNotFoundRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: ResourceNotFoundRpcError.code,
            shortMessage: 'Requested resource not found.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ResourceNotFoundRpcError'
        });
    }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32001
});
exports.ResourceNotFoundRpcError = ResourceNotFoundRpcError;
class ResourceUnavailableRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: ResourceUnavailableRpcError.code,
            shortMessage: 'Requested resource not available.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ResourceUnavailableRpcError'
        });
    }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32002
});
exports.ResourceUnavailableRpcError = ResourceUnavailableRpcError;
class TransactionRejectedRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: TransactionRejectedRpcError.code,
            shortMessage: 'Transaction creation failed.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'TransactionRejectedRpcError'
        });
    }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32003
});
exports.TransactionRejectedRpcError = TransactionRejectedRpcError;
class MethodNotSupportedRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: MethodNotSupportedRpcError.code,
            shortMessage: 'Method is not implemented.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'MethodNotSupportedRpcError'
        });
    }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32004
});
exports.MethodNotSupportedRpcError = MethodNotSupportedRpcError;
class LimitExceededRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: LimitExceededRpcError.code,
            shortMessage: 'Request exceeds defined limit.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'LimitExceededRpcError'
        });
    }
}
Object.defineProperty(LimitExceededRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32005
});
exports.LimitExceededRpcError = LimitExceededRpcError;
class JsonRpcVersionUnsupportedError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: JsonRpcVersionUnsupportedError.code,
            shortMessage: 'Version of JSON-RPC protocol is not supported.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'JsonRpcVersionUnsupportedError'
        });
    }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32006
});
exports.JsonRpcVersionUnsupportedError = JsonRpcVersionUnsupportedError;
class UserRejectedRequestError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: UserRejectedRequestError.code,
            shortMessage: 'User rejected the request.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UserRejectedRequestError'
        });
    }
}
Object.defineProperty(UserRejectedRequestError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4001
});
exports.UserRejectedRequestError = UserRejectedRequestError;
class UnauthorizedProviderError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: UnauthorizedProviderError.code,
            shortMessage: 'The requested method and/or account has not been authorized by the user.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnauthorizedProviderError'
        });
    }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4100
});
exports.UnauthorizedProviderError = UnauthorizedProviderError;
class UnsupportedProviderMethodError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: UnsupportedProviderMethodError.code,
            shortMessage: 'The Provider does not support the requested method.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnsupportedProviderMethodError'
        });
    }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4200
});
exports.UnsupportedProviderMethodError = UnsupportedProviderMethodError;
class ProviderDisconnectedError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: ProviderDisconnectedError.code,
            shortMessage: 'The Provider is disconnected from all chains.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ProviderDisconnectedError'
        });
    }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4900
});
exports.ProviderDisconnectedError = ProviderDisconnectedError;
class ChainDisconnectedError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: ChainDisconnectedError.code,
            shortMessage: 'The Provider is not connected to the requested chain.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ChainDisconnectedError'
        });
    }
}
Object.defineProperty(ChainDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4901
});
exports.ChainDisconnectedError = ChainDisconnectedError;
class SwitchChainError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: SwitchChainError.code,
            shortMessage: 'An error occurred when attempting to switch chain.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'SwitchChainError'
        });
    }
}
Object.defineProperty(SwitchChainError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4902
});
exports.SwitchChainError = SwitchChainError;
class UnknownRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            shortMessage: 'An unknown RPC error occurred.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownRpcError'
        });
    }
}
exports.UnknownRpcError = UnknownRpcError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/transaction.js":
/*!**********************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/transaction.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = exports.prettyPrint = void 0;
const formatEther_js_1 = __webpack_require__(/*! ../utils/unit/formatEther.js */ "../../node_modules/viem/_cjs/utils/unit/formatEther.js");
const formatGwei_js_1 = __webpack_require__(/*! ../utils/unit/formatGwei.js */ "../../node_modules/viem/_cjs/utils/unit/formatGwei.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
function prettyPrint(args) {
    const entries = Object.entries(args)
        .map(([key, value]) => {
        if (value === undefined || value === false)
            return null;
        return [key, value];
    })
        .filter(Boolean);
    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
    return entries
        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)
        .join('\n');
}
exports.prettyPrint = prettyPrint;
class FeeConflictError extends base_js_1.BaseError {
    constructor() {
        super([
            'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',
            'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',
        ].join('\n'));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'FeeConflictError'
        });
    }
}
exports.FeeConflictError = FeeConflictError;
class InvalidLegacyVError extends base_js_1.BaseError {
    constructor({ v }) {
        super(`Invalid \`v\` value "${v}". Expected 27 or 28.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidLegacyVError'
        });
    }
}
exports.InvalidLegacyVError = InvalidLegacyVError;
class InvalidSerializableTransactionError extends base_js_1.BaseError {
    constructor({ transaction }) {
        super('Cannot infer a transaction type from provided transaction.', {
            metaMessages: [
                'Provided Transaction:',
                '{',
                prettyPrint(transaction),
                '}',
                '',
                'To infer the type, either provide:',
                '- a `type` to the Transaction, or',
                '- an EIP-1559 Transaction with `maxFeePerGas`, or',
                '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',
                '- a Legacy Transaction with `gasPrice`',
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidSerializableTransactionError'
        });
    }
}
exports.InvalidSerializableTransactionError = InvalidSerializableTransactionError;
class InvalidSerializedTransactionTypeError extends base_js_1.BaseError {
    constructor({ serializedType }) {
        super(`Serialized transaction type "${serializedType}" is invalid.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidSerializedTransactionType'
        });
        Object.defineProperty(this, "serializedType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.serializedType = serializedType;
    }
}
exports.InvalidSerializedTransactionTypeError = InvalidSerializedTransactionTypeError;
class InvalidSerializedTransactionError extends base_js_1.BaseError {
    constructor({ attributes, serializedTransaction, type, }) {
        const missing = Object.entries(attributes)
            .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))
            .filter(Boolean);
        super(`Invalid serialized transaction of type "${type}" was provided.`, {
            metaMessages: [
                `Serialized Transaction: "${serializedTransaction}"`,
                missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',
            ].filter(Boolean),
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidSerializedTransactionError'
        });
        Object.defineProperty(this, "serializedTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.serializedTransaction = serializedTransaction;
        this.type = type;
    }
}
exports.InvalidSerializedTransactionError = InvalidSerializedTransactionError;
class InvalidStorageKeySizeError extends base_js_1.BaseError {
    constructor({ storageKey }) {
        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidStorageKeySizeError'
        });
    }
}
exports.InvalidStorageKeySizeError = InvalidStorageKeySizeError;
class TransactionExecutionError extends base_js_1.BaseError {
    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
        const prettyArgs = prettyPrint({
            chain: chain && `${chain?.name} (id: ${chain?.id})`,
            from: account?.address,
            to,
            value: typeof value !== 'undefined' &&
                `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== 'undefined' && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce,
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                'Request Arguments:',
                prettyArgs,
            ].filter(Boolean),
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'TransactionExecutionError'
        });
        this.cause = cause;
    }
}
exports.TransactionExecutionError = TransactionExecutionError;
class TransactionNotFoundError extends base_js_1.BaseError {
    constructor({ blockHash, blockNumber, blockTag, hash, index, }) {
        let identifier = 'Transaction';
        if (blockTag && index !== undefined)
            identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
        if (blockHash && index !== undefined)
            identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
        if (blockNumber && index !== undefined)
            identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
        if (hash)
            identifier = `Transaction with hash "${hash}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'TransactionNotFoundError'
        });
    }
}
exports.TransactionNotFoundError = TransactionNotFoundError;
class TransactionReceiptNotFoundError extends base_js_1.BaseError {
    constructor({ hash }) {
        super(`Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'TransactionReceiptNotFoundError'
        });
    }
}
exports.TransactionReceiptNotFoundError = TransactionReceiptNotFoundError;
class WaitForTransactionReceiptTimeoutError extends base_js_1.BaseError {
    constructor({ hash }) {
        super(`Timed out while waiting for transaction with hash "${hash}" to be confirmed.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'WaitForTransactionReceiptTimeoutError'
        });
    }
}
exports.WaitForTransactionReceiptTimeoutError = WaitForTransactionReceiptTimeoutError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/transport.js":
/*!********************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/transport.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UrlRequiredError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/viem/_cjs/errors/base.js");
class UrlRequiredError extends base_js_1.BaseError {
    constructor() {
        super('No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.', {
            docsPath: '/docs/clients/intro',
        });
    }
}
exports.UrlRequiredError = UrlRequiredError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/utils.js":
/*!****************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getVersion = exports.getUrl = exports.getContractAddress = void 0;
const version_js_1 = __webpack_require__(/*! ./version.js */ "../../node_modules/viem/_cjs/errors/version.js");
const getContractAddress = (address) => address;
exports.getContractAddress = getContractAddress;
const getUrl = (url) => url;
exports.getUrl = getUrl;
const getVersion = () => `viem@${version_js_1.version}`;
exports.getVersion = getVersion;


/***/ }),

/***/ "../../node_modules/viem/_cjs/errors/version.js":
/*!******************************************************!*\
  !*** ../../node_modules/viem/_cjs/errors/version.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = '1.21.3';


/***/ }),

/***/ "../../node_modules/viem/_cjs/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/viem/_cjs/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = exports.weiUnits = exports.gweiUnits = exports.etherUnits = exports.zeroAddress = exports.multicall3Abi = exports.webSocket = exports.createWalletClient = exports.createTransport = exports.walletActions = exports.testActions = exports.publicActions = exports.createTestClient = exports.createPublicClient = exports.http = exports.fallback = exports.custom = exports.createClient = exports.getContract = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.UnknownSignatureError = exports.UnknownTypeError = exports.SolidityProtectedKeywordError = exports.InvalidStructSignatureError = exports.InvalidSignatureError = exports.InvalidParenthesisError = exports.InvalidParameterError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.InvalidAbiItemError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = exports.CircularReferenceError = void 0;
exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = void 0;
exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiEventNotFoundError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingBytesSizeMismatchError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeTooSmallError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = exports.presignMessagePrefix = exports.zeroHash = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = void 0;
exports.InvalidHexBooleanError = exports.IntegerOutOfRangeError = exports.InvalidBytesBooleanError = exports.DataLengthTooShortError = exports.DataLengthTooLongError = exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = exports.UserRejectedRequestError = exports.UnsupportedProviderMethodError = exports.UnknownRpcError = exports.UnauthorizedProviderError = exports.TransactionRejectedRpcError = exports.SwitchChainError = exports.RpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.ProviderRpcError = exports.ProviderDisconnectedError = exports.ParseRpcError = exports.MethodNotSupportedRpcError = exports.MethodNotFoundRpcError = exports.LimitExceededRpcError = exports.JsonRpcVersionUnsupportedError = exports.InvalidRequestRpcError = exports.InvalidParamsRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.ChainDisconnectedError = exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = exports.BlockNotFoundError = exports.BaseError = exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiEncodingTypeError = exports.InvalidAbiDecodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiFunctionSignatureNotFoundError = void 0;
exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeDeployData = exports.decodeAbiParameters = exports.formatLog = exports.formatBlock = exports.defineBlock = exports.namehash = exports.labelhash = exports.UrlRequiredError = exports.SliceOffsetOutOfBoundsError = exports.SizeExceedsPaddingSizeError = exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = exports.InvalidAddressError = exports.WebSocketRequestError = exports.TimeoutError = exports.RpcRequestError = exports.HttpRequestError = exports.FilterTypeNotSupportedError = exports.UnknownNodeError = exports.TransactionTypeNotSupportedError = exports.TipAboveFeeCapError = exports.NonceTooLowError = exports.NonceTooHighError = exports.NonceMaxValueError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = exports.EstimateGasExecutionError = exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarUriResolutionError = exports.SizeOverflowError = exports.OffsetOutOfBoundsError = exports.InvalidHexValueError = void 0;
exports.toHex = exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toBytes = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.verifyTypedData = exports.verifyMessage = exports.toRlp = exports.hexToRlp = exports.bytesToRlp = exports.signatureToHex = exports.compactSignatureToHex = exports.signatureToCompactSignature = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hexToSignature = exports.hexToCompactSignature = exports.compactSignatureToSignature = exports.hashTypedData = exports.hashDomain = exports.getTransactionType = exports.getSerializedTransactionType = exports.getCreateAddress = exports.getCreate2Address = exports.getContractAddress = exports.getAbiItem = exports.rpcTransactionType = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.formatTransactionReceipt = exports.defineTransactionReceipt = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = void 0;
exports.parseUnits = exports.parseTransaction = exports.parseGwei = exports.parseEther = exports.padHex = exports.padBytes = exports.pad = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.isHex = exports.isHash = exports.isBytes = exports.isAddressEqual = exports.isAddress = exports.hashMessage = exports.getFunctionSignature = exports.getFunctionSelector = exports.getEventSignature = exports.getEventSelector = exports.getContractError = exports.getAddress = exports.checksumAddress = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.encodePacked = exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.concatHex = exports.concatBytes = exports.concat = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.bytesToBigInt = void 0;
exports.getTypesForEIP712Domain = exports.domainSeparator = exports.validateTypedData = exports.trim = exports.stringify = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.serializeTransaction = exports.serializeAccessList = void 0;
var abitype_1 = __webpack_require__(/*! abitype */ "../../node_modules/abitype/dist/cjs/index.js");
Object.defineProperty(exports, "CircularReferenceError", ({ enumerable: true, get: function () { return abitype_1.CircularReferenceError; } }));
Object.defineProperty(exports, "InvalidAbiParameterError", ({ enumerable: true, get: function () { return abitype_1.InvalidAbiParameterError; } }));
Object.defineProperty(exports, "InvalidAbiParametersError", ({ enumerable: true, get: function () { return abitype_1.InvalidAbiParametersError; } }));
Object.defineProperty(exports, "InvalidAbiItemError", ({ enumerable: true, get: function () { return abitype_1.InvalidAbiItemError; } }));
Object.defineProperty(exports, "InvalidAbiTypeParameterError", ({ enumerable: true, get: function () { return abitype_1.InvalidAbiTypeParameterError; } }));
Object.defineProperty(exports, "InvalidFunctionModifierError", ({ enumerable: true, get: function () { return abitype_1.InvalidFunctionModifierError; } }));
Object.defineProperty(exports, "InvalidModifierError", ({ enumerable: true, get: function () { return abitype_1.InvalidModifierError; } }));
Object.defineProperty(exports, "InvalidParameterError", ({ enumerable: true, get: function () { return abitype_1.InvalidParameterError; } }));
Object.defineProperty(exports, "InvalidParenthesisError", ({ enumerable: true, get: function () { return abitype_1.InvalidParenthesisError; } }));
Object.defineProperty(exports, "InvalidSignatureError", ({ enumerable: true, get: function () { return abitype_1.InvalidSignatureError; } }));
Object.defineProperty(exports, "InvalidStructSignatureError", ({ enumerable: true, get: function () { return abitype_1.InvalidStructSignatureError; } }));
Object.defineProperty(exports, "SolidityProtectedKeywordError", ({ enumerable: true, get: function () { return abitype_1.SolidityProtectedKeywordError; } }));
Object.defineProperty(exports, "UnknownTypeError", ({ enumerable: true, get: function () { return abitype_1.UnknownTypeError; } }));
Object.defineProperty(exports, "UnknownSignatureError", ({ enumerable: true, get: function () { return abitype_1.UnknownSignatureError; } }));
Object.defineProperty(exports, "parseAbi", ({ enumerable: true, get: function () { return abitype_1.parseAbi; } }));
Object.defineProperty(exports, "parseAbiItem", ({ enumerable: true, get: function () { return abitype_1.parseAbiItem; } }));
Object.defineProperty(exports, "parseAbiParameter", ({ enumerable: true, get: function () { return abitype_1.parseAbiParameter; } }));
Object.defineProperty(exports, "parseAbiParameters", ({ enumerable: true, get: function () { return abitype_1.parseAbiParameters; } }));
var getContract_js_1 = __webpack_require__(/*! ./actions/getContract.js */ "../../node_modules/viem/_cjs/actions/getContract.js");
Object.defineProperty(exports, "getContract", ({ enumerable: true, get: function () { return getContract_js_1.getContract; } }));
var createClient_js_1 = __webpack_require__(/*! ./clients/createClient.js */ "../../node_modules/viem/_cjs/clients/createClient.js");
Object.defineProperty(exports, "createClient", ({ enumerable: true, get: function () { return createClient_js_1.createClient; } }));
var custom_js_1 = __webpack_require__(/*! ./clients/transports/custom.js */ "../../node_modules/viem/_cjs/clients/transports/custom.js");
Object.defineProperty(exports, "custom", ({ enumerable: true, get: function () { return custom_js_1.custom; } }));
var fallback_js_1 = __webpack_require__(/*! ./clients/transports/fallback.js */ "../../node_modules/viem/_cjs/clients/transports/fallback.js");
Object.defineProperty(exports, "fallback", ({ enumerable: true, get: function () { return fallback_js_1.fallback; } }));
var http_js_1 = __webpack_require__(/*! ./clients/transports/http.js */ "../../node_modules/viem/_cjs/clients/transports/http.js");
Object.defineProperty(exports, "http", ({ enumerable: true, get: function () { return http_js_1.http; } }));
var createPublicClient_js_1 = __webpack_require__(/*! ./clients/createPublicClient.js */ "../../node_modules/viem/_cjs/clients/createPublicClient.js");
Object.defineProperty(exports, "createPublicClient", ({ enumerable: true, get: function () { return createPublicClient_js_1.createPublicClient; } }));
var createTestClient_js_1 = __webpack_require__(/*! ./clients/createTestClient.js */ "../../node_modules/viem/_cjs/clients/createTestClient.js");
Object.defineProperty(exports, "createTestClient", ({ enumerable: true, get: function () { return createTestClient_js_1.createTestClient; } }));
var public_js_1 = __webpack_require__(/*! ./clients/decorators/public.js */ "../../node_modules/viem/_cjs/clients/decorators/public.js");
Object.defineProperty(exports, "publicActions", ({ enumerable: true, get: function () { return public_js_1.publicActions; } }));
var test_js_1 = __webpack_require__(/*! ./clients/decorators/test.js */ "../../node_modules/viem/_cjs/clients/decorators/test.js");
Object.defineProperty(exports, "testActions", ({ enumerable: true, get: function () { return test_js_1.testActions; } }));
var wallet_js_1 = __webpack_require__(/*! ./clients/decorators/wallet.js */ "../../node_modules/viem/_cjs/clients/decorators/wallet.js");
Object.defineProperty(exports, "walletActions", ({ enumerable: true, get: function () { return wallet_js_1.walletActions; } }));
var createTransport_js_1 = __webpack_require__(/*! ./clients/transports/createTransport.js */ "../../node_modules/viem/_cjs/clients/transports/createTransport.js");
Object.defineProperty(exports, "createTransport", ({ enumerable: true, get: function () { return createTransport_js_1.createTransport; } }));
var createWalletClient_js_1 = __webpack_require__(/*! ./clients/createWalletClient.js */ "../../node_modules/viem/_cjs/clients/createWalletClient.js");
Object.defineProperty(exports, "createWalletClient", ({ enumerable: true, get: function () { return createWalletClient_js_1.createWalletClient; } }));
var webSocket_js_1 = __webpack_require__(/*! ./clients/transports/webSocket.js */ "../../node_modules/viem/_cjs/clients/transports/webSocket.js");
Object.defineProperty(exports, "webSocket", ({ enumerable: true, get: function () { return webSocket_js_1.webSocket; } }));
var abis_js_1 = __webpack_require__(/*! ./constants/abis.js */ "../../node_modules/viem/_cjs/constants/abis.js");
Object.defineProperty(exports, "multicall3Abi", ({ enumerable: true, get: function () { return abis_js_1.multicall3Abi; } }));
var address_js_1 = __webpack_require__(/*! ./constants/address.js */ "../../node_modules/viem/_cjs/constants/address.js");
Object.defineProperty(exports, "zeroAddress", ({ enumerable: true, get: function () { return address_js_1.zeroAddress; } }));
var unit_js_1 = __webpack_require__(/*! ./constants/unit.js */ "../../node_modules/viem/_cjs/constants/unit.js");
Object.defineProperty(exports, "etherUnits", ({ enumerable: true, get: function () { return unit_js_1.etherUnits; } }));
Object.defineProperty(exports, "gweiUnits", ({ enumerable: true, get: function () { return unit_js_1.gweiUnits; } }));
Object.defineProperty(exports, "weiUnits", ({ enumerable: true, get: function () { return unit_js_1.weiUnits; } }));
var number_js_1 = __webpack_require__(/*! ./constants/number.js */ "../../node_modules/viem/_cjs/constants/number.js");
Object.defineProperty(exports, "maxInt8", ({ enumerable: true, get: function () { return number_js_1.maxInt8; } }));
Object.defineProperty(exports, "maxInt16", ({ enumerable: true, get: function () { return number_js_1.maxInt16; } }));
Object.defineProperty(exports, "maxInt24", ({ enumerable: true, get: function () { return number_js_1.maxInt24; } }));
Object.defineProperty(exports, "maxInt32", ({ enumerable: true, get: function () { return number_js_1.maxInt32; } }));
Object.defineProperty(exports, "maxInt40", ({ enumerable: true, get: function () { return number_js_1.maxInt40; } }));
Object.defineProperty(exports, "maxInt48", ({ enumerable: true, get: function () { return number_js_1.maxInt48; } }));
Object.defineProperty(exports, "maxInt56", ({ enumerable: true, get: function () { return number_js_1.maxInt56; } }));
Object.defineProperty(exports, "maxInt64", ({ enumerable: true, get: function () { return number_js_1.maxInt64; } }));
Object.defineProperty(exports, "maxInt72", ({ enumerable: true, get: function () { return number_js_1.maxInt72; } }));
Object.defineProperty(exports, "maxInt80", ({ enumerable: true, get: function () { return number_js_1.maxInt80; } }));
Object.defineProperty(exports, "maxInt88", ({ enumerable: true, get: function () { return number_js_1.maxInt88; } }));
Object.defineProperty(exports, "maxInt96", ({ enumerable: true, get: function () { return number_js_1.maxInt96; } }));
Object.defineProperty(exports, "maxInt104", ({ enumerable: true, get: function () { return number_js_1.maxInt104; } }));
Object.defineProperty(exports, "maxInt112", ({ enumerable: true, get: function () { return number_js_1.maxInt112; } }));
Object.defineProperty(exports, "maxInt120", ({ enumerable: true, get: function () { return number_js_1.maxInt120; } }));
Object.defineProperty(exports, "maxInt128", ({ enumerable: true, get: function () { return number_js_1.maxInt128; } }));
Object.defineProperty(exports, "maxInt136", ({ enumerable: true, get: function () { return number_js_1.maxInt136; } }));
Object.defineProperty(exports, "maxInt144", ({ enumerable: true, get: function () { return number_js_1.maxInt144; } }));
Object.defineProperty(exports, "maxInt152", ({ enumerable: true, get: function () { return number_js_1.maxInt152; } }));
Object.defineProperty(exports, "maxInt160", ({ enumerable: true, get: function () { return number_js_1.maxInt160; } }));
Object.defineProperty(exports, "maxInt168", ({ enumerable: true, get: function () { return number_js_1.maxInt168; } }));
Object.defineProperty(exports, "maxInt176", ({ enumerable: true, get: function () { return number_js_1.maxInt176; } }));
Object.defineProperty(exports, "maxInt184", ({ enumerable: true, get: function () { return number_js_1.maxInt184; } }));
Object.defineProperty(exports, "maxInt192", ({ enumerable: true, get: function () { return number_js_1.maxInt192; } }));
Object.defineProperty(exports, "maxInt200", ({ enumerable: true, get: function () { return number_js_1.maxInt200; } }));
Object.defineProperty(exports, "maxInt208", ({ enumerable: true, get: function () { return number_js_1.maxInt208; } }));
Object.defineProperty(exports, "maxInt216", ({ enumerable: true, get: function () { return number_js_1.maxInt216; } }));
Object.defineProperty(exports, "maxInt224", ({ enumerable: true, get: function () { return number_js_1.maxInt224; } }));
Object.defineProperty(exports, "maxInt232", ({ enumerable: true, get: function () { return number_js_1.maxInt232; } }));
Object.defineProperty(exports, "maxInt240", ({ enumerable: true, get: function () { return number_js_1.maxInt240; } }));
Object.defineProperty(exports, "maxInt248", ({ enumerable: true, get: function () { return number_js_1.maxInt248; } }));
Object.defineProperty(exports, "maxInt256", ({ enumerable: true, get: function () { return number_js_1.maxInt256; } }));
Object.defineProperty(exports, "maxUint8", ({ enumerable: true, get: function () { return number_js_1.maxUint8; } }));
Object.defineProperty(exports, "maxUint16", ({ enumerable: true, get: function () { return number_js_1.maxUint16; } }));
Object.defineProperty(exports, "maxUint24", ({ enumerable: true, get: function () { return number_js_1.maxUint24; } }));
Object.defineProperty(exports, "maxUint32", ({ enumerable: true, get: function () { return number_js_1.maxUint32; } }));
Object.defineProperty(exports, "maxUint40", ({ enumerable: true, get: function () { return number_js_1.maxUint40; } }));
Object.defineProperty(exports, "maxUint48", ({ enumerable: true, get: function () { return number_js_1.maxUint48; } }));
Object.defineProperty(exports, "maxUint56", ({ enumerable: true, get: function () { return number_js_1.maxUint56; } }));
Object.defineProperty(exports, "maxUint64", ({ enumerable: true, get: function () { return number_js_1.maxUint64; } }));
Object.defineProperty(exports, "maxUint72", ({ enumerable: true, get: function () { return number_js_1.maxUint72; } }));
Object.defineProperty(exports, "maxUint80", ({ enumerable: true, get: function () { return number_js_1.maxUint80; } }));
Object.defineProperty(exports, "maxUint88", ({ enumerable: true, get: function () { return number_js_1.maxUint88; } }));
Object.defineProperty(exports, "maxUint96", ({ enumerable: true, get: function () { return number_js_1.maxUint96; } }));
Object.defineProperty(exports, "maxUint104", ({ enumerable: true, get: function () { return number_js_1.maxUint104; } }));
Object.defineProperty(exports, "maxUint112", ({ enumerable: true, get: function () { return number_js_1.maxUint112; } }));
Object.defineProperty(exports, "maxUint120", ({ enumerable: true, get: function () { return number_js_1.maxUint120; } }));
Object.defineProperty(exports, "maxUint128", ({ enumerable: true, get: function () { return number_js_1.maxUint128; } }));
Object.defineProperty(exports, "maxUint136", ({ enumerable: true, get: function () { return number_js_1.maxUint136; } }));
Object.defineProperty(exports, "maxUint144", ({ enumerable: true, get: function () { return number_js_1.maxUint144; } }));
Object.defineProperty(exports, "maxUint152", ({ enumerable: true, get: function () { return number_js_1.maxUint152; } }));
Object.defineProperty(exports, "maxUint160", ({ enumerable: true, get: function () { return number_js_1.maxUint160; } }));
Object.defineProperty(exports, "maxUint168", ({ enumerable: true, get: function () { return number_js_1.maxUint168; } }));
Object.defineProperty(exports, "maxUint176", ({ enumerable: true, get: function () { return number_js_1.maxUint176; } }));
Object.defineProperty(exports, "maxUint184", ({ enumerable: true, get: function () { return number_js_1.maxUint184; } }));
Object.defineProperty(exports, "maxUint192", ({ enumerable: true, get: function () { return number_js_1.maxUint192; } }));
Object.defineProperty(exports, "maxUint200", ({ enumerable: true, get: function () { return number_js_1.maxUint200; } }));
Object.defineProperty(exports, "maxUint208", ({ enumerable: true, get: function () { return number_js_1.maxUint208; } }));
Object.defineProperty(exports, "maxUint216", ({ enumerable: true, get: function () { return number_js_1.maxUint216; } }));
Object.defineProperty(exports, "maxUint224", ({ enumerable: true, get: function () { return number_js_1.maxUint224; } }));
Object.defineProperty(exports, "maxUint232", ({ enumerable: true, get: function () { return number_js_1.maxUint232; } }));
Object.defineProperty(exports, "maxUint240", ({ enumerable: true, get: function () { return number_js_1.maxUint240; } }));
Object.defineProperty(exports, "maxUint248", ({ enumerable: true, get: function () { return number_js_1.maxUint248; } }));
Object.defineProperty(exports, "maxUint256", ({ enumerable: true, get: function () { return number_js_1.maxUint256; } }));
Object.defineProperty(exports, "minInt8", ({ enumerable: true, get: function () { return number_js_1.minInt8; } }));
Object.defineProperty(exports, "minInt16", ({ enumerable: true, get: function () { return number_js_1.minInt16; } }));
Object.defineProperty(exports, "minInt24", ({ enumerable: true, get: function () { return number_js_1.minInt24; } }));
Object.defineProperty(exports, "minInt32", ({ enumerable: true, get: function () { return number_js_1.minInt32; } }));
Object.defineProperty(exports, "minInt40", ({ enumerable: true, get: function () { return number_js_1.minInt40; } }));
Object.defineProperty(exports, "minInt48", ({ enumerable: true, get: function () { return number_js_1.minInt48; } }));
Object.defineProperty(exports, "minInt56", ({ enumerable: true, get: function () { return number_js_1.minInt56; } }));
Object.defineProperty(exports, "minInt64", ({ enumerable: true, get: function () { return number_js_1.minInt64; } }));
Object.defineProperty(exports, "minInt72", ({ enumerable: true, get: function () { return number_js_1.minInt72; } }));
Object.defineProperty(exports, "minInt80", ({ enumerable: true, get: function () { return number_js_1.minInt80; } }));
Object.defineProperty(exports, "minInt88", ({ enumerable: true, get: function () { return number_js_1.minInt88; } }));
Object.defineProperty(exports, "minInt96", ({ enumerable: true, get: function () { return number_js_1.minInt96; } }));
Object.defineProperty(exports, "minInt104", ({ enumerable: true, get: function () { return number_js_1.minInt104; } }));
Object.defineProperty(exports, "minInt112", ({ enumerable: true, get: function () { return number_js_1.minInt112; } }));
Object.defineProperty(exports, "minInt120", ({ enumerable: true, get: function () { return number_js_1.minInt120; } }));
Object.defineProperty(exports, "minInt128", ({ enumerable: true, get: function () { return number_js_1.minInt128; } }));
Object.defineProperty(exports, "minInt136", ({ enumerable: true, get: function () { return number_js_1.minInt136; } }));
Object.defineProperty(exports, "minInt144", ({ enumerable: true, get: function () { return number_js_1.minInt144; } }));
Object.defineProperty(exports, "minInt152", ({ enumerable: true, get: function () { return number_js_1.minInt152; } }));
Object.defineProperty(exports, "minInt160", ({ enumerable: true, get: function () { return number_js_1.minInt160; } }));
Object.defineProperty(exports, "minInt168", ({ enumerable: true, get: function () { return number_js_1.minInt168; } }));
Object.defineProperty(exports, "minInt176", ({ enumerable: true, get: function () { return number_js_1.minInt176; } }));
Object.defineProperty(exports, "minInt184", ({ enumerable: true, get: function () { return number_js_1.minInt184; } }));
Object.defineProperty(exports, "minInt192", ({ enumerable: true, get: function () { return number_js_1.minInt192; } }));
Object.defineProperty(exports, "minInt200", ({ enumerable: true, get: function () { return number_js_1.minInt200; } }));
Object.defineProperty(exports, "minInt208", ({ enumerable: true, get: function () { return number_js_1.minInt208; } }));
Object.defineProperty(exports, "minInt216", ({ enumerable: true, get: function () { return number_js_1.minInt216; } }));
Object.defineProperty(exports, "minInt224", ({ enumerable: true, get: function () { return number_js_1.minInt224; } }));
Object.defineProperty(exports, "minInt232", ({ enumerable: true, get: function () { return number_js_1.minInt232; } }));
Object.defineProperty(exports, "minInt240", ({ enumerable: true, get: function () { return number_js_1.minInt240; } }));
Object.defineProperty(exports, "minInt248", ({ enumerable: true, get: function () { return number_js_1.minInt248; } }));
Object.defineProperty(exports, "minInt256", ({ enumerable: true, get: function () { return number_js_1.minInt256; } }));
var bytes_js_1 = __webpack_require__(/*! ./constants/bytes.js */ "../../node_modules/viem/_cjs/constants/bytes.js");
Object.defineProperty(exports, "zeroHash", ({ enumerable: true, get: function () { return bytes_js_1.zeroHash; } }));
var strings_js_1 = __webpack_require__(/*! ./constants/strings.js */ "../../node_modules/viem/_cjs/constants/strings.js");
Object.defineProperty(exports, "presignMessagePrefix", ({ enumerable: true, get: function () { return strings_js_1.presignMessagePrefix; } }));
var abi_js_1 = __webpack_require__(/*! ./errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
Object.defineProperty(exports, "AbiConstructorNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiConstructorNotFoundError; } }));
Object.defineProperty(exports, "AbiConstructorParamsNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiConstructorParamsNotFoundError; } }));
Object.defineProperty(exports, "AbiDecodingDataSizeInvalidError", ({ enumerable: true, get: function () { return abi_js_1.AbiDecodingDataSizeInvalidError; } }));
Object.defineProperty(exports, "AbiDecodingDataSizeTooSmallError", ({ enumerable: true, get: function () { return abi_js_1.AbiDecodingDataSizeTooSmallError; } }));
Object.defineProperty(exports, "AbiDecodingZeroDataError", ({ enumerable: true, get: function () { return abi_js_1.AbiDecodingZeroDataError; } }));
Object.defineProperty(exports, "AbiEncodingArrayLengthMismatchError", ({ enumerable: true, get: function () { return abi_js_1.AbiEncodingArrayLengthMismatchError; } }));
Object.defineProperty(exports, "AbiEncodingLengthMismatchError", ({ enumerable: true, get: function () { return abi_js_1.AbiEncodingLengthMismatchError; } }));
Object.defineProperty(exports, "AbiEncodingBytesSizeMismatchError", ({ enumerable: true, get: function () { return abi_js_1.AbiEncodingBytesSizeMismatchError; } }));
Object.defineProperty(exports, "AbiErrorInputsNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiErrorInputsNotFoundError; } }));
Object.defineProperty(exports, "AbiErrorNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiErrorNotFoundError; } }));
Object.defineProperty(exports, "AbiErrorSignatureNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiErrorSignatureNotFoundError; } }));
Object.defineProperty(exports, "AbiEventNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiEventNotFoundError; } }));
Object.defineProperty(exports, "AbiEventSignatureEmptyTopicsError", ({ enumerable: true, get: function () { return abi_js_1.AbiEventSignatureEmptyTopicsError; } }));
Object.defineProperty(exports, "AbiEventSignatureNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiEventSignatureNotFoundError; } }));
Object.defineProperty(exports, "AbiFunctionNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiFunctionNotFoundError; } }));
Object.defineProperty(exports, "AbiFunctionOutputsNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiFunctionOutputsNotFoundError; } }));
Object.defineProperty(exports, "AbiFunctionSignatureNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiFunctionSignatureNotFoundError; } }));
Object.defineProperty(exports, "BytesSizeMismatchError", ({ enumerable: true, get: function () { return abi_js_1.BytesSizeMismatchError; } }));
Object.defineProperty(exports, "DecodeLogDataMismatch", ({ enumerable: true, get: function () { return abi_js_1.DecodeLogDataMismatch; } }));
Object.defineProperty(exports, "DecodeLogTopicsMismatch", ({ enumerable: true, get: function () { return abi_js_1.DecodeLogTopicsMismatch; } }));
Object.defineProperty(exports, "InvalidAbiDecodingTypeError", ({ enumerable: true, get: function () { return abi_js_1.InvalidAbiDecodingTypeError; } }));
Object.defineProperty(exports, "InvalidAbiEncodingTypeError", ({ enumerable: true, get: function () { return abi_js_1.InvalidAbiEncodingTypeError; } }));
Object.defineProperty(exports, "InvalidArrayError", ({ enumerable: true, get: function () { return abi_js_1.InvalidArrayError; } }));
Object.defineProperty(exports, "InvalidDefinitionTypeError", ({ enumerable: true, get: function () { return abi_js_1.InvalidDefinitionTypeError; } }));
Object.defineProperty(exports, "UnsupportedPackedAbiType", ({ enumerable: true, get: function () { return abi_js_1.UnsupportedPackedAbiType; } }));
var base_js_1 = __webpack_require__(/*! ./errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
Object.defineProperty(exports, "BaseError", ({ enumerable: true, get: function () { return base_js_1.BaseError; } }));
var block_js_1 = __webpack_require__(/*! ./errors/block.js */ "../../node_modules/viem/_cjs/errors/block.js");
Object.defineProperty(exports, "BlockNotFoundError", ({ enumerable: true, get: function () { return block_js_1.BlockNotFoundError; } }));
var contract_js_1 = __webpack_require__(/*! ./errors/contract.js */ "../../node_modules/viem/_cjs/errors/contract.js");
Object.defineProperty(exports, "CallExecutionError", ({ enumerable: true, get: function () { return contract_js_1.CallExecutionError; } }));
Object.defineProperty(exports, "ContractFunctionExecutionError", ({ enumerable: true, get: function () { return contract_js_1.ContractFunctionExecutionError; } }));
Object.defineProperty(exports, "ContractFunctionRevertedError", ({ enumerable: true, get: function () { return contract_js_1.ContractFunctionRevertedError; } }));
Object.defineProperty(exports, "ContractFunctionZeroDataError", ({ enumerable: true, get: function () { return contract_js_1.ContractFunctionZeroDataError; } }));
Object.defineProperty(exports, "RawContractError", ({ enumerable: true, get: function () { return contract_js_1.RawContractError; } }));
var fee_js_1 = __webpack_require__(/*! ./errors/fee.js */ "../../node_modules/viem/_cjs/errors/fee.js");
Object.defineProperty(exports, "BaseFeeScalarError", ({ enumerable: true, get: function () { return fee_js_1.BaseFeeScalarError; } }));
Object.defineProperty(exports, "Eip1559FeesNotSupportedError", ({ enumerable: true, get: function () { return fee_js_1.Eip1559FeesNotSupportedError; } }));
Object.defineProperty(exports, "MaxFeePerGasTooLowError", ({ enumerable: true, get: function () { return fee_js_1.MaxFeePerGasTooLowError; } }));
var rpc_js_1 = __webpack_require__(/*! ./errors/rpc.js */ "../../node_modules/viem/_cjs/errors/rpc.js");
Object.defineProperty(exports, "ChainDisconnectedError", ({ enumerable: true, get: function () { return rpc_js_1.ChainDisconnectedError; } }));
Object.defineProperty(exports, "InternalRpcError", ({ enumerable: true, get: function () { return rpc_js_1.InternalRpcError; } }));
Object.defineProperty(exports, "InvalidInputRpcError", ({ enumerable: true, get: function () { return rpc_js_1.InvalidInputRpcError; } }));
Object.defineProperty(exports, "InvalidParamsRpcError", ({ enumerable: true, get: function () { return rpc_js_1.InvalidParamsRpcError; } }));
Object.defineProperty(exports, "InvalidRequestRpcError", ({ enumerable: true, get: function () { return rpc_js_1.InvalidRequestRpcError; } }));
Object.defineProperty(exports, "JsonRpcVersionUnsupportedError", ({ enumerable: true, get: function () { return rpc_js_1.JsonRpcVersionUnsupportedError; } }));
Object.defineProperty(exports, "LimitExceededRpcError", ({ enumerable: true, get: function () { return rpc_js_1.LimitExceededRpcError; } }));
Object.defineProperty(exports, "MethodNotFoundRpcError", ({ enumerable: true, get: function () { return rpc_js_1.MethodNotFoundRpcError; } }));
Object.defineProperty(exports, "MethodNotSupportedRpcError", ({ enumerable: true, get: function () { return rpc_js_1.MethodNotSupportedRpcError; } }));
Object.defineProperty(exports, "ParseRpcError", ({ enumerable: true, get: function () { return rpc_js_1.ParseRpcError; } }));
Object.defineProperty(exports, "ProviderDisconnectedError", ({ enumerable: true, get: function () { return rpc_js_1.ProviderDisconnectedError; } }));
Object.defineProperty(exports, "ProviderRpcError", ({ enumerable: true, get: function () { return rpc_js_1.ProviderRpcError; } }));
Object.defineProperty(exports, "ResourceNotFoundRpcError", ({ enumerable: true, get: function () { return rpc_js_1.ResourceNotFoundRpcError; } }));
Object.defineProperty(exports, "ResourceUnavailableRpcError", ({ enumerable: true, get: function () { return rpc_js_1.ResourceUnavailableRpcError; } }));
Object.defineProperty(exports, "RpcError", ({ enumerable: true, get: function () { return rpc_js_1.RpcError; } }));
Object.defineProperty(exports, "SwitchChainError", ({ enumerable: true, get: function () { return rpc_js_1.SwitchChainError; } }));
Object.defineProperty(exports, "TransactionRejectedRpcError", ({ enumerable: true, get: function () { return rpc_js_1.TransactionRejectedRpcError; } }));
Object.defineProperty(exports, "UnauthorizedProviderError", ({ enumerable: true, get: function () { return rpc_js_1.UnauthorizedProviderError; } }));
Object.defineProperty(exports, "UnknownRpcError", ({ enumerable: true, get: function () { return rpc_js_1.UnknownRpcError; } }));
Object.defineProperty(exports, "UnsupportedProviderMethodError", ({ enumerable: true, get: function () { return rpc_js_1.UnsupportedProviderMethodError; } }));
Object.defineProperty(exports, "UserRejectedRequestError", ({ enumerable: true, get: function () { return rpc_js_1.UserRejectedRequestError; } }));
var chain_js_1 = __webpack_require__(/*! ./errors/chain.js */ "../../node_modules/viem/_cjs/errors/chain.js");
Object.defineProperty(exports, "ChainDoesNotSupportContract", ({ enumerable: true, get: function () { return chain_js_1.ChainDoesNotSupportContract; } }));
Object.defineProperty(exports, "ChainMismatchError", ({ enumerable: true, get: function () { return chain_js_1.ChainMismatchError; } }));
Object.defineProperty(exports, "ChainNotFoundError", ({ enumerable: true, get: function () { return chain_js_1.ChainNotFoundError; } }));
Object.defineProperty(exports, "ClientChainNotConfiguredError", ({ enumerable: true, get: function () { return chain_js_1.ClientChainNotConfiguredError; } }));
Object.defineProperty(exports, "InvalidChainIdError", ({ enumerable: true, get: function () { return chain_js_1.InvalidChainIdError; } }));
var encoding_js_1 = __webpack_require__(/*! ./errors/encoding.js */ "../../node_modules/viem/_cjs/errors/encoding.js");
Object.defineProperty(exports, "DataLengthTooLongError", ({ enumerable: true, get: function () { return encoding_js_1.DataLengthTooLongError; } }));
Object.defineProperty(exports, "DataLengthTooShortError", ({ enumerable: true, get: function () { return encoding_js_1.DataLengthTooShortError; } }));
Object.defineProperty(exports, "InvalidBytesBooleanError", ({ enumerable: true, get: function () { return encoding_js_1.InvalidBytesBooleanError; } }));
Object.defineProperty(exports, "IntegerOutOfRangeError", ({ enumerable: true, get: function () { return encoding_js_1.IntegerOutOfRangeError; } }));
Object.defineProperty(exports, "InvalidHexBooleanError", ({ enumerable: true, get: function () { return encoding_js_1.InvalidHexBooleanError; } }));
Object.defineProperty(exports, "InvalidHexValueError", ({ enumerable: true, get: function () { return encoding_js_1.InvalidHexValueError; } }));
Object.defineProperty(exports, "OffsetOutOfBoundsError", ({ enumerable: true, get: function () { return encoding_js_1.OffsetOutOfBoundsError; } }));
Object.defineProperty(exports, "SizeOverflowError", ({ enumerable: true, get: function () { return encoding_js_1.SizeOverflowError; } }));
var ens_js_1 = __webpack_require__(/*! ./errors/ens.js */ "../../node_modules/viem/_cjs/errors/ens.js");
Object.defineProperty(exports, "EnsAvatarUriResolutionError", ({ enumerable: true, get: function () { return ens_js_1.EnsAvatarUriResolutionError; } }));
Object.defineProperty(exports, "EnsAvatarInvalidNftUriError", ({ enumerable: true, get: function () { return ens_js_1.EnsAvatarInvalidNftUriError; } }));
Object.defineProperty(exports, "EnsAvatarUnsupportedNamespaceError", ({ enumerable: true, get: function () { return ens_js_1.EnsAvatarUnsupportedNamespaceError; } }));
var estimateGas_js_1 = __webpack_require__(/*! ./errors/estimateGas.js */ "../../node_modules/viem/_cjs/errors/estimateGas.js");
Object.defineProperty(exports, "EstimateGasExecutionError", ({ enumerable: true, get: function () { return estimateGas_js_1.EstimateGasExecutionError; } }));
var node_js_1 = __webpack_require__(/*! ./errors/node.js */ "../../node_modules/viem/_cjs/errors/node.js");
Object.defineProperty(exports, "ExecutionRevertedError", ({ enumerable: true, get: function () { return node_js_1.ExecutionRevertedError; } }));
Object.defineProperty(exports, "FeeCapTooHighError", ({ enumerable: true, get: function () { return node_js_1.FeeCapTooHighError; } }));
Object.defineProperty(exports, "FeeCapTooLowError", ({ enumerable: true, get: function () { return node_js_1.FeeCapTooLowError; } }));
Object.defineProperty(exports, "InsufficientFundsError", ({ enumerable: true, get: function () { return node_js_1.InsufficientFundsError; } }));
Object.defineProperty(exports, "IntrinsicGasTooHighError", ({ enumerable: true, get: function () { return node_js_1.IntrinsicGasTooHighError; } }));
Object.defineProperty(exports, "IntrinsicGasTooLowError", ({ enumerable: true, get: function () { return node_js_1.IntrinsicGasTooLowError; } }));
Object.defineProperty(exports, "NonceMaxValueError", ({ enumerable: true, get: function () { return node_js_1.NonceMaxValueError; } }));
Object.defineProperty(exports, "NonceTooHighError", ({ enumerable: true, get: function () { return node_js_1.NonceTooHighError; } }));
Object.defineProperty(exports, "NonceTooLowError", ({ enumerable: true, get: function () { return node_js_1.NonceTooLowError; } }));
Object.defineProperty(exports, "TipAboveFeeCapError", ({ enumerable: true, get: function () { return node_js_1.TipAboveFeeCapError; } }));
Object.defineProperty(exports, "TransactionTypeNotSupportedError", ({ enumerable: true, get: function () { return node_js_1.TransactionTypeNotSupportedError; } }));
Object.defineProperty(exports, "UnknownNodeError", ({ enumerable: true, get: function () { return node_js_1.UnknownNodeError; } }));
var log_js_1 = __webpack_require__(/*! ./errors/log.js */ "../../node_modules/viem/_cjs/errors/log.js");
Object.defineProperty(exports, "FilterTypeNotSupportedError", ({ enumerable: true, get: function () { return log_js_1.FilterTypeNotSupportedError; } }));
var request_js_1 = __webpack_require__(/*! ./errors/request.js */ "../../node_modules/viem/_cjs/errors/request.js");
Object.defineProperty(exports, "HttpRequestError", ({ enumerable: true, get: function () { return request_js_1.HttpRequestError; } }));
Object.defineProperty(exports, "RpcRequestError", ({ enumerable: true, get: function () { return request_js_1.RpcRequestError; } }));
Object.defineProperty(exports, "TimeoutError", ({ enumerable: true, get: function () { return request_js_1.TimeoutError; } }));
Object.defineProperty(exports, "WebSocketRequestError", ({ enumerable: true, get: function () { return request_js_1.WebSocketRequestError; } }));
var address_js_2 = __webpack_require__(/*! ./errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
Object.defineProperty(exports, "InvalidAddressError", ({ enumerable: true, get: function () { return address_js_2.InvalidAddressError; } }));
var transaction_js_1 = __webpack_require__(/*! ./errors/transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
Object.defineProperty(exports, "FeeConflictError", ({ enumerable: true, get: function () { return transaction_js_1.FeeConflictError; } }));
Object.defineProperty(exports, "InvalidLegacyVError", ({ enumerable: true, get: function () { return transaction_js_1.InvalidLegacyVError; } }));
Object.defineProperty(exports, "InvalidSerializableTransactionError", ({ enumerable: true, get: function () { return transaction_js_1.InvalidSerializableTransactionError; } }));
Object.defineProperty(exports, "InvalidSerializedTransactionError", ({ enumerable: true, get: function () { return transaction_js_1.InvalidSerializedTransactionError; } }));
Object.defineProperty(exports, "InvalidSerializedTransactionTypeError", ({ enumerable: true, get: function () { return transaction_js_1.InvalidSerializedTransactionTypeError; } }));
Object.defineProperty(exports, "InvalidStorageKeySizeError", ({ enumerable: true, get: function () { return transaction_js_1.InvalidStorageKeySizeError; } }));
Object.defineProperty(exports, "TransactionExecutionError", ({ enumerable: true, get: function () { return transaction_js_1.TransactionExecutionError; } }));
Object.defineProperty(exports, "TransactionNotFoundError", ({ enumerable: true, get: function () { return transaction_js_1.TransactionNotFoundError; } }));
Object.defineProperty(exports, "TransactionReceiptNotFoundError", ({ enumerable: true, get: function () { return transaction_js_1.TransactionReceiptNotFoundError; } }));
Object.defineProperty(exports, "WaitForTransactionReceiptTimeoutError", ({ enumerable: true, get: function () { return transaction_js_1.WaitForTransactionReceiptTimeoutError; } }));
var data_js_1 = __webpack_require__(/*! ./errors/data.js */ "../../node_modules/viem/_cjs/errors/data.js");
Object.defineProperty(exports, "SizeExceedsPaddingSizeError", ({ enumerable: true, get: function () { return data_js_1.SizeExceedsPaddingSizeError; } }));
Object.defineProperty(exports, "SliceOffsetOutOfBoundsError", ({ enumerable: true, get: function () { return data_js_1.SliceOffsetOutOfBoundsError; } }));
var transport_js_1 = __webpack_require__(/*! ./errors/transport.js */ "../../node_modules/viem/_cjs/errors/transport.js");
Object.defineProperty(exports, "UrlRequiredError", ({ enumerable: true, get: function () { return transport_js_1.UrlRequiredError; } }));
var labelhash_js_1 = __webpack_require__(/*! ./utils/ens/labelhash.js */ "../../node_modules/viem/_cjs/utils/ens/labelhash.js");
Object.defineProperty(exports, "labelhash", ({ enumerable: true, get: function () { return labelhash_js_1.labelhash; } }));
var namehash_js_1 = __webpack_require__(/*! ./utils/ens/namehash.js */ "../../node_modules/viem/_cjs/utils/ens/namehash.js");
Object.defineProperty(exports, "namehash", ({ enumerable: true, get: function () { return namehash_js_1.namehash; } }));
var block_js_2 = __webpack_require__(/*! ./utils/formatters/block.js */ "../../node_modules/viem/_cjs/utils/formatters/block.js");
Object.defineProperty(exports, "defineBlock", ({ enumerable: true, get: function () { return block_js_2.defineBlock; } }));
Object.defineProperty(exports, "formatBlock", ({ enumerable: true, get: function () { return block_js_2.formatBlock; } }));
var log_js_2 = __webpack_require__(/*! ./utils/formatters/log.js */ "../../node_modules/viem/_cjs/utils/formatters/log.js");
Object.defineProperty(exports, "formatLog", ({ enumerable: true, get: function () { return log_js_2.formatLog; } }));
var decodeAbiParameters_js_1 = __webpack_require__(/*! ./utils/abi/decodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
Object.defineProperty(exports, "decodeAbiParameters", ({ enumerable: true, get: function () { return decodeAbiParameters_js_1.decodeAbiParameters; } }));
var decodeDeployData_js_1 = __webpack_require__(/*! ./utils/abi/decodeDeployData.js */ "../../node_modules/viem/_cjs/utils/abi/decodeDeployData.js");
Object.defineProperty(exports, "decodeDeployData", ({ enumerable: true, get: function () { return decodeDeployData_js_1.decodeDeployData; } }));
var decodeErrorResult_js_1 = __webpack_require__(/*! ./utils/abi/decodeErrorResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeErrorResult.js");
Object.defineProperty(exports, "decodeErrorResult", ({ enumerable: true, get: function () { return decodeErrorResult_js_1.decodeErrorResult; } }));
var decodeEventLog_js_1 = __webpack_require__(/*! ./utils/abi/decodeEventLog.js */ "../../node_modules/viem/_cjs/utils/abi/decodeEventLog.js");
Object.defineProperty(exports, "decodeEventLog", ({ enumerable: true, get: function () { return decodeEventLog_js_1.decodeEventLog; } }));
var decodeFunctionData_js_1 = __webpack_require__(/*! ./utils/abi/decodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionData.js");
Object.defineProperty(exports, "decodeFunctionData", ({ enumerable: true, get: function () { return decodeFunctionData_js_1.decodeFunctionData; } }));
var decodeFunctionResult_js_1 = __webpack_require__(/*! ./utils/abi/decodeFunctionResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
Object.defineProperty(exports, "decodeFunctionResult", ({ enumerable: true, get: function () { return decodeFunctionResult_js_1.decodeFunctionResult; } }));
var encodeAbiParameters_js_1 = __webpack_require__(/*! ./utils/abi/encodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
Object.defineProperty(exports, "encodeAbiParameters", ({ enumerable: true, get: function () { return encodeAbiParameters_js_1.encodeAbiParameters; } }));
var encodeDeployData_js_1 = __webpack_require__(/*! ./utils/abi/encodeDeployData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeDeployData.js");
Object.defineProperty(exports, "encodeDeployData", ({ enumerable: true, get: function () { return encodeDeployData_js_1.encodeDeployData; } }));
var encodeErrorResult_js_1 = __webpack_require__(/*! ./utils/abi/encodeErrorResult.js */ "../../node_modules/viem/_cjs/utils/abi/encodeErrorResult.js");
Object.defineProperty(exports, "encodeErrorResult", ({ enumerable: true, get: function () { return encodeErrorResult_js_1.encodeErrorResult; } }));
var encodeEventTopics_js_1 = __webpack_require__(/*! ./utils/abi/encodeEventTopics.js */ "../../node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
Object.defineProperty(exports, "encodeEventTopics", ({ enumerable: true, get: function () { return encodeEventTopics_js_1.encodeEventTopics; } }));
var encodeFunctionData_js_1 = __webpack_require__(/*! ./utils/abi/encodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
Object.defineProperty(exports, "encodeFunctionData", ({ enumerable: true, get: function () { return encodeFunctionData_js_1.encodeFunctionData; } }));
var encodeFunctionResult_js_1 = __webpack_require__(/*! ./utils/abi/encodeFunctionResult.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js");
Object.defineProperty(exports, "encodeFunctionResult", ({ enumerable: true, get: function () { return encodeFunctionResult_js_1.encodeFunctionResult; } }));
var transaction_js_2 = __webpack_require__(/*! ./utils/formatters/transaction.js */ "../../node_modules/viem/_cjs/utils/formatters/transaction.js");
Object.defineProperty(exports, "defineTransaction", ({ enumerable: true, get: function () { return transaction_js_2.defineTransaction; } }));
Object.defineProperty(exports, "formatTransaction", ({ enumerable: true, get: function () { return transaction_js_2.formatTransaction; } }));
Object.defineProperty(exports, "transactionType", ({ enumerable: true, get: function () { return transaction_js_2.transactionType; } }));
var transactionReceipt_js_1 = __webpack_require__(/*! ./utils/formatters/transactionReceipt.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionReceipt.js");
Object.defineProperty(exports, "defineTransactionReceipt", ({ enumerable: true, get: function () { return transactionReceipt_js_1.defineTransactionReceipt; } }));
Object.defineProperty(exports, "formatTransactionReceipt", ({ enumerable: true, get: function () { return transactionReceipt_js_1.formatTransactionReceipt; } }));
var transactionRequest_js_1 = __webpack_require__(/*! ./utils/formatters/transactionRequest.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
Object.defineProperty(exports, "defineTransactionRequest", ({ enumerable: true, get: function () { return transactionRequest_js_1.defineTransactionRequest; } }));
Object.defineProperty(exports, "formatTransactionRequest", ({ enumerable: true, get: function () { return transactionRequest_js_1.formatTransactionRequest; } }));
Object.defineProperty(exports, "rpcTransactionType", ({ enumerable: true, get: function () { return transactionRequest_js_1.rpcTransactionType; } }));
var getAbiItem_js_1 = __webpack_require__(/*! ./utils/abi/getAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/getAbiItem.js");
Object.defineProperty(exports, "getAbiItem", ({ enumerable: true, get: function () { return getAbiItem_js_1.getAbiItem; } }));
var getContractAddress_js_1 = __webpack_require__(/*! ./utils/address/getContractAddress.js */ "../../node_modules/viem/_cjs/utils/address/getContractAddress.js");
Object.defineProperty(exports, "getContractAddress", ({ enumerable: true, get: function () { return getContractAddress_js_1.getContractAddress; } }));
Object.defineProperty(exports, "getCreate2Address", ({ enumerable: true, get: function () { return getContractAddress_js_1.getCreate2Address; } }));
Object.defineProperty(exports, "getCreateAddress", ({ enumerable: true, get: function () { return getContractAddress_js_1.getCreateAddress; } }));
var getSerializedTransactionType_js_1 = __webpack_require__(/*! ./utils/transaction/getSerializedTransactionType.js */ "../../node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js");
Object.defineProperty(exports, "getSerializedTransactionType", ({ enumerable: true, get: function () { return getSerializedTransactionType_js_1.getSerializedTransactionType; } }));
var getTransactionType_js_1 = __webpack_require__(/*! ./utils/transaction/getTransactionType.js */ "../../node_modules/viem/_cjs/utils/transaction/getTransactionType.js");
Object.defineProperty(exports, "getTransactionType", ({ enumerable: true, get: function () { return getTransactionType_js_1.getTransactionType; } }));
var hashTypedData_js_1 = __webpack_require__(/*! ./utils/signature/hashTypedData.js */ "../../node_modules/viem/_cjs/utils/signature/hashTypedData.js");
Object.defineProperty(exports, "hashDomain", ({ enumerable: true, get: function () { return hashTypedData_js_1.hashDomain; } }));
Object.defineProperty(exports, "hashTypedData", ({ enumerable: true, get: function () { return hashTypedData_js_1.hashTypedData; } }));
var compactSignatureToSignature_js_1 = __webpack_require__(/*! ./utils/signature/compactSignatureToSignature.js */ "../../node_modules/viem/_cjs/utils/signature/compactSignatureToSignature.js");
Object.defineProperty(exports, "compactSignatureToSignature", ({ enumerable: true, get: function () { return compactSignatureToSignature_js_1.compactSignatureToSignature; } }));
var hexToCompactSignature_js_1 = __webpack_require__(/*! ./utils/signature/hexToCompactSignature.js */ "../../node_modules/viem/_cjs/utils/signature/hexToCompactSignature.js");
Object.defineProperty(exports, "hexToCompactSignature", ({ enumerable: true, get: function () { return hexToCompactSignature_js_1.hexToCompactSignature; } }));
var hexToSignature_js_1 = __webpack_require__(/*! ./utils/signature/hexToSignature.js */ "../../node_modules/viem/_cjs/utils/signature/hexToSignature.js");
Object.defineProperty(exports, "hexToSignature", ({ enumerable: true, get: function () { return hexToSignature_js_1.hexToSignature; } }));
var recoverAddress_js_1 = __webpack_require__(/*! ./utils/signature/recoverAddress.js */ "../../node_modules/viem/_cjs/utils/signature/recoverAddress.js");
Object.defineProperty(exports, "recoverAddress", ({ enumerable: true, get: function () { return recoverAddress_js_1.recoverAddress; } }));
var recoverMessageAddress_js_1 = __webpack_require__(/*! ./utils/signature/recoverMessageAddress.js */ "../../node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js");
Object.defineProperty(exports, "recoverMessageAddress", ({ enumerable: true, get: function () { return recoverMessageAddress_js_1.recoverMessageAddress; } }));
var recoverPublicKey_js_1 = __webpack_require__(/*! ./utils/signature/recoverPublicKey.js */ "../../node_modules/viem/_cjs/utils/signature/recoverPublicKey.js");
Object.defineProperty(exports, "recoverPublicKey", ({ enumerable: true, get: function () { return recoverPublicKey_js_1.recoverPublicKey; } }));
var recoverTypedDataAddress_js_1 = __webpack_require__(/*! ./utils/signature/recoverTypedDataAddress.js */ "../../node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js");
Object.defineProperty(exports, "recoverTypedDataAddress", ({ enumerable: true, get: function () { return recoverTypedDataAddress_js_1.recoverTypedDataAddress; } }));
var signatureToCompactSignature_js_1 = __webpack_require__(/*! ./utils/signature/signatureToCompactSignature.js */ "../../node_modules/viem/_cjs/utils/signature/signatureToCompactSignature.js");
Object.defineProperty(exports, "signatureToCompactSignature", ({ enumerable: true, get: function () { return signatureToCompactSignature_js_1.signatureToCompactSignature; } }));
var compactSignatureToHex_js_1 = __webpack_require__(/*! ./utils/signature/compactSignatureToHex.js */ "../../node_modules/viem/_cjs/utils/signature/compactSignatureToHex.js");
Object.defineProperty(exports, "compactSignatureToHex", ({ enumerable: true, get: function () { return compactSignatureToHex_js_1.compactSignatureToHex; } }));
var signatureToHex_js_1 = __webpack_require__(/*! ./utils/signature/signatureToHex.js */ "../../node_modules/viem/_cjs/utils/signature/signatureToHex.js");
Object.defineProperty(exports, "signatureToHex", ({ enumerable: true, get: function () { return signatureToHex_js_1.signatureToHex; } }));
var toRlp_js_1 = __webpack_require__(/*! ./utils/encoding/toRlp.js */ "../../node_modules/viem/_cjs/utils/encoding/toRlp.js");
Object.defineProperty(exports, "bytesToRlp", ({ enumerable: true, get: function () { return toRlp_js_1.bytesToRlp; } }));
Object.defineProperty(exports, "hexToRlp", ({ enumerable: true, get: function () { return toRlp_js_1.hexToRlp; } }));
Object.defineProperty(exports, "toRlp", ({ enumerable: true, get: function () { return toRlp_js_1.toRlp; } }));
var verifyMessage_js_1 = __webpack_require__(/*! ./utils/signature/verifyMessage.js */ "../../node_modules/viem/_cjs/utils/signature/verifyMessage.js");
Object.defineProperty(exports, "verifyMessage", ({ enumerable: true, get: function () { return verifyMessage_js_1.verifyMessage; } }));
var verifyTypedData_js_1 = __webpack_require__(/*! ./utils/signature/verifyTypedData.js */ "../../node_modules/viem/_cjs/utils/signature/verifyTypedData.js");
Object.defineProperty(exports, "verifyTypedData", ({ enumerable: true, get: function () { return verifyTypedData_js_1.verifyTypedData; } }));
var assertRequest_js_1 = __webpack_require__(/*! ./utils/transaction/assertRequest.js */ "../../node_modules/viem/_cjs/utils/transaction/assertRequest.js");
Object.defineProperty(exports, "assertRequest", ({ enumerable: true, get: function () { return assertRequest_js_1.assertRequest; } }));
var assertTransaction_js_1 = __webpack_require__(/*! ./utils/transaction/assertTransaction.js */ "../../node_modules/viem/_cjs/utils/transaction/assertTransaction.js");
Object.defineProperty(exports, "assertTransactionEIP1559", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP1559; } }));
Object.defineProperty(exports, "assertTransactionEIP2930", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP2930; } }));
Object.defineProperty(exports, "assertTransactionLegacy", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionLegacy; } }));
var toBytes_js_1 = __webpack_require__(/*! ./utils/encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
Object.defineProperty(exports, "boolToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.boolToBytes; } }));
Object.defineProperty(exports, "hexToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.hexToBytes; } }));
Object.defineProperty(exports, "numberToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.numberToBytes; } }));
Object.defineProperty(exports, "stringToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.stringToBytes; } }));
Object.defineProperty(exports, "toBytes", ({ enumerable: true, get: function () { return toBytes_js_1.toBytes; } }));
var toHex_js_1 = __webpack_require__(/*! ./utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
Object.defineProperty(exports, "boolToHex", ({ enumerable: true, get: function () { return toHex_js_1.boolToHex; } }));
Object.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return toHex_js_1.bytesToHex; } }));
Object.defineProperty(exports, "numberToHex", ({ enumerable: true, get: function () { return toHex_js_1.numberToHex; } }));
Object.defineProperty(exports, "stringToHex", ({ enumerable: true, get: function () { return toHex_js_1.stringToHex; } }));
Object.defineProperty(exports, "toHex", ({ enumerable: true, get: function () { return toHex_js_1.toHex; } }));
var fromBytes_js_1 = __webpack_require__(/*! ./utils/encoding/fromBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/fromBytes.js");
Object.defineProperty(exports, "bytesToBigInt", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToBigInt; } }));
Object.defineProperty(exports, "bytesToBigint", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToBigInt; } }));
Object.defineProperty(exports, "bytesToBool", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToBool; } }));
Object.defineProperty(exports, "bytesToNumber", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToNumber; } }));
Object.defineProperty(exports, "bytesToString", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToString; } }));
Object.defineProperty(exports, "fromBytes", ({ enumerable: true, get: function () { return fromBytes_js_1.fromBytes; } }));
var ccip_js_1 = __webpack_require__(/*! ./utils/ccip.js */ "../../node_modules/viem/_cjs/utils/ccip.js");
Object.defineProperty(exports, "ccipFetch", ({ enumerable: true, get: function () { return ccip_js_1.ccipFetch; } }));
Object.defineProperty(exports, "offchainLookup", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookup; } }));
Object.defineProperty(exports, "offchainLookupAbiItem", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookupAbiItem; } }));
Object.defineProperty(exports, "offchainLookupSignature", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookupSignature; } }));
var concat_js_1 = __webpack_require__(/*! ./utils/data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
Object.defineProperty(exports, "concat", ({ enumerable: true, get: function () { return concat_js_1.concat; } }));
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return concat_js_1.concatBytes; } }));
Object.defineProperty(exports, "concatHex", ({ enumerable: true, get: function () { return concat_js_1.concatHex; } }));
var assertCurrentChain_js_1 = __webpack_require__(/*! ./utils/chain/assertCurrentChain.js */ "../../node_modules/viem/_cjs/utils/chain/assertCurrentChain.js");
Object.defineProperty(exports, "assertCurrentChain", ({ enumerable: true, get: function () { return assertCurrentChain_js_1.assertCurrentChain; } }));
var defineChain_js_1 = __webpack_require__(/*! ./utils/chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
Object.defineProperty(exports, "defineChain", ({ enumerable: true, get: function () { return defineChain_js_1.defineChain; } }));
var extractChain_js_1 = __webpack_require__(/*! ./utils/chain/extractChain.js */ "../../node_modules/viem/_cjs/utils/chain/extractChain.js");
Object.defineProperty(exports, "extractChain", ({ enumerable: true, get: function () { return extractChain_js_1.extractChain; } }));
var getChainContractAddress_js_1 = __webpack_require__(/*! ./utils/chain/getChainContractAddress.js */ "../../node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
Object.defineProperty(exports, "getChainContractAddress", ({ enumerable: true, get: function () { return getChainContractAddress_js_1.getChainContractAddress; } }));
var encodePacked_js_1 = __webpack_require__(/*! ./utils/abi/encodePacked.js */ "../../node_modules/viem/_cjs/utils/abi/encodePacked.js");
Object.defineProperty(exports, "encodePacked", ({ enumerable: true, get: function () { return encodePacked_js_1.encodePacked; } }));
var formatEther_js_1 = __webpack_require__(/*! ./utils/unit/formatEther.js */ "../../node_modules/viem/_cjs/utils/unit/formatEther.js");
Object.defineProperty(exports, "formatEther", ({ enumerable: true, get: function () { return formatEther_js_1.formatEther; } }));
var formatGwei_js_1 = __webpack_require__(/*! ./utils/unit/formatGwei.js */ "../../node_modules/viem/_cjs/utils/unit/formatGwei.js");
Object.defineProperty(exports, "formatGwei", ({ enumerable: true, get: function () { return formatGwei_js_1.formatGwei; } }));
var formatUnits_js_1 = __webpack_require__(/*! ./utils/unit/formatUnits.js */ "../../node_modules/viem/_cjs/utils/unit/formatUnits.js");
Object.defineProperty(exports, "formatUnits", ({ enumerable: true, get: function () { return formatUnits_js_1.formatUnits; } }));
var fromHex_js_1 = __webpack_require__(/*! ./utils/encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
Object.defineProperty(exports, "fromHex", ({ enumerable: true, get: function () { return fromHex_js_1.fromHex; } }));
Object.defineProperty(exports, "hexToBigInt", ({ enumerable: true, get: function () { return fromHex_js_1.hexToBigInt; } }));
Object.defineProperty(exports, "hexToBool", ({ enumerable: true, get: function () { return fromHex_js_1.hexToBool; } }));
Object.defineProperty(exports, "hexToNumber", ({ enumerable: true, get: function () { return fromHex_js_1.hexToNumber; } }));
Object.defineProperty(exports, "hexToString", ({ enumerable: true, get: function () { return fromHex_js_1.hexToString; } }));
var fromRlp_js_1 = __webpack_require__(/*! ./utils/encoding/fromRlp.js */ "../../node_modules/viem/_cjs/utils/encoding/fromRlp.js");
Object.defineProperty(exports, "fromRlp", ({ enumerable: true, get: function () { return fromRlp_js_1.fromRlp; } }));
var getAddress_js_1 = __webpack_require__(/*! ./utils/address/getAddress.js */ "../../node_modules/viem/_cjs/utils/address/getAddress.js");
Object.defineProperty(exports, "checksumAddress", ({ enumerable: true, get: function () { return getAddress_js_1.checksumAddress; } }));
Object.defineProperty(exports, "getAddress", ({ enumerable: true, get: function () { return getAddress_js_1.getAddress; } }));
var getContractError_js_1 = __webpack_require__(/*! ./utils/errors/getContractError.js */ "../../node_modules/viem/_cjs/utils/errors/getContractError.js");
Object.defineProperty(exports, "getContractError", ({ enumerable: true, get: function () { return getContractError_js_1.getContractError; } }));
var getEventSelector_js_1 = __webpack_require__(/*! ./utils/hash/getEventSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getEventSelector.js");
Object.defineProperty(exports, "getEventSelector", ({ enumerable: true, get: function () { return getEventSelector_js_1.getEventSelector; } }));
var getEventSignature_js_1 = __webpack_require__(/*! ./utils/hash/getEventSignature.js */ "../../node_modules/viem/_cjs/utils/hash/getEventSignature.js");
Object.defineProperty(exports, "getEventSignature", ({ enumerable: true, get: function () { return getEventSignature_js_1.getEventSignature; } }));
var getFunctionSelector_js_1 = __webpack_require__(/*! ./utils/hash/getFunctionSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getFunctionSelector.js");
Object.defineProperty(exports, "getFunctionSelector", ({ enumerable: true, get: function () { return getFunctionSelector_js_1.getFunctionSelector; } }));
var getFunctionSignature_js_1 = __webpack_require__(/*! ./utils/hash/getFunctionSignature.js */ "../../node_modules/viem/_cjs/utils/hash/getFunctionSignature.js");
Object.defineProperty(exports, "getFunctionSignature", ({ enumerable: true, get: function () { return getFunctionSignature_js_1.getFunctionSignature; } }));
var hashMessage_js_1 = __webpack_require__(/*! ./utils/signature/hashMessage.js */ "../../node_modules/viem/_cjs/utils/signature/hashMessage.js");
Object.defineProperty(exports, "hashMessage", ({ enumerable: true, get: function () { return hashMessage_js_1.hashMessage; } }));
var isAddress_js_1 = __webpack_require__(/*! ./utils/address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
Object.defineProperty(exports, "isAddress", ({ enumerable: true, get: function () { return isAddress_js_1.isAddress; } }));
var isAddressEqual_js_1 = __webpack_require__(/*! ./utils/address/isAddressEqual.js */ "../../node_modules/viem/_cjs/utils/address/isAddressEqual.js");
Object.defineProperty(exports, "isAddressEqual", ({ enumerable: true, get: function () { return isAddressEqual_js_1.isAddressEqual; } }));
var isBytes_js_1 = __webpack_require__(/*! ./utils/data/isBytes.js */ "../../node_modules/viem/_cjs/utils/data/isBytes.js");
Object.defineProperty(exports, "isBytes", ({ enumerable: true, get: function () { return isBytes_js_1.isBytes; } }));
var isHash_js_1 = __webpack_require__(/*! ./utils/hash/isHash.js */ "../../node_modules/viem/_cjs/utils/hash/isHash.js");
Object.defineProperty(exports, "isHash", ({ enumerable: true, get: function () { return isHash_js_1.isHash; } }));
var isHex_js_1 = __webpack_require__(/*! ./utils/data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
Object.defineProperty(exports, "isHex", ({ enumerable: true, get: function () { return isHex_js_1.isHex; } }));
var keccak256_js_1 = __webpack_require__(/*! ./utils/hash/keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
Object.defineProperty(exports, "keccak256", ({ enumerable: true, get: function () { return keccak256_js_1.keccak256; } }));
var sha256_js_1 = __webpack_require__(/*! ./utils/hash/sha256.js */ "../../node_modules/viem/_cjs/utils/hash/sha256.js");
Object.defineProperty(exports, "sha256", ({ enumerable: true, get: function () { return sha256_js_1.sha256; } }));
var ripemd160_js_1 = __webpack_require__(/*! ./utils/hash/ripemd160.js */ "../../node_modules/viem/_cjs/utils/hash/ripemd160.js");
Object.defineProperty(exports, "ripemd160", ({ enumerable: true, get: function () { return ripemd160_js_1.ripemd160; } }));
var pad_js_1 = __webpack_require__(/*! ./utils/data/pad.js */ "../../node_modules/viem/_cjs/utils/data/pad.js");
Object.defineProperty(exports, "pad", ({ enumerable: true, get: function () { return pad_js_1.pad; } }));
Object.defineProperty(exports, "padBytes", ({ enumerable: true, get: function () { return pad_js_1.padBytes; } }));
Object.defineProperty(exports, "padHex", ({ enumerable: true, get: function () { return pad_js_1.padHex; } }));
var parseEther_js_1 = __webpack_require__(/*! ./utils/unit/parseEther.js */ "../../node_modules/viem/_cjs/utils/unit/parseEther.js");
Object.defineProperty(exports, "parseEther", ({ enumerable: true, get: function () { return parseEther_js_1.parseEther; } }));
var parseGwei_js_1 = __webpack_require__(/*! ./utils/unit/parseGwei.js */ "../../node_modules/viem/_cjs/utils/unit/parseGwei.js");
Object.defineProperty(exports, "parseGwei", ({ enumerable: true, get: function () { return parseGwei_js_1.parseGwei; } }));
var parseTransaction_js_1 = __webpack_require__(/*! ./utils/transaction/parseTransaction.js */ "../../node_modules/viem/_cjs/utils/transaction/parseTransaction.js");
Object.defineProperty(exports, "parseTransaction", ({ enumerable: true, get: function () { return parseTransaction_js_1.parseTransaction; } }));
var parseUnits_js_1 = __webpack_require__(/*! ./utils/unit/parseUnits.js */ "../../node_modules/viem/_cjs/utils/unit/parseUnits.js");
Object.defineProperty(exports, "parseUnits", ({ enumerable: true, get: function () { return parseUnits_js_1.parseUnits; } }));
var serializeAccessList_js_1 = __webpack_require__(/*! ./utils/transaction/serializeAccessList.js */ "../../node_modules/viem/_cjs/utils/transaction/serializeAccessList.js");
Object.defineProperty(exports, "serializeAccessList", ({ enumerable: true, get: function () { return serializeAccessList_js_1.serializeAccessList; } }));
var serializeTransaction_js_1 = __webpack_require__(/*! ./utils/transaction/serializeTransaction.js */ "../../node_modules/viem/_cjs/utils/transaction/serializeTransaction.js");
Object.defineProperty(exports, "serializeTransaction", ({ enumerable: true, get: function () { return serializeTransaction_js_1.serializeTransaction; } }));
var size_js_1 = __webpack_require__(/*! ./utils/data/size.js */ "../../node_modules/viem/_cjs/utils/data/size.js");
Object.defineProperty(exports, "size", ({ enumerable: true, get: function () { return size_js_1.size; } }));
var slice_js_1 = __webpack_require__(/*! ./utils/data/slice.js */ "../../node_modules/viem/_cjs/utils/data/slice.js");
Object.defineProperty(exports, "slice", ({ enumerable: true, get: function () { return slice_js_1.slice; } }));
Object.defineProperty(exports, "sliceBytes", ({ enumerable: true, get: function () { return slice_js_1.sliceBytes; } }));
Object.defineProperty(exports, "sliceHex", ({ enumerable: true, get: function () { return slice_js_1.sliceHex; } }));
var stringify_js_1 = __webpack_require__(/*! ./utils/stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return stringify_js_1.stringify; } }));
var trim_js_1 = __webpack_require__(/*! ./utils/data/trim.js */ "../../node_modules/viem/_cjs/utils/data/trim.js");
Object.defineProperty(exports, "trim", ({ enumerable: true, get: function () { return trim_js_1.trim; } }));
var typedData_js_1 = __webpack_require__(/*! ./utils/typedData.js */ "../../node_modules/viem/_cjs/utils/typedData.js");
Object.defineProperty(exports, "validateTypedData", ({ enumerable: true, get: function () { return typedData_js_1.validateTypedData; } }));
Object.defineProperty(exports, "domainSeparator", ({ enumerable: true, get: function () { return typedData_js_1.domainSeparator; } }));
Object.defineProperty(exports, "getTypesForEIP712Domain", ({ enumerable: true, get: function () { return typedData_js_1.getTypesForEIP712Domain; } }));


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeAbiParameters = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const getAddress_js_1 = __webpack_require__(/*! ../address/getAddress.js */ "../../node_modules/viem/_cjs/utils/address/getAddress.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "../../node_modules/viem/_cjs/utils/data/size.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "../../node_modules/viem/_cjs/utils/data/slice.js");
const trim_js_1 = __webpack_require__(/*! ../data/trim.js */ "../../node_modules/viem/_cjs/utils/data/trim.js");
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
function decodeAbiParameters(params, data) {
    if (data === '0x' && params.length > 0)
        throw new abi_js_1.AbiDecodingZeroDataError();
    if ((0, size_js_1.size)(data) && (0, size_js_1.size)(data) < 32)
        throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
            data,
            params: params,
            size: (0, size_js_1.size)(data),
        });
    return decodeParams({
        data,
        params: params,
    });
}
exports.decodeAbiParameters = decodeAbiParameters;
function decodeParams({ data, params, }) {
    const decodedValues = [];
    let position = 0;
    for (let i = 0; i < params.length; i++) {
        if (position >= (0, size_js_1.size)(data))
            throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
                data,
                params,
                size: (0, size_js_1.size)(data),
            });
        const param = params[i];
        const { consumed, value } = decodeParam({ data, param, position });
        decodedValues.push(value);
        position += consumed;
    }
    return decodedValues;
}
function decodeParam({ data, param, position, }) {
    const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return decodeArray(data, {
            length,
            param: { ...param, type: type },
            position,
        });
    }
    if (param.type === 'tuple') {
        return decodeTuple(data, { param: param, position });
    }
    if (param.type === 'string') {
        return decodeString(data, { position });
    }
    if (param.type.startsWith('bytes')) {
        return decodeBytes(data, { param, position });
    }
    const value = (0, slice_js_1.slice)(data, position, position + 32, { strict: true });
    if (param.type.startsWith('uint') || param.type.startsWith('int')) {
        return decodeNumber(value, { param });
    }
    if (param.type === 'address') {
        return decodeAddress(value);
    }
    if (param.type === 'bool') {
        return decodeBool(value);
    }
    throw new abi_js_1.InvalidAbiDecodingTypeError(param.type, {
        docsPath: '/docs/contract/decodeAbiParameters',
    });
}
function decodeAddress(value) {
    return { consumed: 32, value: (0, getAddress_js_1.checksumAddress)((0, slice_js_1.slice)(value, -20)) };
}
function decodeArray(data, { param, length, position, }) {
    if (!length) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
        let consumed = 0;
        const value = [];
        for (let i = 0; i < length; ++i) {
            const decodedChild = decodeParam({
                data: (0, slice_js_1.slice)(data, offset + 32),
                param,
                position: consumed,
            });
            consumed += decodedChild.consumed;
            value.push(decodedChild.value);
        }
        return { value, consumed: 32 };
    }
    if (hasDynamicChild(param)) {
        const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
        const dynamicChild = !arrayComponents?.[0];
        let consumed = 0;
        const value = [];
        for (let i = 0; i < length; ++i) {
            const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
            const decodedChild = decodeParam({
                data: (0, slice_js_1.slice)(data, offset),
                param,
                position: dynamicChild ? consumed : i * 32,
            });
            consumed += decodedChild.consumed;
            value.push(decodedChild.value);
        }
        return { value, consumed: 32 };
    }
    let consumed = 0;
    const value = [];
    for (let i = 0; i < length; ++i) {
        const decodedChild = decodeParam({
            data,
            param,
            position: position + consumed,
        });
        consumed += decodedChild.consumed;
        value.push(decodedChild.value);
    }
    return { value, consumed };
}
function decodeBool(value) {
    return { consumed: 32, value: (0, fromHex_js_1.hexToBool)(value) };
}
function decodeBytes(data, { param, position }) {
    const [_, size] = param.type.split('bytes');
    if (!size) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
        if (length === 0)
            return { consumed: 32, value: '0x' };
        const value = (0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, {
            strict: true,
        });
        return { consumed: 32, value };
    }
    const value = (0, slice_js_1.slice)(data, position, position + parseInt(size), {
        strict: true,
    });
    return { consumed: 32, value };
}
function decodeNumber(value, { param }) {
    const signed = param.type.startsWith('int');
    const size = parseInt(param.type.split('int')[1] || '256');
    return {
        consumed: 32,
        value: size > 48
            ? (0, fromHex_js_1.hexToBigInt)(value, { signed })
            : (0, fromHex_js_1.hexToNumber)(value, { signed }),
    };
}
function decodeString(data, { position }) {
    const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
    const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
    if (length === 0)
        return { consumed: 32, value: '' };
    const value = (0, fromHex_js_1.hexToString)((0, trim_js_1.trim)((0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, { strict: true })));
    return { consumed: 32, value };
}
function decodeTuple(data, { param, position }) {
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild(param)) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        for (let i = 0; i < param.components.length; ++i) {
            const component = param.components[i];
            const decodedChild = decodeParam({
                data: (0, slice_js_1.slice)(data, offset),
                param: component,
                position: consumed,
            });
            consumed += decodedChild.consumed;
            value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
        }
        return { consumed: 32, value };
    }
    for (let i = 0; i < param.components.length; ++i) {
        const component = param.components[i];
        const decodedChild = decodeParam({
            data,
            param: component,
            position: position + consumed,
        });
        consumed += decodedChild.consumed;
        value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
    }
    return { consumed, value };
}
function hasDynamicChild(param) {
    const { type } = param;
    if (type === 'string')
        return true;
    if (type === 'bytes')
        return true;
    if (type.endsWith('[]'))
        return true;
    if (type === 'tuple')
        return param.components?.some(hasDynamicChild);
    const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
    if (arrayComponents &&
        hasDynamicChild({ ...param, type: arrayComponents[1] }))
        return true;
    return false;
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/decodeDeployData.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/decodeDeployData.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeDeployData = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const decodeAbiParameters_js_1 = __webpack_require__(/*! ./decodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
const docsPath = '/docs/contract/decodeDeployData';
function decodeDeployData({ abi, bytecode, data, }) {
    if (data === bytecode)
        return { bytecode };
    const description = abi.find((x) => 'type' in x && x.type === 'constructor');
    if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
    if (!('inputs' in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
    if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
    const args = (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, `0x${data.replace(bytecode, '')}`);
    return { args, bytecode };
}
exports.decodeDeployData = decodeDeployData;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/decodeErrorResult.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/decodeErrorResult.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeErrorResult = void 0;
const solidity_js_1 = __webpack_require__(/*! ../../constants/solidity.js */ "../../node_modules/viem/_cjs/constants/solidity.js");
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "../../node_modules/viem/_cjs/utils/data/slice.js");
const getFunctionSelector_js_1 = __webpack_require__(/*! ../hash/getFunctionSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getFunctionSelector.js");
const decodeAbiParameters_js_1 = __webpack_require__(/*! ./decodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
function decodeErrorResult({ abi, data, }) {
    const signature = (0, slice_js_1.slice)(data, 0, 4);
    if (signature === '0x')
        throw new abi_js_1.AbiDecodingZeroDataError();
    const abi_ = [...(abi || []), solidity_js_1.solidityError, solidity_js_1.solidityPanic];
    const abiItem = abi_.find((x) => x.type === 'error' && signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
    if (!abiItem)
        throw new abi_js_1.AbiErrorSignatureNotFoundError(signature, {
            docsPath: '/docs/contract/decodeErrorResult',
        });
    return {
        abiItem,
        args: ('inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0
            ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.inputs, (0, slice_js_1.slice)(data, 4))
            : undefined),
        errorName: abiItem.name,
    };
}
exports.decodeErrorResult = decodeErrorResult;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/decodeEventLog.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/decodeEventLog.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeEventLog = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const getEventSelector_js_1 = __webpack_require__(/*! ../hash/getEventSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getEventSelector.js");
const decodeAbiParameters_js_1 = __webpack_require__(/*! ./decodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const docsPath = '/docs/contract/decodeEventLog';
function decodeEventLog({ abi, data, strict: strict_, topics, }) {
    const strict = strict_ ?? true;
    const [signature, ...argTopics] = topics;
    if (!signature)
        throw new abi_js_1.AbiEventSignatureEmptyTopicsError({
            docsPath,
        });
    const abiItem = abi.find((x) => x.type === 'event' &&
        signature === (0, getEventSelector_js_1.getEventSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
    if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')
        throw new abi_js_1.AbiEventSignatureNotFoundError(signature, {
            docsPath,
        });
    const { name, inputs } = abiItem;
    const isUnnamed = inputs?.some((x) => !('name' in x && x.name));
    let args = isUnnamed ? [] : {};
    const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed);
    for (let i = 0; i < indexedInputs.length; i++) {
        const param = indexedInputs[i];
        const topic = argTopics[i];
        if (!topic)
            throw new abi_js_1.DecodeLogTopicsMismatch({
                abiItem,
                param: param,
            });
        args[param.name || i] = decodeTopic({ param, value: topic });
    }
    const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed));
    if (nonIndexedInputs.length > 0) {
        if (data && data !== '0x') {
            try {
                const decodedData = (0, decodeAbiParameters_js_1.decodeAbiParameters)(nonIndexedInputs, data);
                if (decodedData) {
                    if (isUnnamed)
                        args = [...args, ...decodedData];
                    else {
                        for (let i = 0; i < nonIndexedInputs.length; i++) {
                            args[nonIndexedInputs[i].name] = decodedData[i];
                        }
                    }
                }
            }
            catch (err) {
                if (strict) {
                    if (err instanceof abi_js_1.AbiDecodingDataSizeTooSmallError)
                        throw new abi_js_1.DecodeLogDataMismatch({
                            abiItem,
                            data: err.data,
                            params: err.params,
                            size: err.size,
                        });
                    throw err;
                }
            }
        }
        else if (strict) {
            throw new abi_js_1.DecodeLogDataMismatch({
                abiItem,
                data: '0x',
                params: nonIndexedInputs,
                size: 0,
            });
        }
    }
    return {
        eventName: name,
        args: Object.values(args).length > 0 ? args : undefined,
    };
}
exports.decodeEventLog = decodeEventLog;
function decodeTopic({ param, value }) {
    if (param.type === 'string' ||
        param.type === 'bytes' ||
        param.type === 'tuple' ||
        param.type.match(/^(.*)\[(\d+)?\]$/))
        return value;
    const decodedArg = (0, decodeAbiParameters_js_1.decodeAbiParameters)([param], value) || [];
    return decodedArg[0];
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionData.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/decodeFunctionData.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeFunctionData = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "../../node_modules/viem/_cjs/utils/data/slice.js");
const getFunctionSelector_js_1 = __webpack_require__(/*! ../hash/getFunctionSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getFunctionSelector.js");
const decodeAbiParameters_js_1 = __webpack_require__(/*! ./decodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
function decodeFunctionData({ abi, data, }) {
    const signature = (0, slice_js_1.slice)(data, 0, 4);
    const description = abi.find((x) => x.type === 'function' &&
        signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
    if (!description)
        throw new abi_js_1.AbiFunctionSignatureNotFoundError(signature, {
            docsPath: '/docs/contract/decodeFunctionData',
        });
    return {
        functionName: description.name,
        args: ('inputs' in description &&
            description.inputs &&
            description.inputs.length > 0
            ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, (0, slice_js_1.slice)(data, 4))
            : undefined),
    };
}
exports.decodeFunctionData = decodeFunctionData;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeFunctionResult = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const decodeAbiParameters_js_1 = __webpack_require__(/*! ./decodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
const getAbiItem_js_1 = __webpack_require__(/*! ./getAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const docsPath = '/docs/contract/decodeFunctionResult';
function decodeFunctionResult({ abi, args, functionName, data, }) {
    let abiItem = abi[0];
    if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
            abi,
            args,
            name: functionName,
        });
        if (!abiItem)
            throw new abi_js_1.AbiFunctionNotFoundError(functionName, { docsPath });
    }
    if (abiItem.type !== 'function')
        throw new abi_js_1.AbiFunctionNotFoundError(undefined, { docsPath });
    if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
    const values = (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.outputs, data);
    if (values && values.length > 1)
        return values;
    if (values && values.length === 1)
        return values[0];
    return undefined;
}
exports.decodeFunctionResult = decodeFunctionResult;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getArrayComponents = exports.encodeAbiParameters = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "../../node_modules/viem/_cjs/utils/data/pad.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "../../node_modules/viem/_cjs/utils/data/size.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "../../node_modules/viem/_cjs/utils/data/slice.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
function encodeAbiParameters(params, values) {
    if (params.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
            expectedLength: params.length,
            givenLength: values.length,
        });
    const preparedParams = prepareParams({
        params: params,
        values,
    });
    const data = encodeParams(preparedParams);
    if (data.length === 0)
        return '0x';
    return data;
}
exports.encodeAbiParameters = encodeAbiParameters;
function prepareParams({ params, values, }) {
    const preparedParams = [];
    for (let i = 0; i < params.length; i++) {
        preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
    }
    return preparedParams;
}
function prepareParam({ param, value, }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return encodeArray(value, { length, param: { ...param, type } });
    }
    if (param.type === 'tuple') {
        return encodeTuple(value, {
            param: param,
        });
    }
    if (param.type === 'address') {
        return encodeAddress(value);
    }
    if (param.type === 'bool') {
        return encodeBool(value);
    }
    if (param.type.startsWith('uint') || param.type.startsWith('int')) {
        const signed = param.type.startsWith('int');
        return encodeNumber(value, { signed });
    }
    if (param.type.startsWith('bytes')) {
        return encodeBytes(value, { param });
    }
    if (param.type === 'string') {
        return encodeString(value);
    }
    throw new abi_js_1.InvalidAbiEncodingTypeError(param.type, {
        docsPath: '/docs/contract/encodeAbiParameters',
    });
}
function encodeParams(preparedParams) {
    let staticSize = 0;
    for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic)
            staticSize += 32;
        else
            staticSize += (0, size_js_1.size)(encoded);
    }
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) {
            staticParams.push((0, toHex_js_1.numberToHex)(staticSize + dynamicSize, { size: 32 }));
            dynamicParams.push(encoded);
            dynamicSize += (0, size_js_1.size)(encoded);
        }
        else {
            staticParams.push(encoded);
        }
    }
    return (0, concat_js_1.concat)([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
    if (!(0, isAddress_js_1.isAddress)(value))
        throw new address_js_1.InvalidAddressError({ address: value });
    return { dynamic: false, encoded: (0, pad_js_1.padHex)(value.toLowerCase()) };
}
function encodeArray(value, { length, param, }) {
    const dynamic = length === null;
    if (!Array.isArray(value))
        throw new abi_js_1.InvalidArrayError(value);
    if (!dynamic && value.length !== length)
        throw new abi_js_1.AbiEncodingArrayLengthMismatchError({
            expectedLength: length,
            givenLength: value.length,
            type: `${param.type}[${length}]`,
        });
    let dynamicChild = false;
    const preparedParams = [];
    for (let i = 0; i < value.length; i++) {
        const preparedParam = prepareParam({ param, value: value[i] });
        if (preparedParam.dynamic)
            dynamicChild = true;
        preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
        const data = encodeParams(preparedParams);
        if (dynamic) {
            const length = (0, toHex_js_1.numberToHex)(preparedParams.length, { size: 32 });
            return {
                dynamic: true,
                encoded: preparedParams.length > 0 ? (0, concat_js_1.concat)([length, data]) : length,
            };
        }
        if (dynamicChild)
            return { dynamic: true, encoded: data };
    }
    return {
        dynamic: false,
        encoded: (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded)),
    };
}
function encodeBytes(value, { param }) {
    const [, paramSize] = param.type.split('bytes');
    const bytesSize = (0, size_js_1.size)(value);
    if (!paramSize) {
        let value_ = value;
        if (bytesSize % 32 !== 0)
            value_ = (0, pad_js_1.padHex)(value_, {
                dir: 'right',
                size: Math.ceil((value.length - 2) / 2 / 32) * 32,
            });
        return {
            dynamic: true,
            encoded: (0, concat_js_1.concat)([(0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)(bytesSize, { size: 32 })), value_]),
        };
    }
    if (bytesSize !== parseInt(paramSize))
        throw new abi_js_1.AbiEncodingBytesSizeMismatchError({
            expectedSize: parseInt(paramSize),
            value,
        });
    return { dynamic: false, encoded: (0, pad_js_1.padHex)(value, { dir: 'right' }) };
}
function encodeBool(value) {
    return { dynamic: false, encoded: (0, pad_js_1.padHex)((0, toHex_js_1.boolToHex)(value)) };
}
function encodeNumber(value, { signed }) {
    return {
        dynamic: false,
        encoded: (0, toHex_js_1.numberToHex)(value, {
            size: 32,
            signed,
        }),
    };
}
function encodeString(value) {
    const hexValue = (0, toHex_js_1.stringToHex)(value);
    const partsLength = Math.ceil((0, size_js_1.size)(hexValue) / 32);
    const parts = [];
    for (let i = 0; i < partsLength; i++) {
        parts.push((0, pad_js_1.padHex)((0, slice_js_1.slice)(hexValue, i * 32, (i + 1) * 32), {
            dir: 'right',
        }));
    }
    return {
        dynamic: true,
        encoded: (0, concat_js_1.concat)([
            (0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)((0, size_js_1.size)(hexValue), { size: 32 })),
            ...parts,
        ]),
    };
}
function encodeTuple(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for (let i = 0; i < param.components.length; i++) {
        const param_ = param.components[i];
        const index = Array.isArray(value) ? i : param_.name;
        const preparedParam = prepareParam({
            param: param_,
            value: value[index],
        });
        preparedParams.push(preparedParam);
        if (preparedParam.dynamic)
            dynamic = true;
    }
    return {
        dynamic,
        encoded: dynamic
            ? encodeParams(preparedParams)
            : (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded)),
    };
}
function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches
        ?
            [matches[2] ? Number(matches[2]) : null, matches[1]]
        : undefined;
}
exports.getArrayComponents = getArrayComponents;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/encodeDeployData.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/encodeDeployData.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeDeployData = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const docsPath = '/docs/contract/encodeDeployData';
function encodeDeployData({ abi, args, bytecode, }) {
    if (!args || args.length === 0)
        return bytecode;
    const description = abi.find((x) => 'type' in x && x.type === 'constructor');
    if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
    if (!('inputs' in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
    if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
    const data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(description.inputs, args);
    return (0, concat_js_1.concatHex)([bytecode, data]);
}
exports.encodeDeployData = encodeDeployData;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/encodeErrorResult.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/encodeErrorResult.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeErrorResult = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const getFunctionSelector_js_1 = __webpack_require__(/*! ../hash/getFunctionSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getFunctionSelector.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const getAbiItem_js_1 = __webpack_require__(/*! ./getAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const docsPath = '/docs/contract/encodeErrorResult';
function encodeErrorResult({ abi, errorName, args }) {
    let abiItem = abi[0];
    if (errorName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
            abi,
            args,
            name: errorName,
        });
        if (!abiItem)
            throw new abi_js_1.AbiErrorNotFoundError(errorName, { docsPath });
    }
    if (abiItem.type !== 'error')
        throw new abi_js_1.AbiErrorNotFoundError(undefined, { docsPath });
    const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
    const signature = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
    let data = '0x';
    if (args && args.length > 0) {
        if (!abiItem.inputs)
            throw new abi_js_1.AbiErrorInputsNotFoundError(abiItem.name, { docsPath });
        data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args);
    }
    return (0, concat_js_1.concatHex)([signature, data]);
}
exports.encodeErrorResult = encodeErrorResult;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/encodeEventTopics.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/encodeEventTopics.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeEventTopics = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const log_js_1 = __webpack_require__(/*! ../../errors/log.js */ "../../node_modules/viem/_cjs/errors/log.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const getEventSelector_js_1 = __webpack_require__(/*! ../hash/getEventSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getEventSelector.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const getAbiItem_js_1 = __webpack_require__(/*! ./getAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/getAbiItem.js");
function encodeEventTopics({ abi, eventName, args }) {
    let abiItem = abi[0];
    if (eventName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
            abi,
            args,
            name: eventName,
        });
        if (!abiItem)
            throw new abi_js_1.AbiEventNotFoundError(eventName, {
                docsPath: '/docs/contract/encodeEventTopics',
            });
    }
    if (abiItem.type !== 'event')
        throw new abi_js_1.AbiEventNotFoundError(undefined, {
            docsPath: '/docs/contract/encodeEventTopics',
        });
    const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
    const signature = (0, getEventSelector_js_1.getEventSelector)(definition);
    let topics = [];
    if (args && 'inputs' in abiItem) {
        const indexedInputs = abiItem.inputs?.filter((param) => 'indexed' in param && param.indexed);
        const args_ = Array.isArray(args)
            ? args
            : Object.values(args).length > 0
                ? indexedInputs?.map((x) => args[x.name]) ?? []
                : [];
        if (args_.length > 0) {
            topics =
                indexedInputs?.map((param, i) => Array.isArray(args_[i])
                    ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }))
                    : args_[i]
                        ? encodeArg({ param, value: args_[i] })
                        : null) ?? [];
        }
    }
    return [signature, ...topics];
}
exports.encodeEventTopics = encodeEventTopics;
function encodeArg({ param, value, }) {
    if (param.type === 'string' || param.type === 'bytes')
        return (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
    if (param.type === 'tuple' || param.type.match(/^(.*)\[(\d+)?\]$/))
        throw new log_js_1.FilterTypeNotSupportedError(param.type);
    return (0, encodeAbiParameters_js_1.encodeAbiParameters)([param], [value]);
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeFunctionData = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const getFunctionSelector_js_1 = __webpack_require__(/*! ../hash/getFunctionSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getFunctionSelector.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const getAbiItem_js_1 = __webpack_require__(/*! ./getAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/getAbiItem.js");
function encodeFunctionData({ abi, args, functionName, }) {
    let abiItem = abi[0];
    if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
            abi,
            args,
            name: functionName,
        });
        if (!abiItem)
            throw new abi_js_1.AbiFunctionNotFoundError(functionName, {
                docsPath: '/docs/contract/encodeFunctionData',
            });
    }
    if (abiItem.type !== 'function')
        throw new abi_js_1.AbiFunctionNotFoundError(undefined, {
            docsPath: '/docs/contract/encodeFunctionData',
        });
    const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
    const signature = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
    const data = 'inputs' in abiItem && abiItem.inputs
        ? (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, (args ?? []))
        : undefined;
    return (0, concat_js_1.concatHex)([signature, data ?? '0x']);
}
exports.encodeFunctionData = encodeFunctionData;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeFunctionResult = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const getAbiItem_js_1 = __webpack_require__(/*! ./getAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const docsPath = '/docs/contract/encodeFunctionResult';
function encodeFunctionResult({ abi, functionName, result, }) {
    let abiItem = abi[0];
    if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
            abi,
            name: functionName,
        });
        if (!abiItem)
            throw new abi_js_1.AbiFunctionNotFoundError(functionName, {
                docsPath: '/docs/contract/encodeFunctionResult',
            });
    }
    if (abiItem.type !== 'function')
        throw new abi_js_1.AbiFunctionNotFoundError(undefined, {
            docsPath: '/docs/contract/encodeFunctionResult',
        });
    if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
    let values = Array.isArray(result) ? result : [result];
    if (abiItem.outputs.length === 0 && !values[0])
        values = [];
    return (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.outputs, values);
}
exports.encodeFunctionResult = encodeFunctionResult;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/encodePacked.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/encodePacked.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodePacked = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "../../node_modules/viem/_cjs/utils/data/pad.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const regex_js_1 = __webpack_require__(/*! ../regex.js */ "../../node_modules/viem/_cjs/utils/regex.js");
function encodePacked(types, values) {
    if (types.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
            expectedLength: types.length,
            givenLength: values.length,
        });
    const data = [];
    for (let i = 0; i < types.length; i++) {
        const type = types[i];
        const value = values[i];
        data.push(encode(type, value));
    }
    return (0, concat_js_1.concatHex)(data);
}
exports.encodePacked = encodePacked;
function encode(type, value, isArray = false) {
    if (type === 'address') {
        const address = value;
        if (!(0, isAddress_js_1.isAddress)(address))
            throw new address_js_1.InvalidAddressError({ address });
        return (0, pad_js_1.pad)(address.toLowerCase(), {
            size: isArray ? 32 : null,
        });
    }
    if (type === 'string')
        return (0, toHex_js_1.stringToHex)(value);
    if (type === 'bytes')
        return value;
    if (type === 'bool')
        return (0, pad_js_1.pad)((0, toHex_js_1.boolToHex)(value), { size: isArray ? 32 : 1 });
    const intMatch = type.match(regex_js_1.integerRegex);
    if (intMatch) {
        const [_type, baseType, bits = '256'] = intMatch;
        const size = parseInt(bits) / 8;
        return (0, toHex_js_1.numberToHex)(value, {
            size: isArray ? 32 : size,
            signed: baseType === 'int',
        });
    }
    const bytesMatch = type.match(regex_js_1.bytesRegex);
    if (bytesMatch) {
        const [_type, size] = bytesMatch;
        if (parseInt(size) !== (value.length - 2) / 2)
            throw new abi_js_1.BytesSizeMismatchError({
                expectedSize: parseInt(size),
                givenSize: (value.length - 2) / 2,
            });
        return (0, pad_js_1.pad)(value, { dir: 'right', size: isArray ? 32 : null });
    }
    const arrayMatch = type.match(regex_js_1.arrayRegex);
    if (arrayMatch && Array.isArray(value)) {
        const [_type, childType] = arrayMatch;
        const data = [];
        for (let i = 0; i < value.length; i++) {
            data.push(encode(childType, value[i], true));
        }
        if (data.length === 0)
            return '0x';
        return (0, concat_js_1.concatHex)(data);
    }
    throw new abi_js_1.UnsupportedPackedAbiType(type);
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/formatAbiItem.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/formatAbiItem.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbiParams = exports.formatAbiItem = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
function formatAbiItem(abiItem, { includeName = false } = {}) {
    if (abiItem.type !== 'function' &&
        abiItem.type !== 'event' &&
        abiItem.type !== 'error')
        throw new abi_js_1.InvalidDefinitionTypeError(abiItem.type);
    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
exports.formatAbiItem = formatAbiItem;
function formatAbiParams(params, { includeName = false } = {}) {
    if (!params)
        return '';
    return params
        .map((param) => formatAbiParam(param, { includeName }))
        .join(includeName ? ', ' : ',');
}
exports.formatAbiParams = formatAbiParams;
function formatAbiParam(param, { includeName }) {
    if (param.type.startsWith('tuple')) {
        return `(${formatAbiParams(param.components, { includeName })})${param.type.slice('tuple'.length)}`;
    }
    return param.type + (includeName && param.name ? ` ${param.name}` : '');
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbiItemWithArgs = void 0;
const stringify_js_1 = __webpack_require__(/*! ../stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false, }) {
    if (!('name' in abiItem))
        return;
    if (!('inputs' in abiItem))
        return;
    if (!abiItem.inputs)
        return;
    return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs
        .map((input, i) => `${includeName && input.name ? `${input.name}: ` : ''}${typeof args[i] === 'object' ? (0, stringify_js_1.stringify)(args[i]) : args[i]}`)
        .join(', ')})`;
}
exports.formatAbiItemWithArgs = formatAbiItemWithArgs;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/abi/getAbiItem.js":
/*!************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/abi/getAbiItem.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAmbiguousTypes = exports.isArgOfType = exports.getAbiItem = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const isHex_js_1 = __webpack_require__(/*! ../../utils/data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
const getEventSelector_js_1 = __webpack_require__(/*! ../../utils/hash/getEventSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getEventSelector.js");
const getFunctionSelector_js_1 = __webpack_require__(/*! ../../utils/hash/getFunctionSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getFunctionSelector.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
function getAbiItem({ abi, args = [], name, }) {
    const isSelector = (0, isHex_js_1.isHex)(name, { strict: false });
    const abiItems = abi.filter((abiItem) => {
        if (isSelector) {
            if (abiItem.type === 'function')
                return (0, getFunctionSelector_js_1.getFunctionSelector)(abiItem) === name;
            if (abiItem.type === 'event')
                return (0, getEventSelector_js_1.getEventSelector)(abiItem) === name;
            return false;
        }
        return 'name' in abiItem && abiItem.name === name;
    });
    if (abiItems.length === 0)
        return undefined;
    if (abiItems.length === 1)
        return abiItems[0];
    let matchedAbiItem = undefined;
    for (const abiItem of abiItems) {
        if (!('inputs' in abiItem))
            continue;
        if (!args || args.length === 0) {
            if (!abiItem.inputs || abiItem.inputs.length === 0)
                return abiItem;
            continue;
        }
        if (!abiItem.inputs)
            continue;
        if (abiItem.inputs.length === 0)
            continue;
        if (abiItem.inputs.length !== args.length)
            continue;
        const matched = args.every((arg, index) => {
            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];
            if (!abiParameter)
                return false;
            return isArgOfType(arg, abiParameter);
        });
        if (matched) {
            if (matchedAbiItem &&
                'inputs' in matchedAbiItem &&
                matchedAbiItem.inputs) {
                const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
                if (ambiguousTypes)
                    throw new abi_js_1.AbiItemAmbiguityError({
                        abiItem,
                        type: ambiguousTypes[0],
                    }, {
                        abiItem: matchedAbiItem,
                        type: ambiguousTypes[1],
                    });
            }
            matchedAbiItem = abiItem;
        }
    }
    if (matchedAbiItem)
        return matchedAbiItem;
    return abiItems[0];
}
exports.getAbiItem = getAbiItem;
function isArgOfType(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch (abiParameterType) {
        case 'address':
            return (0, isAddress_js_1.isAddress)(arg);
        case 'bool':
            return argType === 'boolean';
        case 'function':
            return argType === 'string';
        case 'string':
            return argType === 'string';
        default: {
            if (abiParameterType === 'tuple' && 'components' in abiParameter)
                return Object.values(abiParameter.components).every((component, index) => {
                    return isArgOfType(Object.values(arg)[index], component);
                });
            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
                return argType === 'number' || argType === 'bigint';
            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
                return argType === 'string' || arg instanceof Uint8Array;
            if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
                return (Array.isArray(arg) &&
                    arg.every((x) => isArgOfType(x, {
                        ...abiParameter,
                        type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, ''),
                    })));
            }
            return false;
        }
    }
}
exports.isArgOfType = isArgOfType;
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
    for (const parameterIndex in sourceParameters) {
        const sourceParameter = sourceParameters[parameterIndex];
        const targetParameter = targetParameters[parameterIndex];
        if (sourceParameter.type === 'tuple' &&
            targetParameter.type === 'tuple' &&
            'components' in sourceParameter &&
            'components' in targetParameter)
            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
        const types = [sourceParameter.type, targetParameter.type];
        const ambiguous = (() => {
            if (types.includes('address') && types.includes('bytes20'))
                return true;
            if (types.includes('address') && types.includes('string'))
                return (0, isAddress_js_1.isAddress)(args[parameterIndex]);
            if (types.includes('address') && types.includes('bytes'))
                return (0, isAddress_js_1.isAddress)(args[parameterIndex]);
            return false;
        })();
        if (ambiguous)
            return types;
    }
    return;
}
exports.getAmbiguousTypes = getAmbiguousTypes;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/accounts.js":
/*!******************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/accounts.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.publicKeyToAddress = exports.parseAccount = void 0;
var parseAccount_js_1 = __webpack_require__(/*! ../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
Object.defineProperty(exports, "parseAccount", ({ enumerable: true, get: function () { return parseAccount_js_1.parseAccount; } }));
var publicKeyToAddress_js_1 = __webpack_require__(/*! ../accounts/utils/publicKeyToAddress.js */ "../../node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js");
Object.defineProperty(exports, "publicKeyToAddress", ({ enumerable: true, get: function () { return publicKeyToAddress_js_1.publicKeyToAddress; } }));


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/address/getAddress.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/address/getAddress.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAddress = exports.checksumAddress = void 0;
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
const isAddress_js_1 = __webpack_require__(/*! ./isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
function checksumAddress(address_, chainId) {
    const hexAddress = chainId
        ? `${chainId}${address_.toLowerCase()}`
        : address_.substring(2).toLowerCase();
    const hash = (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(hexAddress), 'bytes');
    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');
    for (let i = 0; i < 40; i += 2) {
        if (hash[i >> 1] >> 4 >= 8 && address[i]) {
            address[i] = address[i].toUpperCase();
        }
        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
            address[i + 1] = address[i + 1].toUpperCase();
        }
    }
    return `0x${address.join('')}`;
}
exports.checksumAddress = checksumAddress;
function getAddress(address, chainId) {
    if (!(0, isAddress_js_1.isAddress)(address))
        throw new address_js_1.InvalidAddressError({ address });
    return checksumAddress(address, chainId);
}
exports.getAddress = getAddress;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/address/getContractAddress.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/address/getContractAddress.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = void 0;
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const isBytes_js_1 = __webpack_require__(/*! ../data/isBytes.js */ "../../node_modules/viem/_cjs/utils/data/isBytes.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "../../node_modules/viem/_cjs/utils/data/pad.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "../../node_modules/viem/_cjs/utils/data/slice.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toRlp_js_1 = __webpack_require__(/*! ../encoding/toRlp.js */ "../../node_modules/viem/_cjs/utils/encoding/toRlp.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
const getAddress_js_1 = __webpack_require__(/*! ./getAddress.js */ "../../node_modules/viem/_cjs/utils/address/getAddress.js");
function getContractAddress(opts) {
    if (opts.opcode === 'CREATE2')
        return getCreate2Address(opts);
    return getCreateAddress(opts);
}
exports.getContractAddress = getContractAddress;
function getCreateAddress(opts) {
    const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
    let nonce = (0, toBytes_js_1.toBytes)(opts.nonce);
    if (nonce[0] === 0)
        nonce = new Uint8Array([]);
    return (0, getAddress_js_1.getAddress)(`0x${(0, keccak256_js_1.keccak256)((0, toRlp_js_1.toRlp)([from, nonce], 'bytes')).slice(26)}`);
}
exports.getCreateAddress = getCreateAddress;
function getCreate2Address(opts) {
    const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
    const salt = (0, pad_js_1.pad)((0, isBytes_js_1.isBytes)(opts.salt) ? opts.salt : (0, toBytes_js_1.toBytes)(opts.salt), {
        size: 32,
    });
    const bytecodeHash = (() => {
        if ('bytecodeHash' in opts) {
            if ((0, isBytes_js_1.isBytes)(opts.bytecodeHash))
                return opts.bytecodeHash;
            return (0, toBytes_js_1.toBytes)(opts.bytecodeHash);
        }
        return (0, keccak256_js_1.keccak256)(opts.bytecode, 'bytes');
    })();
    return (0, getAddress_js_1.getAddress)((0, slice_js_1.slice)((0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([(0, toBytes_js_1.toBytes)('0xff'), from, salt, bytecodeHash])), 12));
}
exports.getCreate2Address = getCreate2Address;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/address/isAddress.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/address/isAddress.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isAddress = void 0;
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
function isAddress(address) {
    return addressRegex.test(address);
}
exports.isAddress = isAddress;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/address/isAddressEqual.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/address/isAddressEqual.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isAddressEqual = void 0;
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
const isAddress_js_1 = __webpack_require__(/*! ./isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
function isAddressEqual(a, b) {
    if (!(0, isAddress_js_1.isAddress)(a))
        throw new address_js_1.InvalidAddressError({ address: a });
    if (!(0, isAddress_js_1.isAddress)(b))
        throw new address_js_1.InvalidAddressError({ address: b });
    return a.toLowerCase() === b.toLowerCase();
}
exports.isAddressEqual = isAddressEqual;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/buildRequest.js":
/*!**********************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/buildRequest.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildRequest = exports.isDeterministicError = void 0;
const base_js_1 = __webpack_require__(/*! ../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const request_js_1 = __webpack_require__(/*! ../errors/request.js */ "../../node_modules/viem/_cjs/errors/request.js");
const rpc_js_1 = __webpack_require__(/*! ../errors/rpc.js */ "../../node_modules/viem/_cjs/errors/rpc.js");
const withRetry_js_1 = __webpack_require__(/*! ./promise/withRetry.js */ "../../node_modules/viem/_cjs/utils/promise/withRetry.js");
const isDeterministicError = (error) => {
    if ('code' in error)
        return (error.code !== -1 &&
            error.code !== -32004 &&
            error.code !== -32005 &&
            error.code !== -32042 &&
            error.code !== -32603);
    if (error instanceof request_js_1.HttpRequestError && error.status)
        return (error.status !== 403 &&
            error.status !== 408 &&
            error.status !== 413 &&
            error.status !== 429 &&
            error.status !== 500 &&
            error.status !== 502 &&
            error.status !== 503 &&
            error.status !== 504);
    return false;
};
exports.isDeterministicError = isDeterministicError;
function buildRequest(request, { retryDelay = 150, retryCount = 3, } = {}) {
    return (async (args) => (0, withRetry_js_1.withRetry)(async () => {
        try {
            return await request(args);
        }
        catch (err_) {
            const err = err_;
            switch (err.code) {
                case rpc_js_1.ParseRpcError.code:
                    throw new rpc_js_1.ParseRpcError(err);
                case rpc_js_1.InvalidRequestRpcError.code:
                    throw new rpc_js_1.InvalidRequestRpcError(err);
                case rpc_js_1.MethodNotFoundRpcError.code:
                    throw new rpc_js_1.MethodNotFoundRpcError(err);
                case rpc_js_1.InvalidParamsRpcError.code:
                    throw new rpc_js_1.InvalidParamsRpcError(err);
                case rpc_js_1.InternalRpcError.code:
                    throw new rpc_js_1.InternalRpcError(err);
                case rpc_js_1.InvalidInputRpcError.code:
                    throw new rpc_js_1.InvalidInputRpcError(err);
                case rpc_js_1.ResourceNotFoundRpcError.code:
                    throw new rpc_js_1.ResourceNotFoundRpcError(err);
                case rpc_js_1.ResourceUnavailableRpcError.code:
                    throw new rpc_js_1.ResourceUnavailableRpcError(err);
                case rpc_js_1.TransactionRejectedRpcError.code:
                    throw new rpc_js_1.TransactionRejectedRpcError(err);
                case rpc_js_1.MethodNotSupportedRpcError.code:
                    throw new rpc_js_1.MethodNotSupportedRpcError(err);
                case rpc_js_1.LimitExceededRpcError.code:
                    throw new rpc_js_1.LimitExceededRpcError(err);
                case rpc_js_1.JsonRpcVersionUnsupportedError.code:
                    throw new rpc_js_1.JsonRpcVersionUnsupportedError(err);
                case rpc_js_1.UserRejectedRequestError.code:
                    throw new rpc_js_1.UserRejectedRequestError(err);
                case rpc_js_1.UnauthorizedProviderError.code:
                    throw new rpc_js_1.UnauthorizedProviderError(err);
                case rpc_js_1.UnsupportedProviderMethodError.code:
                    throw new rpc_js_1.UnsupportedProviderMethodError(err);
                case rpc_js_1.ProviderDisconnectedError.code:
                    throw new rpc_js_1.ProviderDisconnectedError(err);
                case rpc_js_1.ChainDisconnectedError.code:
                    throw new rpc_js_1.ChainDisconnectedError(err);
                case rpc_js_1.SwitchChainError.code:
                    throw new rpc_js_1.SwitchChainError(err);
                case 5000:
                    throw new rpc_js_1.UserRejectedRequestError(err);
                default:
                    if (err_ instanceof base_js_1.BaseError)
                        throw err_;
                    throw new rpc_js_1.UnknownRpcError(err);
            }
        }
    }, {
        delay: ({ count, error }) => {
            if (error && error instanceof request_js_1.HttpRequestError) {
                const retryAfter = error?.headers?.get('Retry-After');
                if (retryAfter?.match(/\d/))
                    return parseInt(retryAfter) * 1000;
            }
            return ~~(1 << count) * retryDelay;
        },
        retryCount,
        shouldRetry: ({ error }) => !(0, exports.isDeterministicError)(error),
    }));
}
exports.buildRequest = buildRequest;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/ccip.js":
/*!**************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/ccip.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ccipFetch = exports.offchainLookup = exports.offchainLookupAbiItem = exports.offchainLookupSignature = void 0;
const call_js_1 = __webpack_require__(/*! ../actions/public/call.js */ "../../node_modules/viem/_cjs/actions/public/call.js");
const ccip_js_1 = __webpack_require__(/*! ../errors/ccip.js */ "../../node_modules/viem/_cjs/errors/ccip.js");
const request_js_1 = __webpack_require__(/*! ../errors/request.js */ "../../node_modules/viem/_cjs/errors/request.js");
const decodeErrorResult_js_1 = __webpack_require__(/*! ./abi/decodeErrorResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeErrorResult.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./abi/encodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ./address/isAddressEqual.js */ "../../node_modules/viem/_cjs/utils/address/isAddressEqual.js");
const concat_js_1 = __webpack_require__(/*! ./data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const isHex_js_1 = __webpack_require__(/*! ./data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
exports.offchainLookupSignature = '0x556f1830';
exports.offchainLookupAbiItem = {
    name: 'OffchainLookup',
    type: 'error',
    inputs: [
        {
            name: 'sender',
            type: 'address',
        },
        {
            name: 'urls',
            type: 'string[]',
        },
        {
            name: 'callData',
            type: 'bytes',
        },
        {
            name: 'callbackFunction',
            type: 'bytes4',
        },
        {
            name: 'extraData',
            type: 'bytes',
        },
    ],
};
async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {
    const { args } = (0, decodeErrorResult_js_1.decodeErrorResult)({
        data,
        abi: [exports.offchainLookupAbiItem],
    });
    const [sender, urls, callData, callbackSelector, extraData] = args;
    try {
        if (!(0, isAddressEqual_js_1.isAddressEqual)(to, sender))
            throw new ccip_js_1.OffchainLookupSenderMismatchError({ sender, to });
        const result = await ccipFetch({ data: callData, sender, urls });
        const { data: data_ } = await (0, call_js_1.call)(client, {
            blockNumber,
            blockTag,
            data: (0, concat_js_1.concat)([
                callbackSelector,
                (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),
            ]),
            to,
        });
        return data_;
    }
    catch (err) {
        throw new ccip_js_1.OffchainLookupError({
            callbackSelector,
            cause: err,
            data,
            extraData,
            sender,
            urls,
        });
    }
}
exports.offchainLookup = offchainLookup;
async function ccipFetch({ data, sender, urls, }) {
    let error = new Error('An unknown error occurred.');
    for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        const method = url.includes('{data}') ? 'GET' : 'POST';
        const body = method === 'POST' ? { data, sender } : undefined;
        try {
            const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {
                body: JSON.stringify(body),
                method,
            });
            let result;
            if (response.headers.get('Content-Type')?.startsWith('application/json')) {
                result = (await response.json()).data;
            }
            else {
                result = (await response.text());
            }
            if (!response.ok) {
                error = new request_js_1.HttpRequestError({
                    body,
                    details: result?.error
                        ? (0, stringify_js_1.stringify)(result.error)
                        : response.statusText,
                    headers: response.headers,
                    status: response.status,
                    url,
                });
                continue;
            }
            if (!(0, isHex_js_1.isHex)(result)) {
                error = new ccip_js_1.OffchainLookupResponseMalformedError({
                    result,
                    url,
                });
                continue;
            }
            return result;
        }
        catch (err) {
            error = new request_js_1.HttpRequestError({
                body,
                details: err.message,
                url,
            });
        }
    }
    throw error;
}
exports.ccipFetch = ccipFetch;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/chain/assertCurrentChain.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/chain/assertCurrentChain.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertCurrentChain = void 0;
const chain_js_1 = __webpack_require__(/*! ../../errors/chain.js */ "../../node_modules/viem/_cjs/errors/chain.js");
function assertCurrentChain({ chain, currentChainId, }) {
    if (!chain)
        throw new chain_js_1.ChainNotFoundError();
    if (currentChainId !== chain.id)
        throw new chain_js_1.ChainMismatchError({ chain, currentChainId });
}
exports.assertCurrentChain = assertCurrentChain;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/chain/defineChain.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/chain/defineChain.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineChain = void 0;
function defineChain(chain, config = {}) {
    const { fees = chain.fees, formatters = chain.formatters, serializers = chain.serializers, } = config;
    return {
        ...chain,
        fees,
        formatters,
        serializers,
    };
}
exports.defineChain = defineChain;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/chain/extractChain.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/chain/extractChain.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractChain = void 0;
function extractChain({ chains, id, }) {
    return chains.find((chain) => chain.id === id);
}
exports.extractChain = extractChain;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/chain/getChainContractAddress.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/chain/getChainContractAddress.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getChainContractAddress = void 0;
const chain_js_1 = __webpack_require__(/*! ../../errors/chain.js */ "../../node_modules/viem/_cjs/errors/chain.js");
function getChainContractAddress({ blockNumber, chain, contract: name, }) {
    const contract = chain?.contracts?.[name];
    if (!contract)
        throw new chain_js_1.ChainDoesNotSupportContract({
            chain,
            contract: { name },
        });
    if (blockNumber &&
        contract.blockCreated &&
        contract.blockCreated > blockNumber)
        throw new chain_js_1.ChainDoesNotSupportContract({
            blockNumber,
            chain,
            contract: {
                name,
                blockCreated: contract.blockCreated,
            },
        });
    return contract.address;
}
exports.getChainContractAddress = getChainContractAddress;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/contract/extractFunctionParts.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/contract/extractFunctionParts.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractFunctionType = exports.extractFunctionParams = exports.extractFunctionName = exports.extractFunctionParts = void 0;
const paramsRegex = /((function|event)\s)?(.*)(\((.*)\))/;
function extractFunctionParts(def) {
    const parts = def.match(paramsRegex);
    const type = parts?.[2] || undefined;
    const name = parts?.[3];
    const params = parts?.[5] || undefined;
    return { type, name, params };
}
exports.extractFunctionParts = extractFunctionParts;
function extractFunctionName(def) {
    return extractFunctionParts(def).name;
}
exports.extractFunctionName = extractFunctionName;
function extractFunctionParams(def) {
    const params = extractFunctionParts(def).params;
    const splitParams = params?.split(',').map((x) => x.trim().split(' '));
    return splitParams?.map((param) => ({
        type: param[0],
        name: param[1] === 'indexed' ? param[2] : param[1],
        ...(param[1] === 'indexed' ? { indexed: true } : {}),
    }));
}
exports.extractFunctionParams = extractFunctionParams;
function extractFunctionType(def) {
    return extractFunctionParts(def).type;
}
exports.extractFunctionType = extractFunctionType;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/cursor.js":
/*!****************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/cursor.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createCursor = void 0;
const cursor_js_1 = __webpack_require__(/*! ../errors/cursor.js */ "../../node_modules/viem/_cjs/errors/cursor.js");
const staticCursor = {
    bytes: new Uint8Array(),
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    assertPosition(position) {
        if (position < 0 || position > this.bytes.length - 1)
            throw new cursor_js_1.PositionOutOfBoundsError({
                length: this.bytes.length,
                position,
            });
    },
    decrementPosition(offset) {
        if (offset < 0)
            throw new cursor_js_1.NegativeOffsetError({ offset });
        const position = this.position - offset;
        this.assertPosition(position);
        this.position = position;
    },
    incrementPosition(offset) {
        if (offset < 0)
            throw new cursor_js_1.NegativeOffsetError({ offset });
        const position = this.position + offset;
        this.assertPosition(position);
        this.position = position;
    },
    inspectByte(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
    },
    inspectBytes(length, position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + length - 1);
        return this.bytes.subarray(position, position + length);
    },
    inspectUint8(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
    },
    inspectUint16(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 1);
        return this.dataView.getUint16(position);
    },
    inspectUint24(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 2);
        return ((this.dataView.getUint16(position) << 8) +
            this.dataView.getUint8(position + 2));
    },
    inspectUint32(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 3);
        return this.dataView.getUint32(position);
    },
    pushByte(byte) {
        this.assertPosition(this.position);
        this.bytes[this.position] = byte;
        this.position++;
    },
    pushBytes(bytes) {
        this.assertPosition(this.position + bytes.length - 1);
        this.bytes.set(bytes, this.position);
        this.position += bytes.length;
    },
    pushUint8(value) {
        this.assertPosition(this.position);
        this.bytes[this.position] = value;
        this.position++;
    },
    pushUint16(value) {
        this.assertPosition(this.position + 1);
        this.dataView.setUint16(this.position, value);
        this.position += 2;
    },
    pushUint24(value) {
        this.assertPosition(this.position + 2);
        this.dataView.setUint16(this.position, value >> 8);
        this.dataView.setUint8(this.position + 2, value & ~4294967040);
        this.position += 3;
    },
    pushUint32(value) {
        this.assertPosition(this.position + 3);
        this.dataView.setUint32(this.position, value);
        this.position += 4;
    },
    readByte() {
        const value = this.inspectByte();
        this.position++;
        return value;
    },
    readBytes(length) {
        const value = this.inspectBytes(length);
        this.position += length;
        return value;
    },
    readUint8() {
        const value = this.inspectUint8();
        this.position += 1;
        return value;
    },
    readUint16() {
        const value = this.inspectUint16();
        this.position += 2;
        return value;
    },
    readUint24() {
        const value = this.inspectUint24();
        this.position += 3;
        return value;
    },
    readUint32() {
        const value = this.inspectUint32();
        this.position += 4;
        return value;
    },
    setPosition(position) {
        this.assertPosition(position);
        this.position = position;
    },
};
function createCursor(bytes) {
    const cursor = Object.create(staticCursor);
    cursor.bytes = bytes;
    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    return cursor;
}
exports.createCursor = createCursor;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/data/concat.js":
/*!*********************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/data/concat.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.concatHex = exports.concatBytes = exports.concat = void 0;
function concat(values) {
    if (typeof values[0] === 'string')
        return concatHex(values);
    return concatBytes(values);
}
exports.concat = concat;
function concatBytes(values) {
    let length = 0;
    for (const arr of values) {
        length += arr.length;
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (const arr of values) {
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
function concatHex(values) {
    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;
}
exports.concatHex = concatHex;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/data/isBytes.js":
/*!**********************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/data/isBytes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBytes = void 0;
function isBytes(value) {
    if (!value)
        return false;
    if (typeof value !== 'object')
        return false;
    if (!('BYTES_PER_ELEMENT' in value))
        return false;
    return (value.BYTES_PER_ELEMENT === 1 && value.constructor.name === 'Uint8Array');
}
exports.isBytes = isBytes;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/data/isBytesEqual.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/data/isBytesEqual.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBytesEqual = void 0;
const utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ "../../node_modules/@noble/curves/abstract/utils.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const isHex_js_1 = __webpack_require__(/*! ./isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
function isBytesEqual(a_, b_) {
    const a = (0, isHex_js_1.isHex)(a_) ? (0, toBytes_js_1.toBytes)(a_) : a_;
    const b = (0, isHex_js_1.isHex)(b_) ? (0, toBytes_js_1.toBytes)(b_) : b_;
    return (0, utils_1.equalBytes)(a, b);
}
exports.isBytesEqual = isBytesEqual;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/data/isHex.js":
/*!********************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/data/isHex.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isHex = void 0;
function isHex(value, { strict = true } = {}) {
    if (!value)
        return false;
    if (typeof value !== 'string')
        return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');
}
exports.isHex = isHex;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/data/pad.js":
/*!******************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/data/pad.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.padBytes = exports.padHex = exports.pad = void 0;
const data_js_1 = __webpack_require__(/*! ../../errors/data.js */ "../../node_modules/viem/_cjs/errors/data.js");
function pad(hexOrBytes, { dir, size = 32 } = {}) {
    if (typeof hexOrBytes === 'string')
        return padHex(hexOrBytes, { dir, size });
    return padBytes(hexOrBytes, { dir, size });
}
exports.pad = pad;
function padHex(hex_, { dir, size = 32 } = {}) {
    if (size === null)
        return hex_;
    const hex = hex_.replace('0x', '');
    if (hex.length > size * 2)
        throw new data_js_1.SizeExceedsPaddingSizeError({
            size: Math.ceil(hex.length / 2),
            targetSize: size,
            type: 'hex',
        });
    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
}
exports.padHex = padHex;
function padBytes(bytes, { dir, size = 32 } = {}) {
    if (size === null)
        return bytes;
    if (bytes.length > size)
        throw new data_js_1.SizeExceedsPaddingSizeError({
            size: bytes.length,
            targetSize: size,
            type: 'bytes',
        });
    const paddedBytes = new Uint8Array(size);
    for (let i = 0; i < size; i++) {
        const padEnd = dir === 'right';
        paddedBytes[padEnd ? i : size - i - 1] =
            bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
}
exports.padBytes = padBytes;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/data/size.js":
/*!*******************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/data/size.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.size = void 0;
const isHex_js_1 = __webpack_require__(/*! ./isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
function size(value) {
    if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return Math.ceil((value.length - 2) / 2);
    return value.length;
}
exports.size = size;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/data/slice.js":
/*!********************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/data/slice.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sliceHex = exports.sliceBytes = exports.slice = void 0;
const data_js_1 = __webpack_require__(/*! ../../errors/data.js */ "../../node_modules/viem/_cjs/errors/data.js");
const isHex_js_1 = __webpack_require__(/*! ./isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
const size_js_1 = __webpack_require__(/*! ./size.js */ "../../node_modules/viem/_cjs/utils/data/size.js");
function slice(value, start, end, { strict } = {}) {
    if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return sliceHex(value, start, end, {
            strict,
        });
    return sliceBytes(value, start, end, {
        strict,
    });
}
exports.slice = slice;
function assertStartOffset(value, start) {
    if (typeof start === 'number' && start > 0 && start > (0, size_js_1.size)(value) - 1)
        throw new data_js_1.SliceOffsetOutOfBoundsError({
            offset: start,
            position: 'start',
            size: (0, size_js_1.size)(value),
        });
}
function assertEndOffset(value, start, end) {
    if (typeof start === 'number' &&
        typeof end === 'number' &&
        (0, size_js_1.size)(value) !== end - start) {
        throw new data_js_1.SliceOffsetOutOfBoundsError({
            offset: end,
            position: 'end',
            size: (0, size_js_1.size)(value),
        });
    }
}
function sliceBytes(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = value_.slice(start, end);
    if (strict)
        assertEndOffset(value, start, end);
    return value;
}
exports.sliceBytes = sliceBytes;
function sliceHex(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = `0x${value_
        .replace('0x', '')
        .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
    if (strict)
        assertEndOffset(value, start, end);
    return value;
}
exports.sliceHex = sliceHex;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/data/trim.js":
/*!*******************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/data/trim.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.trim = void 0;
function trim(hexOrBytes, { dir = 'left' } = {}) {
    let data = typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes;
    let sliceLength = 0;
    for (let i = 0; i < data.length - 1; i++) {
        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')
            sliceLength++;
        else
            break;
    }
    data =
        dir === 'left'
            ? data.slice(sliceLength)
            : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === 'string') {
        if (data.length === 1 && dir === 'right')
            data = `${data}0`;
        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
    }
    return data;
}
exports.trim = trim;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/encoding/fromBytes.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/encoding/fromBytes.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigInt = exports.fromBytes = void 0;
const encoding_js_1 = __webpack_require__(/*! ../../errors/encoding.js */ "../../node_modules/viem/_cjs/errors/encoding.js");
const trim_js_1 = __webpack_require__(/*! ../data/trim.js */ "../../node_modules/viem/_cjs/utils/data/trim.js");
const fromHex_js_1 = __webpack_require__(/*! ./fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ./toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
function fromBytes(bytes, toOrOpts) {
    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;
    const to = opts.to;
    if (to === 'number')
        return bytesToNumber(bytes, opts);
    if (to === 'bigint')
        return bytesToBigInt(bytes, opts);
    if (to === 'boolean')
        return bytesToBool(bytes, opts);
    if (to === 'string')
        return bytesToString(bytes, opts);
    return (0, toHex_js_1.bytesToHex)(bytes, opts);
}
exports.fromBytes = fromBytes;
function bytesToBigInt(bytes, opts = {}) {
    if (typeof opts.size !== 'undefined')
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
    const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
    return (0, fromHex_js_1.hexToBigInt)(hex);
}
exports.bytesToBigInt = bytesToBigInt;
function bytesToBool(bytes_, opts = {}) {
    let bytes = bytes_;
    if (typeof opts.size !== 'undefined') {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes);
    }
    if (bytes.length > 1 || bytes[0] > 1)
        throw new encoding_js_1.InvalidBytesBooleanError(bytes);
    return Boolean(bytes[0]);
}
exports.bytesToBool = bytesToBool;
function bytesToNumber(bytes, opts = {}) {
    if (typeof opts.size !== 'undefined')
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
    const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
    return (0, fromHex_js_1.hexToNumber)(hex);
}
exports.bytesToNumber = bytesToNumber;
function bytesToString(bytes_, opts = {}) {
    let bytes = bytes_;
    if (typeof opts.size !== 'undefined') {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: 'right' });
    }
    return new TextDecoder().decode(bytes);
}
exports.bytesToString = bytesToString;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/encoding/fromHex.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.assertSize = void 0;
const encoding_js_1 = __webpack_require__(/*! ../../errors/encoding.js */ "../../node_modules/viem/_cjs/errors/encoding.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "../../node_modules/viem/_cjs/utils/data/size.js");
const trim_js_1 = __webpack_require__(/*! ../data/trim.js */ "../../node_modules/viem/_cjs/utils/data/trim.js");
const toBytes_js_1 = __webpack_require__(/*! ./toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
function assertSize(hexOrBytes, { size }) {
    if ((0, size_js_1.size)(hexOrBytes) > size)
        throw new encoding_js_1.SizeOverflowError({
            givenSize: (0, size_js_1.size)(hexOrBytes),
            maxSize: size,
        });
}
exports.assertSize = assertSize;
function fromHex(hex, toOrOpts) {
    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;
    const to = opts.to;
    if (to === 'number')
        return hexToNumber(hex, opts);
    if (to === 'bigint')
        return hexToBigInt(hex, opts);
    if (to === 'string')
        return hexToString(hex, opts);
    if (to === 'boolean')
        return hexToBool(hex, opts);
    return (0, toBytes_js_1.hexToBytes)(hex, opts);
}
exports.fromHex = fromHex;
function hexToBigInt(hex, opts = {}) {
    const { signed } = opts;
    if (opts.size)
        assertSize(hex, { size: opts.size });
    const value = BigInt(hex);
    if (!signed)
        return value;
    const size = (hex.length - 2) / 2;
    const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;
    if (value <= max)
        return value;
    return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;
}
exports.hexToBigInt = hexToBigInt;
function hexToBool(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        assertSize(hex, { size: opts.size });
        hex = (0, trim_js_1.trim)(hex);
    }
    if ((0, trim_js_1.trim)(hex) === '0x00')
        return false;
    if ((0, trim_js_1.trim)(hex) === '0x01')
        return true;
    throw new encoding_js_1.InvalidHexBooleanError(hex);
}
exports.hexToBool = hexToBool;
function hexToNumber(hex, opts = {}) {
    return Number(hexToBigInt(hex, opts));
}
exports.hexToNumber = hexToNumber;
function hexToString(hex, opts = {}) {
    let bytes = (0, toBytes_js_1.hexToBytes)(hex);
    if (opts.size) {
        assertSize(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: 'right' });
    }
    return new TextDecoder().decode(bytes);
}
exports.hexToString = hexToString;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/encoding/fromRlp.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/encoding/fromRlp.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rlpToHex = exports.rlpToBytes = exports.fromRlp = void 0;
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const encoding_js_1 = __webpack_require__(/*! ../../errors/encoding.js */ "../../node_modules/viem/_cjs/errors/encoding.js");
const cursor_js_1 = __webpack_require__(/*! ../cursor.js */ "../../node_modules/viem/_cjs/utils/cursor.js");
const toBytes_js_1 = __webpack_require__(/*! ./toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ./toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
function fromRlp(value, to = 'hex') {
    const bytes = (() => {
        if (typeof value === 'string') {
            if (value.length > 3 && value.length % 2 !== 0)
                throw new encoding_js_1.InvalidHexValueError(value);
            return (0, toBytes_js_1.hexToBytes)(value);
        }
        return value;
    })();
    const cursor = (0, cursor_js_1.createCursor)(bytes);
    const result = fromRlpCursor(cursor, to);
    return result;
}
exports.fromRlp = fromRlp;
function rlpToBytes(bytes, to = 'bytes') {
    return fromRlp(bytes, to);
}
exports.rlpToBytes = rlpToBytes;
function rlpToHex(hex, to = 'hex') {
    return fromRlp(hex, to);
}
exports.rlpToHex = rlpToHex;
function fromRlpCursor(cursor, to = 'hex') {
    if (cursor.bytes.length === 0)
        return (to === 'hex' ? (0, toHex_js_1.bytesToHex)(cursor.bytes) : cursor.bytes);
    const prefix = cursor.readByte();
    if (prefix < 0x80)
        cursor.decrementPosition(1);
    if (prefix < 0xc0) {
        const length = readLength(cursor, prefix, 0x80);
        const bytes = cursor.readBytes(length);
        return (to === 'hex' ? (0, toHex_js_1.bytesToHex)(bytes) : bytes);
    }
    const length = readLength(cursor, prefix, 0xc0);
    return readList(cursor, length, to);
}
function readLength(cursor, prefix, offset) {
    if (offset === 0x80 && prefix < 0x80)
        return 1;
    if (prefix <= offset + 55)
        return prefix - offset;
    if (prefix === offset + 55 + 1)
        return cursor.readUint8();
    if (prefix === offset + 55 + 2)
        return cursor.readUint16();
    if (prefix === offset + 55 + 3)
        return cursor.readUint24();
    if (prefix === offset + 55 + 4)
        return cursor.readUint32();
    throw new base_js_1.BaseError('Invalid RLP prefix');
}
function readList(cursor, length, to) {
    const position = cursor.position;
    const value = [];
    while (cursor.position - position < length)
        value.push(fromRlpCursor(cursor, to));
    return value;
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/encoding/toBytes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.toBytes = void 0;
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "../../node_modules/viem/_cjs/utils/data/pad.js");
const fromHex_js_1 = __webpack_require__(/*! ./fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ./toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const encoder = new TextEncoder();
function toBytes(value, opts = {}) {
    if (typeof value === 'number' || typeof value === 'bigint')
        return numberToBytes(value, opts);
    if (typeof value === 'boolean')
        return boolToBytes(value, opts);
    if ((0, isHex_js_1.isHex)(value))
        return hexToBytes(value, opts);
    return stringToBytes(value, opts);
}
exports.toBytes = toBytes;
function boolToBytes(value, opts = {}) {
    const bytes = new Uint8Array(1);
    bytes[0] = Number(value);
    if (typeof opts.size === 'number') {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        return (0, pad_js_1.pad)(bytes, { size: opts.size });
    }
    return bytes;
}
exports.boolToBytes = boolToBytes;
const charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102,
};
function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine)
        return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F)
        return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f)
        return char - (charCodeMap.a - 10);
    return undefined;
}
function hexToBytes(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        hex = (0, pad_js_1.pad)(hex, { dir: 'right', size: opts.size });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
        hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for (let index = 0, j = 0; index < length; index++) {
        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
        if (nibbleLeft === undefined || nibbleRight === undefined) {
            throw new base_js_1.BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
        }
        bytes[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
}
exports.hexToBytes = hexToBytes;
function numberToBytes(value, opts) {
    const hex = (0, toHex_js_1.numberToHex)(value, opts);
    return hexToBytes(hex);
}
exports.numberToBytes = numberToBytes;
function stringToBytes(value, opts = {}) {
    const bytes = encoder.encode(value);
    if (typeof opts.size === 'number') {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        return (0, pad_js_1.pad)(bytes, { dir: 'right', size: opts.size });
    }
    return bytes;
}
exports.stringToBytes = stringToBytes;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/encoding/toHex.js":
/*!************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/encoding/toHex.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toHex = void 0;
const encoding_js_1 = __webpack_require__(/*! ../../errors/encoding.js */ "../../node_modules/viem/_cjs/errors/encoding.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "../../node_modules/viem/_cjs/utils/data/pad.js");
const fromHex_js_1 = __webpack_require__(/*! ./fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const hexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
function toHex(value, opts = {}) {
    if (typeof value === 'number' || typeof value === 'bigint')
        return numberToHex(value, opts);
    if (typeof value === 'string') {
        return stringToHex(value, opts);
    }
    if (typeof value === 'boolean')
        return boolToHex(value, opts);
    return bytesToHex(value, opts);
}
exports.toHex = toHex;
function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === 'number') {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { size: opts.size });
    }
    return hex;
}
exports.boolToHex = boolToHex;
function bytesToHex(value, opts = {}) {
    let string = '';
    for (let i = 0; i < value.length; i++) {
        string += hexes[value[i]];
    }
    const hex = `0x${string}`;
    if (typeof opts.size === 'number') {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { dir: 'right', size: opts.size });
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHex(value_, opts = {}) {
    const { signed, size } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size) {
        if (signed)
            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;
        else
            maxValue = 2n ** (BigInt(size) * 8n) - 1n;
    }
    else if (typeof value_ === 'number') {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
    if ((maxValue && value > maxValue) || value < minValue) {
        const suffix = typeof value_ === 'bigint' ? 'n' : '';
        throw new encoding_js_1.IntegerOutOfRangeError({
            max: maxValue ? `${maxValue}${suffix}` : undefined,
            min: `${minValue}${suffix}`,
            signed,
            size,
            value: `${value_}${suffix}`,
        });
    }
    const hex = `0x${(signed && value < 0
        ? (1n << BigInt(size * 8)) + BigInt(value)
        : value).toString(16)}`;
    if (size)
        return (0, pad_js_1.pad)(hex, { size });
    return hex;
}
exports.numberToHex = numberToHex;
const encoder = new TextEncoder();
function stringToHex(value_, opts = {}) {
    const value = encoder.encode(value_);
    return bytesToHex(value, opts);
}
exports.stringToHex = stringToHex;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/encoding/toRlp.js":
/*!************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/encoding/toRlp.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexToRlp = exports.bytesToRlp = exports.toRlp = void 0;
const index_js_1 = __webpack_require__(/*! ../../index.js */ "../../node_modules/viem/_cjs/index.js");
const cursor_js_1 = __webpack_require__(/*! ../cursor.js */ "../../node_modules/viem/_cjs/utils/cursor.js");
const toBytes_js_1 = __webpack_require__(/*! ./toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ./toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
function toRlp(bytes, to = 'hex') {
    const encodable = getEncodable(bytes);
    const cursor = (0, cursor_js_1.createCursor)(new Uint8Array(encodable.length));
    encodable.encode(cursor);
    if (to === 'hex')
        return (0, toHex_js_1.bytesToHex)(cursor.bytes);
    return cursor.bytes;
}
exports.toRlp = toRlp;
function bytesToRlp(bytes, to = 'bytes') {
    return toRlp(bytes, to);
}
exports.bytesToRlp = bytesToRlp;
function hexToRlp(hex, to = 'hex') {
    return toRlp(hex, to);
}
exports.hexToRlp = hexToRlp;
function getEncodable(bytes) {
    if (Array.isArray(bytes))
        return getEncodableList(bytes.map((x) => getEncodable(x)));
    return getEncodableBytes(bytes);
}
function getEncodableList(list) {
    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
    const sizeOfBodyLength = getSizeOfLength(bodyLength);
    const length = (() => {
        if (bodyLength <= 55)
            return 1 + bodyLength;
        return 1 + sizeOfBodyLength + bodyLength;
    })();
    return {
        length,
        encode(cursor) {
            if (bodyLength <= 55) {
                cursor.pushByte(0xc0 + bodyLength);
            }
            else {
                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);
                if (sizeOfBodyLength === 1)
                    cursor.pushUint8(bodyLength);
                else if (sizeOfBodyLength === 2)
                    cursor.pushUint16(bodyLength);
                else if (sizeOfBodyLength === 3)
                    cursor.pushUint24(bodyLength);
                else
                    cursor.pushUint32(bodyLength);
            }
            for (const { encode } of list) {
                encode(cursor);
            }
        },
    };
}
function getEncodableBytes(bytesOrHex) {
    const bytes = typeof bytesOrHex === 'string' ? (0, toBytes_js_1.hexToBytes)(bytesOrHex) : bytesOrHex;
    const sizeOfBytesLength = getSizeOfLength(bytes.length);
    const length = (() => {
        if (bytes.length === 1 && bytes[0] < 0x80)
            return 1;
        if (bytes.length <= 55)
            return 1 + bytes.length;
        return 1 + sizeOfBytesLength + bytes.length;
    })();
    return {
        length,
        encode(cursor) {
            if (bytes.length === 1 && bytes[0] < 0x80) {
                cursor.pushBytes(bytes);
            }
            else if (bytes.length <= 55) {
                cursor.pushByte(0x80 + bytes.length);
                cursor.pushBytes(bytes);
            }
            else {
                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);
                if (sizeOfBytesLength === 1)
                    cursor.pushUint8(bytes.length);
                else if (sizeOfBytesLength === 2)
                    cursor.pushUint16(bytes.length);
                else if (sizeOfBytesLength === 3)
                    cursor.pushUint24(bytes.length);
                else
                    cursor.pushUint32(bytes.length);
                cursor.pushBytes(bytes);
            }
        },
    };
}
function getSizeOfLength(length) {
    if (length < 2 ** 8)
        return 1;
    if (length < 2 ** 16)
        return 2;
    if (length < 2 ** 24)
        return 3;
    if (length < 2 ** 32)
        return 4;
    throw new index_js_1.BaseError('Length is too large.');
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAvatarRecord = void 0;
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/viem/_cjs/utils/ens/avatar/utils.js");
async function parseAvatarRecord(client, { gatewayUrls, record, }) {
    if (/eip155:/i.test(record))
        return parseNftAvatarUri(client, { gatewayUrls, record });
    return (0, utils_js_1.parseAvatarUri)({ uri: record, gatewayUrls });
}
exports.parseAvatarRecord = parseAvatarRecord;
async function parseNftAvatarUri(client, { gatewayUrls, record, }) {
    const nft = (0, utils_js_1.parseNftUri)(record);
    const nftUri = await (0, utils_js_1.getNftTokenUri)(client, { nft });
    const { uri: resolvedNftUri, isOnChain, isEncoded, } = (0, utils_js_1.resolveAvatarUri)({ uri: nftUri, gatewayUrls });
    if (isOnChain &&
        (resolvedNftUri.includes('data:application/json;base64,') ||
            resolvedNftUri.startsWith('{'))) {
        const encodedJson = isEncoded
            ?
                atob(resolvedNftUri.replace('data:application/json;base64,', ''))
            :
                resolvedNftUri;
        const decoded = JSON.parse(encodedJson);
        return (0, utils_js_1.parseAvatarUri)({ uri: (0, utils_js_1.getJsonImage)(decoded), gatewayUrls });
    }
    let uriTokenId = nft.tokenID;
    if (nft.namespace === 'erc1155')
        uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0');
    return (0, utils_js_1.getMetadataAvatarUri)({
        gatewayUrls,
        uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),
    });
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/ens/avatar/utils.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/ens/avatar/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNftTokenUri = exports.parseNftUri = exports.parseAvatarUri = exports.getMetadataAvatarUri = exports.getJsonImage = exports.resolveAvatarUri = exports.getGateway = exports.isImageUri = void 0;
const readContract_js_1 = __webpack_require__(/*! ../../../actions/public/readContract.js */ "../../node_modules/viem/_cjs/actions/public/readContract.js");
const ens_js_1 = __webpack_require__(/*! ../../../errors/ens.js */ "../../node_modules/viem/_cjs/errors/ens.js");
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
    try {
        const res = await fetch(uri, { method: 'HEAD' });
        if (res.status === 200) {
            const contentType = res.headers.get('content-type');
            return contentType?.startsWith('image/');
        }
        return false;
    }
    catch (error) {
        if (typeof error === 'object' && typeof error.response !== 'undefined') {
            return false;
        }
        if (!globalThis.hasOwnProperty('Image'))
            return false;
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                resolve(true);
            };
            img.onerror = () => {
                resolve(false);
            };
            img.src = uri;
        });
    }
}
exports.isImageUri = isImageUri;
function getGateway(custom, defaultGateway) {
    if (!custom)
        return defaultGateway;
    if (custom.endsWith('/'))
        return custom.slice(0, -1);
    return custom;
}
exports.getGateway = getGateway;
function resolveAvatarUri({ uri, gatewayUrls, }) {
    const isEncoded = base64Regex.test(uri);
    if (isEncoded)
        return { uri, isOnChain: true, isEncoded };
    const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io');
    const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net');
    const networkRegexMatch = uri.match(networkRegex);
    const { protocol, subpath, target, subtarget = '', } = networkRegexMatch?.groups || {};
    const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';
    const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);
    if (uri.startsWith('http') && !isIPNS && !isIPFS) {
        let replacedUri = uri;
        if (gatewayUrls?.arweave)
            replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
        return { uri: replacedUri, isOnChain: false, isEncoded: false };
    }
    if ((isIPNS || isIPFS) && target) {
        return {
            uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,
            isOnChain: false,
            isEncoded: false,
        };
    }
    if (protocol === 'ar:/' && target) {
        return {
            uri: `${arweaveGateway}/${target}${subtarget || ''}`,
            isOnChain: false,
            isEncoded: false,
        };
    }
    let parsedUri = uri.replace(dataURIRegex, '');
    if (parsedUri.startsWith('<svg')) {
        parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
    }
    if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {
        return {
            uri: parsedUri,
            isOnChain: true,
            isEncoded: false,
        };
    }
    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
}
exports.resolveAvatarUri = resolveAvatarUri;
function getJsonImage(data) {
    if (typeof data !== 'object' ||
        (!('image' in data) && !('image_url' in data) && !('image_data' in data))) {
        throw new ens_js_1.EnsAvatarInvalidMetadataError({ data });
    }
    return data.image || data.image_url || data.image_data;
}
exports.getJsonImage = getJsonImage;
async function getMetadataAvatarUri({ gatewayUrls, uri, }) {
    try {
        const res = await fetch(uri).then((res) => res.json());
        const image = await parseAvatarUri({
            gatewayUrls,
            uri: getJsonImage(res),
        });
        return image;
    }
    catch {
        throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
}
exports.getMetadataAvatarUri = getMetadataAvatarUri;
async function parseAvatarUri({ gatewayUrls, uri, }) {
    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
    if (isOnChain)
        return resolvedURI;
    const isImage = await isImageUri(resolvedURI);
    if (isImage)
        return resolvedURI;
    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
}
exports.parseAvatarUri = parseAvatarUri;
function parseNftUri(uri_) {
    let uri = uri_;
    if (uri.startsWith('did:nft:')) {
        uri = uri.replace('did:nft:', '').replace(/_/g, '/');
    }
    const [reference, asset_namespace, tokenID] = uri.split('/');
    const [eip_namespace, chainID] = reference.split(':');
    const [erc_namespace, contractAddress] = asset_namespace.split(':');
    if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' });
    if (!chainID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' });
    if (!contractAddress)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({
            reason: 'Contract address not found',
        });
    if (!tokenID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' });
    if (!erc_namespace)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' });
    return {
        chainID: parseInt(chainID),
        namespace: erc_namespace.toLowerCase(),
        contractAddress: contractAddress,
        tokenID,
    };
}
exports.parseNftUri = parseNftUri;
async function getNftTokenUri(client, { nft }) {
    if (nft.namespace === 'erc721') {
        return (0, readContract_js_1.readContract)(client, {
            address: nft.contractAddress,
            abi: [
                {
                    name: 'tokenURI',
                    type: 'function',
                    stateMutability: 'view',
                    inputs: [{ name: 'tokenId', type: 'uint256' }],
                    outputs: [{ name: '', type: 'string' }],
                },
            ],
            functionName: 'tokenURI',
            args: [BigInt(nft.tokenID)],
        });
    }
    if (nft.namespace === 'erc1155') {
        return (0, readContract_js_1.readContract)(client, {
            address: nft.contractAddress,
            abi: [
                {
                    name: 'uri',
                    type: 'function',
                    stateMutability: 'view',
                    inputs: [{ name: '_id', type: 'uint256' }],
                    outputs: [{ name: '', type: 'string' }],
                },
            ],
            functionName: 'uri',
            args: [BigInt(nft.tokenID)],
        });
    }
    throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}
exports.getNftTokenUri = getNftTokenUri;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/ens/encodeLabelhash.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/ens/encodeLabelhash.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeLabelhash = void 0;
function encodeLabelhash(hash) {
    return `[${hash.slice(2)}]`;
}
exports.encodeLabelhash = encodeLabelhash;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodedLabelToLabelhash = void 0;
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
function encodedLabelToLabelhash(label) {
    if (label.length !== 66)
        return null;
    if (label.indexOf('[') !== 0)
        return null;
    if (label.indexOf(']') !== 65)
        return null;
    const hash = `0x${label.slice(1, 65)}`;
    if (!(0, isHex_js_1.isHex)(hash))
        return null;
    return hash;
}
exports.encodedLabelToLabelhash = encodedLabelToLabelhash;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/ens/errors.js":
/*!********************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/ens/errors.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNullUniversalResolverError = void 0;
const solidity_js_1 = __webpack_require__(/*! ../../constants/solidity.js */ "../../node_modules/viem/_cjs/constants/solidity.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const contract_js_1 = __webpack_require__(/*! ../../errors/contract.js */ "../../node_modules/viem/_cjs/errors/contract.js");
function isNullUniversalResolverError(err, callType) {
    if (!(err instanceof base_js_1.BaseError))
        return false;
    const cause = err.walk((e) => e instanceof contract_js_1.ContractFunctionRevertedError);
    if (!(cause instanceof contract_js_1.ContractFunctionRevertedError))
        return false;
    if (cause.data?.errorName === 'ResolverNotFound')
        return true;
    if (cause.data?.errorName === 'ResolverWildcardNotSupported')
        return true;
    if (cause.reason?.includes('Wildcard on non-extended resolvers is not supported'))
        return true;
    if (callType === 'reverse' && cause.reason === solidity_js_1.panicReasons[50])
        return true;
    return false;
}
exports.isNullUniversalResolverError = isNullUniversalResolverError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/ens/labelhash.js":
/*!***********************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/ens/labelhash.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.labelhash = void 0;
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
const encodedLabelToLabelhash_js_1 = __webpack_require__(/*! ./encodedLabelToLabelhash.js */ "../../node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js");
function labelhash(label) {
    const result = new Uint8Array(32).fill(0);
    if (!label)
        return (0, toHex_js_1.bytesToHex)(result);
    return (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(label) || (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(label));
}
exports.labelhash = labelhash;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/ens/namehash.js":
/*!**********************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/ens/namehash.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.namehash = void 0;
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
const encodedLabelToLabelhash_js_1 = __webpack_require__(/*! ./encodedLabelToLabelhash.js */ "../../node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js");
function namehash(name) {
    let result = new Uint8Array(32).fill(0);
    if (!name)
        return (0, toHex_js_1.bytesToHex)(result);
    const labels = name.split('.');
    for (let i = labels.length - 1; i >= 0; i -= 1) {
        const hashFromEncodedLabel = (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(labels[i]);
        const hashed = hashFromEncodedLabel
            ? (0, toBytes_js_1.toBytes)(hashFromEncodedLabel)
            : (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(labels[i]), 'bytes');
        result = (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([result, hashed]), 'bytes');
    }
    return (0, toHex_js_1.bytesToHex)(result);
}
exports.namehash = namehash;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/ens/packetToBytes.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/ens/packetToBytes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.packetToBytes = void 0;
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const encodeLabelhash_js_1 = __webpack_require__(/*! ./encodeLabelhash.js */ "../../node_modules/viem/_cjs/utils/ens/encodeLabelhash.js");
const labelhash_js_1 = __webpack_require__(/*! ./labelhash.js */ "../../node_modules/viem/_cjs/utils/ens/labelhash.js");
function packetToBytes(packet) {
    const value = packet.replace(/^\.|\.$/gm, '');
    if (value.length === 0)
        return new Uint8Array(1);
    const bytes = new Uint8Array((0, toBytes_js_1.stringToBytes)(value).byteLength + 2);
    let offset = 0;
    const list = value.split('.');
    for (let i = 0; i < list.length; i++) {
        let encoded = (0, toBytes_js_1.stringToBytes)(list[i]);
        if (encoded.byteLength > 255)
            encoded = (0, toBytes_js_1.stringToBytes)((0, encodeLabelhash_js_1.encodeLabelhash)((0, labelhash_js_1.labelhash)(list[i])));
        bytes[offset] = encoded.length;
        bytes.set(encoded, offset + 1);
        offset += encoded.length + 1;
    }
    if (bytes.byteLength !== offset + 1)
        return bytes.slice(0, offset + 1);
    return bytes;
}
exports.packetToBytes = packetToBytes;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/errors/getCallError.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/errors/getCallError.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCallError = void 0;
const contract_js_1 = __webpack_require__(/*! ../../errors/contract.js */ "../../node_modules/viem/_cjs/errors/contract.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "../../node_modules/viem/_cjs/errors/node.js");
const getNodeError_js_1 = __webpack_require__(/*! ./getNodeError.js */ "../../node_modules/viem/_cjs/utils/errors/getNodeError.js");
function getCallError(err, { docsPath, ...args }) {
    const cause = (() => {
        const cause = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause instanceof node_js_1.UnknownNodeError)
            return err;
        return cause;
    })();
    return new contract_js_1.CallExecutionError(cause, {
        docsPath,
        ...args,
    });
}
exports.getCallError = getCallError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/errors/getContractError.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/errors/getContractError.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContractError = void 0;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const contract_js_1 = __webpack_require__(/*! ../../errors/contract.js */ "../../node_modules/viem/_cjs/errors/contract.js");
const rpc_js_1 = __webpack_require__(/*! ../../errors/rpc.js */ "../../node_modules/viem/_cjs/errors/rpc.js");
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi, address, args, docsPath, functionName, sender, }) {
    const { code, data, message, shortMessage } = (err instanceof contract_js_1.RawContractError
        ? err
        : err instanceof base_js_1.BaseError
            ? err.walk((err) => 'data' in err) || err.walk()
            : {});
    const cause = (() => {
        if (err instanceof abi_js_1.AbiDecodingZeroDataError)
            return new contract_js_1.ContractFunctionZeroDataError({ functionName });
        if ([EXECUTION_REVERTED_ERROR_CODE, rpc_js_1.InternalRpcError.code].includes(code) &&
            (data || message || shortMessage)) {
            return new contract_js_1.ContractFunctionRevertedError({
                abi,
                data: typeof data === 'object' ? data.data : data,
                functionName,
                message: shortMessage ?? message,
            });
        }
        return err;
    })();
    return new contract_js_1.ContractFunctionExecutionError(cause, {
        abi,
        args,
        contractAddress: address,
        docsPath,
        functionName,
        sender,
    });
}
exports.getContractError = getContractError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/errors/getEstimateGasError.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/errors/getEstimateGasError.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEstimateGasError = void 0;
const estimateGas_js_1 = __webpack_require__(/*! ../../errors/estimateGas.js */ "../../node_modules/viem/_cjs/errors/estimateGas.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "../../node_modules/viem/_cjs/errors/node.js");
const getNodeError_js_1 = __webpack_require__(/*! ./getNodeError.js */ "../../node_modules/viem/_cjs/utils/errors/getNodeError.js");
function getEstimateGasError(err, { docsPath, ...args }) {
    const cause = (() => {
        const cause = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause instanceof node_js_1.UnknownNodeError)
            return err;
        return cause;
    })();
    return new estimateGas_js_1.EstimateGasExecutionError(cause, {
        docsPath,
        ...args,
    });
}
exports.getEstimateGasError = getEstimateGasError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/errors/getNodeError.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/errors/getNodeError.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNodeError = exports.containsNodeError = void 0;
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "../../node_modules/viem/_cjs/errors/node.js");
const request_js_1 = __webpack_require__(/*! ../../errors/request.js */ "../../node_modules/viem/_cjs/errors/request.js");
const rpc_js_1 = __webpack_require__(/*! ../../errors/rpc.js */ "../../node_modules/viem/_cjs/errors/rpc.js");
function containsNodeError(err) {
    return (err instanceof rpc_js_1.TransactionRejectedRpcError ||
        err instanceof rpc_js_1.InvalidInputRpcError ||
        (err instanceof request_js_1.RpcRequestError && err.code === node_js_1.ExecutionRevertedError.code));
}
exports.containsNodeError = containsNodeError;
function getNodeError(err, args) {
    const message = (err.details || '').toLowerCase();
    const executionRevertedError = err.walk((e) => e.code === node_js_1.ExecutionRevertedError.code);
    if (executionRevertedError instanceof base_js_1.BaseError) {
        return new node_js_1.ExecutionRevertedError({
            cause: err,
            message: executionRevertedError.details,
        });
    }
    if (node_js_1.ExecutionRevertedError.nodeMessage.test(message))
        return new node_js_1.ExecutionRevertedError({
            cause: err,
            message: err.details,
        });
    if (node_js_1.FeeCapTooHighError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooHighError({
            cause: err,
            maxFeePerGas: args?.maxFeePerGas,
        });
    if (node_js_1.FeeCapTooLowError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooLowError({
            cause: err,
            maxFeePerGas: args?.maxFeePerGas,
        });
    if (node_js_1.NonceTooHighError.nodeMessage.test(message))
        return new node_js_1.NonceTooHighError({ cause: err, nonce: args?.nonce });
    if (node_js_1.NonceTooLowError.nodeMessage.test(message))
        return new node_js_1.NonceTooLowError({ cause: err, nonce: args?.nonce });
    if (node_js_1.NonceMaxValueError.nodeMessage.test(message))
        return new node_js_1.NonceMaxValueError({ cause: err, nonce: args?.nonce });
    if (node_js_1.InsufficientFundsError.nodeMessage.test(message))
        return new node_js_1.InsufficientFundsError({ cause: err });
    if (node_js_1.IntrinsicGasTooHighError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
    if (node_js_1.IntrinsicGasTooLowError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
    if (node_js_1.TransactionTypeNotSupportedError.nodeMessage.test(message))
        return new node_js_1.TransactionTypeNotSupportedError({ cause: err });
    if (node_js_1.TipAboveFeeCapError.nodeMessage.test(message))
        return new node_js_1.TipAboveFeeCapError({
            cause: err,
            maxFeePerGas: args?.maxFeePerGas,
            maxPriorityFeePerGas: args?.maxPriorityFeePerGas,
        });
    return new node_js_1.UnknownNodeError({
        cause: err,
    });
}
exports.getNodeError = getNodeError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/errors/getTransactionError.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/errors/getTransactionError.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransactionError = void 0;
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "../../node_modules/viem/_cjs/errors/node.js");
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
const getNodeError_js_1 = __webpack_require__(/*! ./getNodeError.js */ "../../node_modules/viem/_cjs/utils/errors/getNodeError.js");
function getTransactionError(err, { docsPath, ...args }) {
    const cause = (() => {
        const cause = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause instanceof node_js_1.UnknownNodeError)
            return err;
        return cause;
    })();
    return new transaction_js_1.TransactionExecutionError(cause, {
        docsPath,
        ...args,
    });
}
exports.getTransactionError = getTransactionError;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFilterRequestScope = void 0;
function createFilterRequestScope(client, { method }) {
    const requestMap = {};
    if (client.transport.type === 'fallback')
        client.transport.onResponse?.(({ method: method_, response: id, status, transport, }) => {
            if (status === 'success' && method === method_)
                requestMap[id] = transport.request;
        });
    return ((id) => requestMap[id] || client.request);
}
exports.createFilterRequestScope = createFilterRequestScope;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/formatters/block.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/formatters/block.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineBlock = exports.formatBlock = void 0;
const formatter_js_1 = __webpack_require__(/*! ./formatter.js */ "../../node_modules/viem/_cjs/utils/formatters/formatter.js");
const transaction_js_1 = __webpack_require__(/*! ./transaction.js */ "../../node_modules/viem/_cjs/utils/formatters/transaction.js");
function formatBlock(block) {
    const transactions = block.transactions?.map((transaction) => {
        if (typeof transaction === 'string')
            return transaction;
        return (0, transaction_js_1.formatTransaction)(transaction);
    });
    return {
        ...block,
        baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
        difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
        gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
        gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
        hash: block.hash ? block.hash : null,
        logsBloom: block.logsBloom ? block.logsBloom : null,
        nonce: block.nonce ? block.nonce : null,
        number: block.number ? BigInt(block.number) : null,
        size: block.size ? BigInt(block.size) : undefined,
        timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
        transactions,
        totalDifficulty: block.totalDifficulty
            ? BigInt(block.totalDifficulty)
            : null,
    };
}
exports.formatBlock = formatBlock;
exports.defineBlock = (0, formatter_js_1.defineFormatter)('block', formatBlock);


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/formatters/extract.js":
/*!****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/formatters/extract.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extract = void 0;
function extract(value_, { format }) {
    if (!format)
        return {};
    const value = {};
    function extract_(formatted) {
        const keys = Object.keys(formatted);
        for (const key of keys) {
            if (key in value_)
                value[key] = value_[key];
            if (formatted[key] &&
                typeof formatted[key] === 'object' &&
                !Array.isArray(formatted[key]))
                extract_(formatted[key]);
        }
    }
    const formatted = format(value_ || {});
    extract_(formatted);
    return value;
}
exports.extract = extract;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/formatters/feeHistory.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/formatters/feeHistory.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatFeeHistory = void 0;
function formatFeeHistory(feeHistory) {
    return {
        baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
        gasUsedRatio: feeHistory.gasUsedRatio,
        oldestBlock: BigInt(feeHistory.oldestBlock),
        reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value))),
    };
}
exports.formatFeeHistory = formatFeeHistory;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/formatters/formatter.js":
/*!******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/formatters/formatter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineFormatter = void 0;
function defineFormatter(type, format) {
    return ({ exclude, format: overrides, }) => {
        return {
            exclude,
            format: (args) => {
                const formatted = format(args);
                if (exclude) {
                    for (const key of exclude) {
                        delete formatted[key];
                    }
                }
                return {
                    ...formatted,
                    ...overrides(args),
                };
            },
            type,
        };
    };
}
exports.defineFormatter = defineFormatter;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/formatters/log.js":
/*!************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/formatters/log.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatLog = void 0;
function formatLog(log, { args, eventName } = {}) {
    return {
        ...log,
        blockHash: log.blockHash ? log.blockHash : null,
        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
        logIndex: log.logIndex ? Number(log.logIndex) : null,
        transactionHash: log.transactionHash ? log.transactionHash : null,
        transactionIndex: log.transactionIndex
            ? Number(log.transactionIndex)
            : null,
        ...(eventName ? { args, eventName } : {}),
    };
}
exports.formatLog = formatLog;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/formatters/proof.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/formatters/proof.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatProof = void 0;
const index_js_1 = __webpack_require__(/*! ../index.js */ "../../node_modules/viem/_cjs/utils/index.js");
function formatStorageProof(storageProof) {
    return storageProof.map((proof) => ({
        ...proof,
        value: BigInt(proof.value),
    }));
}
function formatProof(proof) {
    return {
        ...proof,
        balance: proof.balance ? BigInt(proof.balance) : undefined,
        nonce: proof.nonce ? (0, index_js_1.hexToNumber)(proof.nonce) : undefined,
        storageProof: proof.storageProof
            ? formatStorageProof(proof.storageProof)
            : undefined,
    };
}
exports.formatProof = formatProof;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/formatters/transaction.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/formatters/transaction.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineTransaction = exports.formatTransaction = exports.transactionType = void 0;
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const formatter_js_1 = __webpack_require__(/*! ./formatter.js */ "../../node_modules/viem/_cjs/utils/formatters/formatter.js");
exports.transactionType = {
    '0x0': 'legacy',
    '0x1': 'eip2930',
    '0x2': 'eip1559',
};
function formatTransaction(transaction) {
    const transaction_ = {
        ...transaction,
        blockHash: transaction.blockHash ? transaction.blockHash : null,
        blockNumber: transaction.blockNumber
            ? BigInt(transaction.blockNumber)
            : null,
        chainId: transaction.chainId ? (0, fromHex_js_1.hexToNumber)(transaction.chainId) : undefined,
        gas: transaction.gas ? BigInt(transaction.gas) : undefined,
        gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
        maxFeePerGas: transaction.maxFeePerGas
            ? BigInt(transaction.maxFeePerGas)
            : undefined,
        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
            ? BigInt(transaction.maxPriorityFeePerGas)
            : undefined,
        nonce: transaction.nonce ? (0, fromHex_js_1.hexToNumber)(transaction.nonce) : undefined,
        to: transaction.to ? transaction.to : null,
        transactionIndex: transaction.transactionIndex
            ? Number(transaction.transactionIndex)
            : null,
        type: transaction.type ? exports.transactionType[transaction.type] : undefined,
        typeHex: transaction.type ? transaction.type : undefined,
        value: transaction.value ? BigInt(transaction.value) : undefined,
        v: transaction.v ? BigInt(transaction.v) : undefined,
    };
    transaction_.yParity = (() => {
        if (transaction.yParity)
            return Number(transaction.yParity);
        if (typeof transaction_.v === 'bigint') {
            if (transaction_.v === 0n || transaction_.v === 27n)
                return 0;
            if (transaction_.v === 1n || transaction_.v === 28n)
                return 1;
            if (transaction_.v >= 35n)
                return transaction_.v % 2n === 0n ? 1 : 0;
        }
        return undefined;
    })();
    if (transaction_.type === 'legacy') {
        delete transaction_.accessList;
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
        delete transaction_.yParity;
    }
    if (transaction_.type === 'eip2930') {
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
    }
    return transaction_;
}
exports.formatTransaction = formatTransaction;
exports.defineTransaction = (0, formatter_js_1.defineFormatter)('transaction', formatTransaction);


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/formatters/transactionReceipt.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/formatters/transactionReceipt.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineTransactionReceipt = exports.formatTransactionReceipt = void 0;
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const formatter_js_1 = __webpack_require__(/*! ./formatter.js */ "../../node_modules/viem/_cjs/utils/formatters/formatter.js");
const log_js_1 = __webpack_require__(/*! ./log.js */ "../../node_modules/viem/_cjs/utils/formatters/log.js");
const transaction_js_1 = __webpack_require__(/*! ./transaction.js */ "../../node_modules/viem/_cjs/utils/formatters/transaction.js");
const statuses = {
    '0x0': 'reverted',
    '0x1': 'success',
};
function formatTransactionReceipt(transactionReceipt) {
    return {
        ...transactionReceipt,
        blockNumber: transactionReceipt.blockNumber
            ? BigInt(transactionReceipt.blockNumber)
            : null,
        contractAddress: transactionReceipt.contractAddress
            ? transactionReceipt.contractAddress
            : null,
        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed
            ? BigInt(transactionReceipt.cumulativeGasUsed)
            : null,
        effectiveGasPrice: transactionReceipt.effectiveGasPrice
            ? BigInt(transactionReceipt.effectiveGasPrice)
            : null,
        gasUsed: transactionReceipt.gasUsed
            ? BigInt(transactionReceipt.gasUsed)
            : null,
        logs: transactionReceipt.logs
            ? transactionReceipt.logs.map((log) => (0, log_js_1.formatLog)(log))
            : null,
        to: transactionReceipt.to ? transactionReceipt.to : null,
        transactionIndex: transactionReceipt.transactionIndex
            ? (0, fromHex_js_1.hexToNumber)(transactionReceipt.transactionIndex)
            : null,
        status: transactionReceipt.status
            ? statuses[transactionReceipt.status]
            : null,
        type: transactionReceipt.type
            ? transaction_js_1.transactionType[transactionReceipt.type] || transactionReceipt.type
            : null,
    };
}
exports.formatTransactionReceipt = formatTransactionReceipt;
exports.defineTransactionReceipt = (0, formatter_js_1.defineFormatter)('transactionReceipt', formatTransactionReceipt);


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/formatters/transactionRequest.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/formatters/transactionRequest.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineTransactionRequest = exports.formatTransactionRequest = exports.rpcTransactionType = void 0;
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const formatter_js_1 = __webpack_require__(/*! ./formatter.js */ "../../node_modules/viem/_cjs/utils/formatters/formatter.js");
exports.rpcTransactionType = {
    legacy: '0x0',
    eip2930: '0x1',
    eip1559: '0x2',
};
function formatTransactionRequest(transactionRequest) {
    return {
        ...transactionRequest,
        gas: typeof transactionRequest.gas !== 'undefined'
            ? (0, toHex_js_1.numberToHex)(transactionRequest.gas)
            : undefined,
        gasPrice: typeof transactionRequest.gasPrice !== 'undefined'
            ? (0, toHex_js_1.numberToHex)(transactionRequest.gasPrice)
            : undefined,
        maxFeePerGas: typeof transactionRequest.maxFeePerGas !== 'undefined'
            ? (0, toHex_js_1.numberToHex)(transactionRequest.maxFeePerGas)
            : undefined,
        maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== 'undefined'
            ? (0, toHex_js_1.numberToHex)(transactionRequest.maxPriorityFeePerGas)
            : undefined,
        nonce: typeof transactionRequest.nonce !== 'undefined'
            ? (0, toHex_js_1.numberToHex)(transactionRequest.nonce)
            : undefined,
        type: typeof transactionRequest.type !== 'undefined'
            ? exports.rpcTransactionType[transactionRequest.type]
            : undefined,
        value: typeof transactionRequest.value !== 'undefined'
            ? (0, toHex_js_1.numberToHex)(transactionRequest.value)
            : undefined,
    };
}
exports.formatTransactionRequest = formatTransactionRequest;
exports.defineTransactionRequest = (0, formatter_js_1.defineFormatter)('transactionRequest', formatTransactionRequest);


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/getAction.js":
/*!*******************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/getAction.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAction = void 0;
function getAction(client, action, name) {
    return (params) => client[action.name || name]?.(params) ?? action(client, params);
}
exports.getAction = getAction;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/hash/getEventSelector.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/hash/getEventSelector.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEventSelector = void 0;
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const getEventSignature_js_1 = __webpack_require__(/*! ./getEventSignature.js */ "../../node_modules/viem/_cjs/utils/hash/getEventSignature.js");
const keccak256_js_1 = __webpack_require__(/*! ./keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
const hash = (value) => (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
const getEventSelector = (fn) => hash((0, getEventSignature_js_1.getEventSignature)(fn));
exports.getEventSelector = getEventSelector;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/hash/getEventSignature.js":
/*!********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/hash/getEventSignature.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEventSignature = void 0;
const getFunctionSignature_js_1 = __webpack_require__(/*! ./getFunctionSignature.js */ "../../node_modules/viem/_cjs/utils/hash/getFunctionSignature.js");
const getEventSignature = (fn) => {
    return (0, getFunctionSignature_js_1.getFunctionSignature)(fn);
};
exports.getEventSignature = getEventSignature;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/hash/getFunctionSelector.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/hash/getFunctionSelector.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFunctionSelector = void 0;
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "../../node_modules/viem/_cjs/utils/data/slice.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const getFunctionSignature_js_1 = __webpack_require__(/*! ./getFunctionSignature.js */ "../../node_modules/viem/_cjs/utils/hash/getFunctionSignature.js");
const keccak256_js_1 = __webpack_require__(/*! ./keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
const hash = (value) => (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
const getFunctionSelector = (fn) => (0, slice_js_1.slice)(hash((0, getFunctionSignature_js_1.getFunctionSignature)(fn)), 0, 4);
exports.getFunctionSelector = getFunctionSelector;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/hash/getFunctionSignature.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/hash/getFunctionSignature.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFunctionSignature = void 0;
const abitype_1 = __webpack_require__(/*! abitype */ "../../node_modules/abitype/dist/cjs/index.js");
const normalizeSignature_js_1 = __webpack_require__(/*! ./normalizeSignature.js */ "../../node_modules/viem/_cjs/utils/hash/normalizeSignature.js");
const getFunctionSignature = (fn_) => {
    const fn = (() => {
        if (typeof fn_ === 'string')
            return fn_;
        return (0, abitype_1.formatAbiItem)(fn_);
    })();
    return (0, normalizeSignature_js_1.normalizeSignature)(fn);
};
exports.getFunctionSignature = getFunctionSignature;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/hash/isHash.js":
/*!*********************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/hash/isHash.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isHash = void 0;
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "../../node_modules/viem/_cjs/utils/data/size.js");
function isHash(hash) {
    return (0, isHex_js_1.isHex)(hash) && (0, size_js_1.size)(hash) === 32;
}
exports.isHash = isHash;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/hash/keccak256.js":
/*!************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/hash/keccak256.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keccak256 = void 0;
const sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ "../../node_modules/@noble/hashes/sha3.js");
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
function keccak256(value, to_) {
    const to = to_ || 'hex';
    const bytes = (0, sha3_1.keccak_256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
    if (to === 'bytes')
        return bytes;
    return (0, toHex_js_1.toHex)(bytes);
}
exports.keccak256 = keccak256;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/hash/normalizeSignature.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/hash/normalizeSignature.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeSignature = void 0;
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
function normalizeSignature(signature) {
    let active = true;
    let current = '';
    let level = 0;
    let result = '';
    let valid = false;
    for (let i = 0; i < signature.length; i++) {
        const char = signature[i];
        if (['(', ')', ','].includes(char))
            active = true;
        if (char === '(')
            level++;
        if (char === ')')
            level--;
        if (!active)
            continue;
        if (level === 0) {
            if (char === ' ' && ['event', 'function', ''].includes(result))
                result = '';
            else {
                result += char;
                if (char === ')') {
                    valid = true;
                    break;
                }
            }
            continue;
        }
        if (char === ' ') {
            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {
                current = '';
                active = false;
            }
            continue;
        }
        result += char;
        current += char;
    }
    if (!valid)
        throw new base_js_1.BaseError('Unable to normalize signature.');
    return result;
}
exports.normalizeSignature = normalizeSignature;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/hash/ripemd160.js":
/*!************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/hash/ripemd160.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = void 0;
const ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ "../../node_modules/@noble/hashes/ripemd160.js");
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
function ripemd160(value, to_) {
    const to = to_ || 'hex';
    const bytes = (0, ripemd160_1.ripemd160)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
    if (to === 'bytes')
        return bytes;
    return (0, toHex_js_1.toHex)(bytes);
}
exports.ripemd160 = ripemd160;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/hash/sha256.js":
/*!*********************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/hash/sha256.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha256 = void 0;
const sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ "../../node_modules/@noble/hashes/sha256.js");
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
function sha256(value, to_) {
    const to = to_ || 'hex';
    const bytes = (0, sha256_1.sha256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
    if (to === 'bytes')
        return bytes;
    return (0, toHex_js_1.toHex)(bytes);
}
exports.sha256 = sha256;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.concat = exports.extractFunctionParts = exports.extractFunctionType = exports.extractFunctionParams = exports.extractFunctionName = exports.isAddressEqual = exports.isAddress = exports.getAddress = exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = exports.publicKeyToAddress = exports.parseAccount = exports.formatAbiParams = exports.formatAbiItem = exports.formatAbiItemWithArgs = exports.encodePacked = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.getAbiItem = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeAbiParameters = exports.validateTypedData = exports.stringify = exports.rpc = exports.getSocket = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.buildRequest = exports.isDeterministicError = void 0;
exports.getEstimateGasError = exports.getContractError = exports.getCallError = exports.getNodeError = exports.containsNodeError = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBigInt = exports.hexToBool = exports.fromHex = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.bytesToBigInt = exports.stringToHex = exports.numberToHex = exports.toHex = exports.bytesToHex = exports.boolToHex = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.toBytes = exports.boolToBytes = exports.toRlp = exports.extract = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.formatLog = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.formatBlock = exports.defineBlock = exports.trim = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.padHex = exports.padBytes = exports.pad = exports.isHex = exports.isBytes = exports.concatHex = exports.concatBytes = void 0;
exports.parseGwei = exports.parseEther = exports.parseUnits = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.serializeAccessList = exports.serializeTransaction = exports.prepareTransactionRequest = exports.parseTransaction = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.getTransactionType = exports.getSerializedTransactionType = exports.hashMessage = exports.verifyTypedData = exports.verifyMessage = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hashTypedData = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.isHash = exports.getFunctionSelector = exports.getEventSelector = exports.defineFormatter = exports.getTransactionError = void 0;
var buildRequest_js_1 = __webpack_require__(/*! ./buildRequest.js */ "../../node_modules/viem/_cjs/utils/buildRequest.js");
Object.defineProperty(exports, "isDeterministicError", ({ enumerable: true, get: function () { return buildRequest_js_1.isDeterministicError; } }));
Object.defineProperty(exports, "buildRequest", ({ enumerable: true, get: function () { return buildRequest_js_1.buildRequest; } }));
var ccip_js_1 = __webpack_require__(/*! ./ccip.js */ "../../node_modules/viem/_cjs/utils/ccip.js");
Object.defineProperty(exports, "ccipFetch", ({ enumerable: true, get: function () { return ccip_js_1.ccipFetch; } }));
Object.defineProperty(exports, "offchainLookup", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookup; } }));
Object.defineProperty(exports, "offchainLookupAbiItem", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookupAbiItem; } }));
Object.defineProperty(exports, "offchainLookupSignature", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookupSignature; } }));
var assertCurrentChain_js_1 = __webpack_require__(/*! ./chain/assertCurrentChain.js */ "../../node_modules/viem/_cjs/utils/chain/assertCurrentChain.js");
Object.defineProperty(exports, "assertCurrentChain", ({ enumerable: true, get: function () { return assertCurrentChain_js_1.assertCurrentChain; } }));
var defineChain_js_1 = __webpack_require__(/*! ./chain/defineChain.js */ "../../node_modules/viem/_cjs/utils/chain/defineChain.js");
Object.defineProperty(exports, "defineChain", ({ enumerable: true, get: function () { return defineChain_js_1.defineChain; } }));
var extractChain_js_1 = __webpack_require__(/*! ./chain/extractChain.js */ "../../node_modules/viem/_cjs/utils/chain/extractChain.js");
Object.defineProperty(exports, "extractChain", ({ enumerable: true, get: function () { return extractChain_js_1.extractChain; } }));
var getChainContractAddress_js_1 = __webpack_require__(/*! ./chain/getChainContractAddress.js */ "../../node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
Object.defineProperty(exports, "getChainContractAddress", ({ enumerable: true, get: function () { return getChainContractAddress_js_1.getChainContractAddress; } }));
var regex_js_1 = __webpack_require__(/*! ./regex.js */ "../../node_modules/viem/_cjs/utils/regex.js");
Object.defineProperty(exports, "arrayRegex", ({ enumerable: true, get: function () { return regex_js_1.arrayRegex; } }));
Object.defineProperty(exports, "bytesRegex", ({ enumerable: true, get: function () { return regex_js_1.bytesRegex; } }));
Object.defineProperty(exports, "integerRegex", ({ enumerable: true, get: function () { return regex_js_1.integerRegex; } }));
var rpc_js_1 = __webpack_require__(/*! ./rpc.js */ "../../node_modules/viem/_cjs/utils/rpc.js");
Object.defineProperty(exports, "getSocket", ({ enumerable: true, get: function () { return rpc_js_1.getSocket; } }));
Object.defineProperty(exports, "rpc", ({ enumerable: true, get: function () { return rpc_js_1.rpc; } }));
var stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return stringify_js_1.stringify; } }));
var typedData_js_1 = __webpack_require__(/*! ./typedData.js */ "../../node_modules/viem/_cjs/utils/typedData.js");
Object.defineProperty(exports, "validateTypedData", ({ enumerable: true, get: function () { return typedData_js_1.validateTypedData; } }));
var decodeAbiParameters_js_1 = __webpack_require__(/*! ./abi/decodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
Object.defineProperty(exports, "decodeAbiParameters", ({ enumerable: true, get: function () { return decodeAbiParameters_js_1.decodeAbiParameters; } }));
var decodeErrorResult_js_1 = __webpack_require__(/*! ./abi/decodeErrorResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeErrorResult.js");
Object.defineProperty(exports, "decodeErrorResult", ({ enumerable: true, get: function () { return decodeErrorResult_js_1.decodeErrorResult; } }));
var decodeEventLog_js_1 = __webpack_require__(/*! ./abi/decodeEventLog.js */ "../../node_modules/viem/_cjs/utils/abi/decodeEventLog.js");
Object.defineProperty(exports, "decodeEventLog", ({ enumerable: true, get: function () { return decodeEventLog_js_1.decodeEventLog; } }));
var decodeFunctionData_js_1 = __webpack_require__(/*! ./abi/decodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionData.js");
Object.defineProperty(exports, "decodeFunctionData", ({ enumerable: true, get: function () { return decodeFunctionData_js_1.decodeFunctionData; } }));
var decodeFunctionResult_js_1 = __webpack_require__(/*! ./abi/decodeFunctionResult.js */ "../../node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
Object.defineProperty(exports, "decodeFunctionResult", ({ enumerable: true, get: function () { return decodeFunctionResult_js_1.decodeFunctionResult; } }));
var encodeAbiParameters_js_1 = __webpack_require__(/*! ./abi/encodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
Object.defineProperty(exports, "encodeAbiParameters", ({ enumerable: true, get: function () { return encodeAbiParameters_js_1.encodeAbiParameters; } }));
var encodeDeployData_js_1 = __webpack_require__(/*! ./abi/encodeDeployData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeDeployData.js");
Object.defineProperty(exports, "encodeDeployData", ({ enumerable: true, get: function () { return encodeDeployData_js_1.encodeDeployData; } }));
var encodeErrorResult_js_1 = __webpack_require__(/*! ./abi/encodeErrorResult.js */ "../../node_modules/viem/_cjs/utils/abi/encodeErrorResult.js");
Object.defineProperty(exports, "encodeErrorResult", ({ enumerable: true, get: function () { return encodeErrorResult_js_1.encodeErrorResult; } }));
var encodeEventTopics_js_1 = __webpack_require__(/*! ./abi/encodeEventTopics.js */ "../../node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
Object.defineProperty(exports, "encodeEventTopics", ({ enumerable: true, get: function () { return encodeEventTopics_js_1.encodeEventTopics; } }));
var encodeFunctionData_js_1 = __webpack_require__(/*! ./abi/encodeFunctionData.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
Object.defineProperty(exports, "encodeFunctionData", ({ enumerable: true, get: function () { return encodeFunctionData_js_1.encodeFunctionData; } }));
var encodeFunctionResult_js_1 = __webpack_require__(/*! ./abi/encodeFunctionResult.js */ "../../node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js");
Object.defineProperty(exports, "encodeFunctionResult", ({ enumerable: true, get: function () { return encodeFunctionResult_js_1.encodeFunctionResult; } }));
var getAbiItem_js_1 = __webpack_require__(/*! ./abi/getAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/getAbiItem.js");
Object.defineProperty(exports, "getAbiItem", ({ enumerable: true, get: function () { return getAbiItem_js_1.getAbiItem; } }));
var abitype_1 = __webpack_require__(/*! abitype */ "../../node_modules/abitype/dist/cjs/index.js");
Object.defineProperty(exports, "parseAbi", ({ enumerable: true, get: function () { return abitype_1.parseAbi; } }));
Object.defineProperty(exports, "parseAbiItem", ({ enumerable: true, get: function () { return abitype_1.parseAbiItem; } }));
Object.defineProperty(exports, "parseAbiParameter", ({ enumerable: true, get: function () { return abitype_1.parseAbiParameter; } }));
Object.defineProperty(exports, "parseAbiParameters", ({ enumerable: true, get: function () { return abitype_1.parseAbiParameters; } }));
var encodePacked_js_1 = __webpack_require__(/*! ./abi/encodePacked.js */ "../../node_modules/viem/_cjs/utils/abi/encodePacked.js");
Object.defineProperty(exports, "encodePacked", ({ enumerable: true, get: function () { return encodePacked_js_1.encodePacked; } }));
var formatAbiItemWithArgs_js_1 = __webpack_require__(/*! ./abi/formatAbiItemWithArgs.js */ "../../node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js");
Object.defineProperty(exports, "formatAbiItemWithArgs", ({ enumerable: true, get: function () { return formatAbiItemWithArgs_js_1.formatAbiItemWithArgs; } }));
var formatAbiItem_js_1 = __webpack_require__(/*! ./abi/formatAbiItem.js */ "../../node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
Object.defineProperty(exports, "formatAbiItem", ({ enumerable: true, get: function () { return formatAbiItem_js_1.formatAbiItem; } }));
Object.defineProperty(exports, "formatAbiParams", ({ enumerable: true, get: function () { return formatAbiItem_js_1.formatAbiParams; } }));
var parseAccount_js_1 = __webpack_require__(/*! ../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
Object.defineProperty(exports, "parseAccount", ({ enumerable: true, get: function () { return parseAccount_js_1.parseAccount; } }));
var publicKeyToAddress_js_1 = __webpack_require__(/*! ../accounts/utils/publicKeyToAddress.js */ "../../node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js");
Object.defineProperty(exports, "publicKeyToAddress", ({ enumerable: true, get: function () { return publicKeyToAddress_js_1.publicKeyToAddress; } }));
var getContractAddress_js_1 = __webpack_require__(/*! ./address/getContractAddress.js */ "../../node_modules/viem/_cjs/utils/address/getContractAddress.js");
Object.defineProperty(exports, "getContractAddress", ({ enumerable: true, get: function () { return getContractAddress_js_1.getContractAddress; } }));
Object.defineProperty(exports, "getCreateAddress", ({ enumerable: true, get: function () { return getContractAddress_js_1.getCreateAddress; } }));
Object.defineProperty(exports, "getCreate2Address", ({ enumerable: true, get: function () { return getContractAddress_js_1.getCreate2Address; } }));
var getAddress_js_1 = __webpack_require__(/*! ./address/getAddress.js */ "../../node_modules/viem/_cjs/utils/address/getAddress.js");
Object.defineProperty(exports, "getAddress", ({ enumerable: true, get: function () { return getAddress_js_1.getAddress; } }));
var isAddress_js_1 = __webpack_require__(/*! ./address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
Object.defineProperty(exports, "isAddress", ({ enumerable: true, get: function () { return isAddress_js_1.isAddress; } }));
var isAddressEqual_js_1 = __webpack_require__(/*! ./address/isAddressEqual.js */ "../../node_modules/viem/_cjs/utils/address/isAddressEqual.js");
Object.defineProperty(exports, "isAddressEqual", ({ enumerable: true, get: function () { return isAddressEqual_js_1.isAddressEqual; } }));
var extractFunctionParts_js_1 = __webpack_require__(/*! ./contract/extractFunctionParts.js */ "../../node_modules/viem/_cjs/utils/contract/extractFunctionParts.js");
Object.defineProperty(exports, "extractFunctionName", ({ enumerable: true, get: function () { return extractFunctionParts_js_1.extractFunctionName; } }));
Object.defineProperty(exports, "extractFunctionParams", ({ enumerable: true, get: function () { return extractFunctionParts_js_1.extractFunctionParams; } }));
Object.defineProperty(exports, "extractFunctionType", ({ enumerable: true, get: function () { return extractFunctionParts_js_1.extractFunctionType; } }));
Object.defineProperty(exports, "extractFunctionParts", ({ enumerable: true, get: function () { return extractFunctionParts_js_1.extractFunctionParts; } }));
var concat_js_1 = __webpack_require__(/*! ./data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
Object.defineProperty(exports, "concat", ({ enumerable: true, get: function () { return concat_js_1.concat; } }));
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return concat_js_1.concatBytes; } }));
Object.defineProperty(exports, "concatHex", ({ enumerable: true, get: function () { return concat_js_1.concatHex; } }));
var isBytes_js_1 = __webpack_require__(/*! ./data/isBytes.js */ "../../node_modules/viem/_cjs/utils/data/isBytes.js");
Object.defineProperty(exports, "isBytes", ({ enumerable: true, get: function () { return isBytes_js_1.isBytes; } }));
var isHex_js_1 = __webpack_require__(/*! ./data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
Object.defineProperty(exports, "isHex", ({ enumerable: true, get: function () { return isHex_js_1.isHex; } }));
var pad_js_1 = __webpack_require__(/*! ./data/pad.js */ "../../node_modules/viem/_cjs/utils/data/pad.js");
Object.defineProperty(exports, "pad", ({ enumerable: true, get: function () { return pad_js_1.pad; } }));
Object.defineProperty(exports, "padBytes", ({ enumerable: true, get: function () { return pad_js_1.padBytes; } }));
Object.defineProperty(exports, "padHex", ({ enumerable: true, get: function () { return pad_js_1.padHex; } }));
var size_js_1 = __webpack_require__(/*! ./data/size.js */ "../../node_modules/viem/_cjs/utils/data/size.js");
Object.defineProperty(exports, "size", ({ enumerable: true, get: function () { return size_js_1.size; } }));
var slice_js_1 = __webpack_require__(/*! ./data/slice.js */ "../../node_modules/viem/_cjs/utils/data/slice.js");
Object.defineProperty(exports, "slice", ({ enumerable: true, get: function () { return slice_js_1.slice; } }));
Object.defineProperty(exports, "sliceBytes", ({ enumerable: true, get: function () { return slice_js_1.sliceBytes; } }));
Object.defineProperty(exports, "sliceHex", ({ enumerable: true, get: function () { return slice_js_1.sliceHex; } }));
var trim_js_1 = __webpack_require__(/*! ./data/trim.js */ "../../node_modules/viem/_cjs/utils/data/trim.js");
Object.defineProperty(exports, "trim", ({ enumerable: true, get: function () { return trim_js_1.trim; } }));
var block_js_1 = __webpack_require__(/*! ./formatters/block.js */ "../../node_modules/viem/_cjs/utils/formatters/block.js");
Object.defineProperty(exports, "defineBlock", ({ enumerable: true, get: function () { return block_js_1.defineBlock; } }));
Object.defineProperty(exports, "formatBlock", ({ enumerable: true, get: function () { return block_js_1.formatBlock; } }));
var transaction_js_1 = __webpack_require__(/*! ./formatters/transaction.js */ "../../node_modules/viem/_cjs/utils/formatters/transaction.js");
Object.defineProperty(exports, "defineTransaction", ({ enumerable: true, get: function () { return transaction_js_1.defineTransaction; } }));
Object.defineProperty(exports, "formatTransaction", ({ enumerable: true, get: function () { return transaction_js_1.formatTransaction; } }));
Object.defineProperty(exports, "transactionType", ({ enumerable: true, get: function () { return transaction_js_1.transactionType; } }));
var log_js_1 = __webpack_require__(/*! ./formatters/log.js */ "../../node_modules/viem/_cjs/utils/formatters/log.js");
Object.defineProperty(exports, "formatLog", ({ enumerable: true, get: function () { return log_js_1.formatLog; } }));
var transactionReceipt_js_1 = __webpack_require__(/*! ./formatters/transactionReceipt.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionReceipt.js");
Object.defineProperty(exports, "defineTransactionReceipt", ({ enumerable: true, get: function () { return transactionReceipt_js_1.defineTransactionReceipt; } }));
var transactionRequest_js_1 = __webpack_require__(/*! ./formatters/transactionRequest.js */ "../../node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
Object.defineProperty(exports, "defineTransactionRequest", ({ enumerable: true, get: function () { return transactionRequest_js_1.defineTransactionRequest; } }));
Object.defineProperty(exports, "formatTransactionRequest", ({ enumerable: true, get: function () { return transactionRequest_js_1.formatTransactionRequest; } }));
var extract_js_1 = __webpack_require__(/*! ./formatters/extract.js */ "../../node_modules/viem/_cjs/utils/formatters/extract.js");
Object.defineProperty(exports, "extract", ({ enumerable: true, get: function () { return extract_js_1.extract; } }));
var toRlp_js_1 = __webpack_require__(/*! ./encoding/toRlp.js */ "../../node_modules/viem/_cjs/utils/encoding/toRlp.js");
Object.defineProperty(exports, "toRlp", ({ enumerable: true, get: function () { return toRlp_js_1.toRlp; } }));
var toBytes_js_1 = __webpack_require__(/*! ./encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
Object.defineProperty(exports, "boolToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.boolToBytes; } }));
Object.defineProperty(exports, "toBytes", ({ enumerable: true, get: function () { return toBytes_js_1.toBytes; } }));
Object.defineProperty(exports, "hexToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.hexToBytes; } }));
Object.defineProperty(exports, "numberToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.numberToBytes; } }));
Object.defineProperty(exports, "stringToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.stringToBytes; } }));
var toHex_js_1 = __webpack_require__(/*! ./encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
Object.defineProperty(exports, "boolToHex", ({ enumerable: true, get: function () { return toHex_js_1.boolToHex; } }));
Object.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return toHex_js_1.bytesToHex; } }));
Object.defineProperty(exports, "toHex", ({ enumerable: true, get: function () { return toHex_js_1.toHex; } }));
Object.defineProperty(exports, "numberToHex", ({ enumerable: true, get: function () { return toHex_js_1.numberToHex; } }));
Object.defineProperty(exports, "stringToHex", ({ enumerable: true, get: function () { return toHex_js_1.stringToHex; } }));
var fromBytes_js_1 = __webpack_require__(/*! ./encoding/fromBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/fromBytes.js");
Object.defineProperty(exports, "bytesToBigInt", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToBigInt; } }));
Object.defineProperty(exports, "bytesToBigint", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToBigInt; } }));
Object.defineProperty(exports, "bytesToBool", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToBool; } }));
Object.defineProperty(exports, "bytesToNumber", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToNumber; } }));
Object.defineProperty(exports, "bytesToString", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToString; } }));
Object.defineProperty(exports, "fromBytes", ({ enumerable: true, get: function () { return fromBytes_js_1.fromBytes; } }));
var fromHex_js_1 = __webpack_require__(/*! ./encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
Object.defineProperty(exports, "fromHex", ({ enumerable: true, get: function () { return fromHex_js_1.fromHex; } }));
Object.defineProperty(exports, "hexToBool", ({ enumerable: true, get: function () { return fromHex_js_1.hexToBool; } }));
Object.defineProperty(exports, "hexToBigInt", ({ enumerable: true, get: function () { return fromHex_js_1.hexToBigInt; } }));
Object.defineProperty(exports, "hexToNumber", ({ enumerable: true, get: function () { return fromHex_js_1.hexToNumber; } }));
Object.defineProperty(exports, "hexToString", ({ enumerable: true, get: function () { return fromHex_js_1.hexToString; } }));
var fromRlp_js_1 = __webpack_require__(/*! ./encoding/fromRlp.js */ "../../node_modules/viem/_cjs/utils/encoding/fromRlp.js");
Object.defineProperty(exports, "fromRlp", ({ enumerable: true, get: function () { return fromRlp_js_1.fromRlp; } }));
var getNodeError_js_1 = __webpack_require__(/*! ./errors/getNodeError.js */ "../../node_modules/viem/_cjs/utils/errors/getNodeError.js");
Object.defineProperty(exports, "containsNodeError", ({ enumerable: true, get: function () { return getNodeError_js_1.containsNodeError; } }));
Object.defineProperty(exports, "getNodeError", ({ enumerable: true, get: function () { return getNodeError_js_1.getNodeError; } }));
var getCallError_js_1 = __webpack_require__(/*! ./errors/getCallError.js */ "../../node_modules/viem/_cjs/utils/errors/getCallError.js");
Object.defineProperty(exports, "getCallError", ({ enumerable: true, get: function () { return getCallError_js_1.getCallError; } }));
var getContractError_js_1 = __webpack_require__(/*! ./errors/getContractError.js */ "../../node_modules/viem/_cjs/utils/errors/getContractError.js");
Object.defineProperty(exports, "getContractError", ({ enumerable: true, get: function () { return getContractError_js_1.getContractError; } }));
var getEstimateGasError_js_1 = __webpack_require__(/*! ./errors/getEstimateGasError.js */ "../../node_modules/viem/_cjs/utils/errors/getEstimateGasError.js");
Object.defineProperty(exports, "getEstimateGasError", ({ enumerable: true, get: function () { return getEstimateGasError_js_1.getEstimateGasError; } }));
var getTransactionError_js_1 = __webpack_require__(/*! ./errors/getTransactionError.js */ "../../node_modules/viem/_cjs/utils/errors/getTransactionError.js");
Object.defineProperty(exports, "getTransactionError", ({ enumerable: true, get: function () { return getTransactionError_js_1.getTransactionError; } }));
var formatter_js_1 = __webpack_require__(/*! ./formatters/formatter.js */ "../../node_modules/viem/_cjs/utils/formatters/formatter.js");
Object.defineProperty(exports, "defineFormatter", ({ enumerable: true, get: function () { return formatter_js_1.defineFormatter; } }));
var getEventSelector_js_1 = __webpack_require__(/*! ./hash/getEventSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getEventSelector.js");
Object.defineProperty(exports, "getEventSelector", ({ enumerable: true, get: function () { return getEventSelector_js_1.getEventSelector; } }));
var getFunctionSelector_js_1 = __webpack_require__(/*! ./hash/getFunctionSelector.js */ "../../node_modules/viem/_cjs/utils/hash/getFunctionSelector.js");
Object.defineProperty(exports, "getFunctionSelector", ({ enumerable: true, get: function () { return getFunctionSelector_js_1.getFunctionSelector; } }));
var isHash_js_1 = __webpack_require__(/*! ./hash/isHash.js */ "../../node_modules/viem/_cjs/utils/hash/isHash.js");
Object.defineProperty(exports, "isHash", ({ enumerable: true, get: function () { return isHash_js_1.isHash; } }));
var keccak256_js_1 = __webpack_require__(/*! ./hash/keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
Object.defineProperty(exports, "keccak256", ({ enumerable: true, get: function () { return keccak256_js_1.keccak256; } }));
var sha256_js_1 = __webpack_require__(/*! ./hash/sha256.js */ "../../node_modules/viem/_cjs/utils/hash/sha256.js");
Object.defineProperty(exports, "sha256", ({ enumerable: true, get: function () { return sha256_js_1.sha256; } }));
var ripemd160_js_1 = __webpack_require__(/*! ./hash/ripemd160.js */ "../../node_modules/viem/_cjs/utils/hash/ripemd160.js");
Object.defineProperty(exports, "ripemd160", ({ enumerable: true, get: function () { return ripemd160_js_1.ripemd160; } }));
var hashTypedData_js_1 = __webpack_require__(/*! ./signature/hashTypedData.js */ "../../node_modules/viem/_cjs/utils/signature/hashTypedData.js");
Object.defineProperty(exports, "hashTypedData", ({ enumerable: true, get: function () { return hashTypedData_js_1.hashTypedData; } }));
var recoverAddress_js_1 = __webpack_require__(/*! ./signature/recoverAddress.js */ "../../node_modules/viem/_cjs/utils/signature/recoverAddress.js");
Object.defineProperty(exports, "recoverAddress", ({ enumerable: true, get: function () { return recoverAddress_js_1.recoverAddress; } }));
var recoverMessageAddress_js_1 = __webpack_require__(/*! ./signature/recoverMessageAddress.js */ "../../node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js");
Object.defineProperty(exports, "recoverMessageAddress", ({ enumerable: true, get: function () { return recoverMessageAddress_js_1.recoverMessageAddress; } }));
var recoverPublicKey_js_1 = __webpack_require__(/*! ./signature/recoverPublicKey.js */ "../../node_modules/viem/_cjs/utils/signature/recoverPublicKey.js");
Object.defineProperty(exports, "recoverPublicKey", ({ enumerable: true, get: function () { return recoverPublicKey_js_1.recoverPublicKey; } }));
var recoverTypedDataAddress_js_1 = __webpack_require__(/*! ./signature/recoverTypedDataAddress.js */ "../../node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js");
Object.defineProperty(exports, "recoverTypedDataAddress", ({ enumerable: true, get: function () { return recoverTypedDataAddress_js_1.recoverTypedDataAddress; } }));
var verifyMessage_js_1 = __webpack_require__(/*! ./signature/verifyMessage.js */ "../../node_modules/viem/_cjs/utils/signature/verifyMessage.js");
Object.defineProperty(exports, "verifyMessage", ({ enumerable: true, get: function () { return verifyMessage_js_1.verifyMessage; } }));
var verifyTypedData_js_1 = __webpack_require__(/*! ./signature/verifyTypedData.js */ "../../node_modules/viem/_cjs/utils/signature/verifyTypedData.js");
Object.defineProperty(exports, "verifyTypedData", ({ enumerable: true, get: function () { return verifyTypedData_js_1.verifyTypedData; } }));
var hashMessage_js_1 = __webpack_require__(/*! ./signature/hashMessage.js */ "../../node_modules/viem/_cjs/utils/signature/hashMessage.js");
Object.defineProperty(exports, "hashMessage", ({ enumerable: true, get: function () { return hashMessage_js_1.hashMessage; } }));
var getSerializedTransactionType_js_1 = __webpack_require__(/*! ./transaction/getSerializedTransactionType.js */ "../../node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js");
Object.defineProperty(exports, "getSerializedTransactionType", ({ enumerable: true, get: function () { return getSerializedTransactionType_js_1.getSerializedTransactionType; } }));
var getTransactionType_js_1 = __webpack_require__(/*! ./transaction/getTransactionType.js */ "../../node_modules/viem/_cjs/utils/transaction/getTransactionType.js");
Object.defineProperty(exports, "getTransactionType", ({ enumerable: true, get: function () { return getTransactionType_js_1.getTransactionType; } }));
var assertRequest_js_1 = __webpack_require__(/*! ./transaction/assertRequest.js */ "../../node_modules/viem/_cjs/utils/transaction/assertRequest.js");
Object.defineProperty(exports, "assertRequest", ({ enumerable: true, get: function () { return assertRequest_js_1.assertRequest; } }));
var assertTransaction_js_1 = __webpack_require__(/*! ./transaction/assertTransaction.js */ "../../node_modules/viem/_cjs/utils/transaction/assertTransaction.js");
Object.defineProperty(exports, "assertTransactionEIP1559", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP1559; } }));
Object.defineProperty(exports, "assertTransactionEIP2930", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP2930; } }));
Object.defineProperty(exports, "assertTransactionLegacy", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionLegacy; } }));
var parseTransaction_js_1 = __webpack_require__(/*! ./transaction/parseTransaction.js */ "../../node_modules/viem/_cjs/utils/transaction/parseTransaction.js");
Object.defineProperty(exports, "parseTransaction", ({ enumerable: true, get: function () { return parseTransaction_js_1.parseTransaction; } }));
var prepareTransactionRequest_js_1 = __webpack_require__(/*! ../actions/wallet/prepareTransactionRequest.js */ "../../node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js");
Object.defineProperty(exports, "prepareTransactionRequest", ({ enumerable: true, get: function () { return prepareTransactionRequest_js_1.prepareTransactionRequest; } }));
var serializeTransaction_js_1 = __webpack_require__(/*! ./transaction/serializeTransaction.js */ "../../node_modules/viem/_cjs/utils/transaction/serializeTransaction.js");
Object.defineProperty(exports, "serializeTransaction", ({ enumerable: true, get: function () { return serializeTransaction_js_1.serializeTransaction; } }));
var serializeAccessList_js_1 = __webpack_require__(/*! ./transaction/serializeAccessList.js */ "../../node_modules/viem/_cjs/utils/transaction/serializeAccessList.js");
Object.defineProperty(exports, "serializeAccessList", ({ enumerable: true, get: function () { return serializeAccessList_js_1.serializeAccessList; } }));
var formatEther_js_1 = __webpack_require__(/*! ./unit/formatEther.js */ "../../node_modules/viem/_cjs/utils/unit/formatEther.js");
Object.defineProperty(exports, "formatEther", ({ enumerable: true, get: function () { return formatEther_js_1.formatEther; } }));
var formatGwei_js_1 = __webpack_require__(/*! ./unit/formatGwei.js */ "../../node_modules/viem/_cjs/utils/unit/formatGwei.js");
Object.defineProperty(exports, "formatGwei", ({ enumerable: true, get: function () { return formatGwei_js_1.formatGwei; } }));
var formatUnits_js_1 = __webpack_require__(/*! ./unit/formatUnits.js */ "../../node_modules/viem/_cjs/utils/unit/formatUnits.js");
Object.defineProperty(exports, "formatUnits", ({ enumerable: true, get: function () { return formatUnits_js_1.formatUnits; } }));
var parseUnits_js_1 = __webpack_require__(/*! ./unit/parseUnits.js */ "../../node_modules/viem/_cjs/utils/unit/parseUnits.js");
Object.defineProperty(exports, "parseUnits", ({ enumerable: true, get: function () { return parseUnits_js_1.parseUnits; } }));
var parseEther_js_1 = __webpack_require__(/*! ./unit/parseEther.js */ "../../node_modules/viem/_cjs/utils/unit/parseEther.js");
Object.defineProperty(exports, "parseEther", ({ enumerable: true, get: function () { return parseEther_js_1.parseEther; } }));
var parseGwei_js_1 = __webpack_require__(/*! ./unit/parseGwei.js */ "../../node_modules/viem/_cjs/utils/unit/parseGwei.js");
Object.defineProperty(exports, "parseGwei", ({ enumerable: true, get: function () { return parseGwei_js_1.parseGwei; } }));


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/observe.js":
/*!*****************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/observe.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.observe = exports.cleanupCache = exports.listenersCache = void 0;
exports.listenersCache = new Map();
exports.cleanupCache = new Map();
let callbackCount = 0;
function observe(observerId, callbacks, fn) {
    const callbackId = ++callbackCount;
    const getListeners = () => exports.listenersCache.get(observerId) || [];
    const unsubscribe = () => {
        const listeners = getListeners();
        exports.listenersCache.set(observerId, listeners.filter((cb) => cb.id !== callbackId));
    };
    const unwatch = () => {
        const cleanup = exports.cleanupCache.get(observerId);
        if (getListeners().length === 1 && cleanup)
            cleanup();
        unsubscribe();
    };
    const listeners = getListeners();
    exports.listenersCache.set(observerId, [
        ...listeners,
        { id: callbackId, fns: callbacks },
    ]);
    if (listeners && listeners.length > 0)
        return unwatch;
    const emit = {};
    for (const key in callbacks) {
        emit[key] = ((...args) => {
            const listeners = getListeners();
            if (listeners.length === 0)
                return;
            for (const listener of listeners)
                listener.fns[key]?.(...args);
        });
    }
    const cleanup = fn(emit);
    if (typeof cleanup === 'function')
        exports.cleanupCache.set(observerId, cleanup);
    return unwatch;
}
exports.observe = observe;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/poll.js":
/*!**************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/poll.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.poll = void 0;
const wait_js_1 = __webpack_require__(/*! ./wait.js */ "../../node_modules/viem/_cjs/utils/wait.js");
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
    let active = true;
    const unwatch = () => (active = false);
    const watch = async () => {
        let data = undefined;
        if (emitOnBegin)
            data = await fn({ unpoll: unwatch });
        const initialWait = (await initialWaitTime?.(data)) ?? interval;
        await (0, wait_js_1.wait)(initialWait);
        const poll = async () => {
            if (!active)
                return;
            await fn({ unpoll: unwatch });
            await (0, wait_js_1.wait)(interval);
            poll();
        };
        poll();
    };
    watch();
    return unwatch;
}
exports.poll = poll;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/promise/createBatchScheduler.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/promise/createBatchScheduler.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createBatchScheduler = void 0;
const schedulerCache = new Map();
function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort, }) {
    const exec = async () => {
        const scheduler = getScheduler();
        flush();
        const args = scheduler.map(({ args }) => args);
        if (args.length === 0)
            return;
        fn(args)
            .then((data) => {
            if (sort && Array.isArray(data))
                data.sort(sort);
            for (let i = 0; i < scheduler.length; i++) {
                const { pendingPromise } = scheduler[i];
                pendingPromise.resolve?.([data[i], data]);
            }
        })
            .catch((err) => {
            for (let i = 0; i < scheduler.length; i++) {
                const { pendingPromise } = scheduler[i];
                pendingPromise.reject?.(err);
            }
        });
    };
    const flush = () => schedulerCache.delete(id);
    const getBatchedArgs = () => getScheduler().map(({ args }) => args);
    const getScheduler = () => schedulerCache.get(id) || [];
    const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
    return {
        flush,
        async schedule(args) {
            const pendingPromise = {};
            const promise = new Promise((resolve, reject) => {
                pendingPromise.resolve = resolve;
                pendingPromise.reject = reject;
            });
            const split = shouldSplitBatch?.([...getBatchedArgs(), args]);
            if (split)
                exec();
            const hasActiveScheduler = getScheduler().length > 0;
            if (hasActiveScheduler) {
                setScheduler({ args, pendingPromise });
                return promise;
            }
            setScheduler({ args, pendingPromise });
            setTimeout(exec, wait);
            return promise;
        },
    };
}
exports.createBatchScheduler = createBatchScheduler;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/promise/withCache.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/promise/withCache.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withCache = exports.getCache = exports.responseCache = exports.promiseCache = void 0;
exports.promiseCache = new Map();
exports.responseCache = new Map();
function getCache(cacheKey) {
    const buildCache = (cacheKey, cache) => ({
        clear: () => cache.delete(cacheKey),
        get: () => cache.get(cacheKey),
        set: (data) => cache.set(cacheKey, data),
    });
    const promise = buildCache(cacheKey, exports.promiseCache);
    const response = buildCache(cacheKey, exports.responseCache);
    return {
        clear: () => {
            promise.clear();
            response.clear();
        },
        promise,
        response,
    };
}
exports.getCache = getCache;
async function withCache(fn, { cacheKey, cacheTime = Infinity }) {
    const cache = getCache(cacheKey);
    const response = cache.response.get();
    if (response && cacheTime > 0) {
        const age = new Date().getTime() - response.created.getTime();
        if (age < cacheTime)
            return response.data;
    }
    let promise = cache.promise.get();
    if (!promise) {
        promise = fn();
        cache.promise.set(promise);
    }
    try {
        const data = await promise;
        cache.response.set({ created: new Date(), data });
        return data;
    }
    finally {
        cache.promise.clear();
    }
}
exports.withCache = withCache;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/promise/withRetry.js":
/*!***************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/promise/withRetry.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withRetry = void 0;
const wait_js_1 = __webpack_require__(/*! ../wait.js */ "../../node_modules/viem/_cjs/utils/wait.js");
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true, } = {}) {
    return new Promise((resolve, reject) => {
        const attemptRetry = async ({ count = 0 } = {}) => {
            const retry = async ({ error }) => {
                const delay = typeof delay_ === 'function' ? delay_({ count, error }) : delay_;
                if (delay)
                    await (0, wait_js_1.wait)(delay);
                attemptRetry({ count: count + 1 });
            };
            try {
                const data = await fn();
                resolve(data);
            }
            catch (err) {
                if (count < retryCount &&
                    (await shouldRetry({ count, error: err })))
                    return retry({ error: err });
                reject(err);
            }
        };
        attemptRetry();
    });
}
exports.withRetry = withRetry;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/promise/withTimeout.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/promise/withTimeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withTimeout = void 0;
function withTimeout(fn, { errorInstance = new Error('timed out'), timeout, signal, }) {
    return new Promise((resolve, reject) => {
        ;
        (async () => {
            let timeoutId;
            try {
                const controller = new AbortController();
                if (timeout > 0) {
                    timeoutId = setTimeout(() => {
                        if (signal) {
                            controller.abort();
                        }
                        else {
                            reject(errorInstance);
                        }
                    }, timeout);
                }
                resolve(await fn({ signal: controller?.signal }));
            }
            catch (err) {
                if (err.name === 'AbortError')
                    reject(errorInstance);
                reject(err);
            }
            finally {
                clearTimeout(timeoutId);
            }
        })();
    });
}
exports.withTimeout = withTimeout;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/regex.js":
/*!***************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/regex.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.integerRegex = exports.bytesRegex = exports.arrayRegex = void 0;
exports.arrayRegex = /^(.*)\[([0-9]*)\]$/;
exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
exports.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/rpc.js":
/*!*************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/rpc.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rpc = exports.getSocket = exports.socketsCache = void 0;
const isows_1 = __webpack_require__(/*! isows */ "../../node_modules/isows/_esm/native.js");
const request_js_1 = __webpack_require__(/*! ../errors/request.js */ "../../node_modules/viem/_cjs/errors/request.js");
const createBatchScheduler_js_1 = __webpack_require__(/*! ./promise/createBatchScheduler.js */ "../../node_modules/viem/_cjs/utils/promise/createBatchScheduler.js");
const withTimeout_js_1 = __webpack_require__(/*! ./promise/withTimeout.js */ "../../node_modules/viem/_cjs/utils/promise/withTimeout.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "../../node_modules/viem/_cjs/utils/stringify.js");
let id = 0;
async function http(url, { body, fetchOptions = {}, timeout = 10000 }) {
    const { headers, method, signal: signal_ } = fetchOptions;
    try {
        const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {
            const response = await fetch(url, {
                ...fetchOptions,
                body: Array.isArray(body)
                    ? (0, stringify_js_1.stringify)(body.map((body) => ({
                        jsonrpc: '2.0',
                        id: body.id ?? id++,
                        ...body,
                    })))
                    : (0, stringify_js_1.stringify)({ jsonrpc: '2.0', id: body.id ?? id++, ...body }),
                headers: {
                    ...headers,
                    'Content-Type': 'application/json',
                },
                method: method || 'POST',
                signal: signal_ || (timeout > 0 ? signal : undefined),
            });
            return response;
        }, {
            errorInstance: new request_js_1.TimeoutError({ body, url }),
            timeout,
            signal: true,
        });
        let data;
        if (response.headers.get('Content-Type')?.startsWith('application/json')) {
            data = await response.json();
        }
        else {
            data = await response.text();
        }
        if (!response.ok) {
            throw new request_js_1.HttpRequestError({
                body,
                details: (0, stringify_js_1.stringify)(data.error) || response.statusText,
                headers: response.headers,
                status: response.status,
                url,
            });
        }
        return data;
    }
    catch (err) {
        if (err instanceof request_js_1.HttpRequestError)
            throw err;
        if (err instanceof request_js_1.TimeoutError)
            throw err;
        throw new request_js_1.HttpRequestError({
            body,
            details: err.message,
            url,
        });
    }
}
exports.socketsCache = new Map();
async function getSocket(url) {
    let socket = exports.socketsCache.get(url);
    if (socket)
        return socket;
    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: url,
        fn: async () => {
            const webSocket = new isows_1.WebSocket(url);
            const requests = new Map();
            const subscriptions = new Map();
            const onMessage = ({ data }) => {
                const message = JSON.parse(data);
                const isSubscription = message.method === 'eth_subscription';
                const id = isSubscription ? message.params.subscription : message.id;
                const cache = isSubscription ? subscriptions : requests;
                const callback = cache.get(id);
                if (callback)
                    callback({ data });
                if (!isSubscription)
                    cache.delete(id);
            };
            const onClose = () => {
                exports.socketsCache.delete(url);
                webSocket.removeEventListener('close', onClose);
                webSocket.removeEventListener('message', onMessage);
            };
            webSocket.addEventListener('close', onClose);
            webSocket.addEventListener('message', onMessage);
            if (webSocket.readyState === isows_1.WebSocket.CONNECTING) {
                await new Promise((resolve, reject) => {
                    if (!webSocket)
                        return;
                    webSocket.onopen = resolve;
                    webSocket.onerror = reject;
                });
            }
            socket = Object.assign(webSocket, {
                requests,
                subscriptions,
            });
            exports.socketsCache.set(url, socket);
            return [socket];
        },
    });
    const [_, [socket_]] = await schedule();
    return socket_;
}
exports.getSocket = getSocket;
function webSocket(socket, { body, onResponse }) {
    if (socket.readyState === socket.CLOSED ||
        socket.readyState === socket.CLOSING)
        throw new request_js_1.WebSocketRequestError({
            body,
            url: socket.url,
            details: 'Socket is closed.',
        });
    const id_ = id++;
    const callback = ({ data }) => {
        const message = JSON.parse(data);
        if (typeof message.id === 'number' && id_ !== message.id)
            return;
        onResponse?.(message);
        if (body.method === 'eth_subscribe' && typeof message.result === 'string') {
            socket.subscriptions.set(message.result, callback);
        }
        if (body.method === 'eth_unsubscribe') {
            socket.subscriptions.delete(body.params?.[0]);
        }
    };
    socket.requests.set(id_, callback);
    socket.send(JSON.stringify({ jsonrpc: '2.0', ...body, id: id_ }));
    return socket;
}
async function webSocketAsync(socket, { body, timeout = 10000 }) {
    return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse) => exports.rpc.webSocket(socket, {
        body,
        onResponse,
    })), {
        errorInstance: new request_js_1.TimeoutError({ body, url: socket.url }),
        timeout,
    });
}
exports.rpc = {
    http,
    webSocket,
    webSocketAsync,
};


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/compactSignatureToHex.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/compactSignatureToHex.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compactSignatureToHex = void 0;
const secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "../../node_modules/@noble/curves/secp256k1.js");
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
function compactSignatureToHex({ r, yParityAndS, }) {
    return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(yParityAndS)).toCompactHex()}`;
}
exports.compactSignatureToHex = compactSignatureToHex;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/compactSignatureToSignature.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/compactSignatureToSignature.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compactSignatureToSignature = void 0;
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
function compactSignatureToSignature({ r, yParityAndS, }) {
    const yParityAndS_bytes = (0, toBytes_js_1.hexToBytes)(yParityAndS);
    const v = yParityAndS_bytes[0] & 0x80 ? 28n : 27n;
    const s = yParityAndS_bytes;
    if (v === 28n)
        s[0] &= 0x7f;
    return { r, s: (0, toHex_js_1.bytesToHex)(s), v };
}
exports.compactSignatureToSignature = compactSignatureToSignature;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/hashMessage.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/hashMessage.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashMessage = void 0;
const strings_js_1 = __webpack_require__(/*! ../../constants/strings.js */ "../../node_modules/viem/_cjs/constants/strings.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "../../node_modules/viem/_cjs/utils/encoding/toBytes.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
function hashMessage(message, to_) {
    const messageBytes = (() => {
        if (typeof message === 'string')
            return (0, toBytes_js_1.stringToBytes)(message);
        if (message.raw instanceof Uint8Array)
            return message.raw;
        return (0, toBytes_js_1.toBytes)(message.raw);
    })();
    const prefixBytes = (0, toBytes_js_1.stringToBytes)(`${strings_js_1.presignMessagePrefix}${messageBytes.length}`);
    return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([prefixBytes, messageBytes]), to_);
}
exports.hashMessage = hashMessage;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/hashTypedData.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/hashTypedData.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashDomain = exports.hashTypedData = void 0;
const encodeAbiParameters_js_1 = __webpack_require__(/*! ../abi/encodeAbiParameters.js */ "../../node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "../../node_modules/viem/_cjs/utils/hash/keccak256.js");
const typedData_js_1 = __webpack_require__(/*! ../typedData.js */ "../../node_modules/viem/_cjs/utils/typedData.js");
function hashTypedData({ domain: domain_, message, primaryType, types: types_, }) {
    const domain = typeof domain_ === 'undefined' ? {} : domain_;
    const types = {
        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
        ...types_,
    };
    (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types,
    });
    const parts = ['0x1901'];
    if (domain)
        parts.push(hashDomain({
            domain,
            types: types,
        }));
    if (primaryType !== 'EIP712Domain') {
        parts.push(hashStruct({
            data: message,
            primaryType: primaryType,
            types: types,
        }));
    }
    return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)(parts));
}
exports.hashTypedData = hashTypedData;
function hashDomain({ domain, types, }) {
    return hashStruct({
        data: domain,
        primaryType: 'EIP712Domain',
        types,
    });
}
exports.hashDomain = hashDomain;
function hashStruct({ data, primaryType, types, }) {
    const encoded = encodeData({
        data,
        primaryType,
        types,
    });
    return (0, keccak256_js_1.keccak256)(encoded);
}
function encodeData({ data, primaryType, types, }) {
    const encodedTypes = [{ type: 'bytes32' }];
    const encodedValues = [hashType({ primaryType, types })];
    for (const field of types[primaryType]) {
        const [type, value] = encodeField({
            types,
            name: field.name,
            type: field.type,
            value: data[field.name],
        });
        encodedTypes.push(type);
        encodedValues.push(value);
    }
    return (0, encodeAbiParameters_js_1.encodeAbiParameters)(encodedTypes, encodedValues);
}
function hashType({ primaryType, types, }) {
    const encodedHashType = (0, toHex_js_1.toHex)(encodeType({ primaryType, types }));
    return (0, keccak256_js_1.keccak256)(encodedHashType);
}
function encodeType({ primaryType, types, }) {
    let result = '';
    const unsortedDeps = findTypeDependencies({ primaryType, types });
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
        result += `${type}(${types[type]
            .map(({ name, type: t }) => `${t} ${name}`)
            .join(',')})`;
    }
    return result;
}
function findTypeDependencies({ primaryType: primaryType_, types, }, results = new Set()) {
    const match = primaryType_.match(/^\w*/u);
    const primaryType = match?.[0];
    if (results.has(primaryType) || types[primaryType] === undefined) {
        return results;
    }
    results.add(primaryType);
    for (const field of types[primaryType]) {
        findTypeDependencies({ primaryType: field.type, types }, results);
    }
    return results;
}
function encodeField({ types, name, type, value, }) {
    if (types[type] !== undefined) {
        return [
            { type: 'bytes32' },
            (0, keccak256_js_1.keccak256)(encodeData({ data: value, primaryType: type, types })),
        ];
    }
    if (type === 'bytes') {
        const prepend = value.length % 2 ? '0' : '';
        value = `0x${prepend + value.slice(2)}`;
        return [{ type: 'bytes32' }, (0, keccak256_js_1.keccak256)(value)];
    }
    if (type === 'string')
        return [{ type: 'bytes32' }, (0, keccak256_js_1.keccak256)((0, toHex_js_1.toHex)(value))];
    if (type.lastIndexOf(']') === type.length - 1) {
        const parsedType = type.slice(0, type.lastIndexOf('['));
        const typeValuePairs = value.map((item) => encodeField({
            name,
            type: parsedType,
            types,
            value: item,
        }));
        return [
            { type: 'bytes32' },
            (0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),
        ];
    }
    return [{ type }, value];
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/hexToCompactSignature.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/hexToCompactSignature.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexToCompactSignature = void 0;
const secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "../../node_modules/@noble/curves/secp256k1.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
function hexToCompactSignature(signatureHex) {
    const { r, s } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
    return {
        r: (0, toHex_js_1.numberToHex)(r, { size: 32 }),
        yParityAndS: (0, toHex_js_1.numberToHex)(s, { size: 32 }),
    };
}
exports.hexToCompactSignature = hexToCompactSignature;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/hexToSignature.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/hexToSignature.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexToSignature = void 0;
const secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "../../node_modules/@noble/curves/secp256k1.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
function hexToSignature(signatureHex) {
    const { r, s } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
    const v = BigInt(`0x${signatureHex.slice(130)}`);
    return { r: (0, toHex_js_1.numberToHex)(r, { size: 32 }), s: (0, toHex_js_1.numberToHex)(s, { size: 32 }), v };
}
exports.hexToSignature = hexToSignature;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/recoverAddress.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/recoverAddress.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recoverAddress = void 0;
const publicKeyToAddress_js_1 = __webpack_require__(/*! ../../accounts/utils/publicKeyToAddress.js */ "../../node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js");
const recoverPublicKey_js_1 = __webpack_require__(/*! ./recoverPublicKey.js */ "../../node_modules/viem/_cjs/utils/signature/recoverPublicKey.js");
async function recoverAddress({ hash, signature, }) {
    return (0, publicKeyToAddress_js_1.publicKeyToAddress)(await (0, recoverPublicKey_js_1.recoverPublicKey)({ hash: hash, signature }));
}
exports.recoverAddress = recoverAddress;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recoverMessageAddress = void 0;
const hashMessage_js_1 = __webpack_require__(/*! ./hashMessage.js */ "../../node_modules/viem/_cjs/utils/signature/hashMessage.js");
const recoverAddress_js_1 = __webpack_require__(/*! ./recoverAddress.js */ "../../node_modules/viem/_cjs/utils/signature/recoverAddress.js");
async function recoverMessageAddress({ message, signature, }) {
    return (0, recoverAddress_js_1.recoverAddress)({ hash: (0, hashMessage_js_1.hashMessage)(message), signature });
}
exports.recoverMessageAddress = recoverMessageAddress;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/recoverPublicKey.js":
/*!************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/recoverPublicKey.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recoverPublicKey = void 0;
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
async function recoverPublicKey({ hash, signature, }) {
    const signatureHex = (0, isHex_js_1.isHex)(signature) ? signature : (0, toHex_js_1.toHex)(signature);
    const hashHex = (0, isHex_js_1.isHex)(hash) ? hash : (0, toHex_js_1.toHex)(hash);
    let v = (0, fromHex_js_1.hexToNumber)(`0x${signatureHex.slice(130)}`);
    if (v === 0 || v === 1)
        v += 27;
    const { secp256k1 } = await Promise.resolve().then(() => __webpack_require__(/*! @noble/curves/secp256k1 */ "../../node_modules/@noble/curves/secp256k1.js"));
    const publicKey = secp256k1.Signature.fromCompact(signatureHex.substring(2, 130))
        .addRecoveryBit(v - 27)
        .recoverPublicKey(hashHex.substring(2))
        .toHex(false);
    return `0x${publicKey}`;
}
exports.recoverPublicKey = recoverPublicKey;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recoverTypedDataAddress = void 0;
const hashTypedData_js_1 = __webpack_require__(/*! ./hashTypedData.js */ "../../node_modules/viem/_cjs/utils/signature/hashTypedData.js");
const recoverAddress_js_1 = __webpack_require__(/*! ./recoverAddress.js */ "../../node_modules/viem/_cjs/utils/signature/recoverAddress.js");
async function recoverTypedDataAddress({ domain, message, primaryType, signature, types, }) {
    return (0, recoverAddress_js_1.recoverAddress)({
        hash: (0, hashTypedData_js_1.hashTypedData)({
            domain,
            message,
            primaryType,
            types,
        }),
        signature,
    });
}
exports.recoverTypedDataAddress = recoverTypedDataAddress;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/signatureToCompactSignature.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/signatureToCompactSignature.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signatureToCompactSignature = void 0;
const index_js_1 = __webpack_require__(/*! ../index.js */ "../../node_modules/viem/_cjs/utils/index.js");
function signatureToCompactSignature(signature) {
    const { r, s, v } = signature;
    const yParity = v - 27n;
    let yParityAndS = s;
    if (yParity === 1n) {
        const bytes = (0, index_js_1.hexToBytes)(s);
        bytes[0] |= 0x80;
        yParityAndS = (0, index_js_1.bytesToHex)(bytes);
    }
    return { r, yParityAndS };
}
exports.signatureToCompactSignature = signatureToCompactSignature;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/signatureToHex.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/signatureToHex.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signatureToHex = void 0;
const secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "../../node_modules/@noble/curves/secp256k1.js");
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
function signatureToHex({ r, s, v }) {
    return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(s)).toCompactHex()}${(0, toHex_js_1.toHex)(v).slice(2)}`;
}
exports.signatureToHex = signatureToHex;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/verifyMessage.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/verifyMessage.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyMessage = void 0;
const getAddress_js_1 = __webpack_require__(/*! ../address/getAddress.js */ "../../node_modules/viem/_cjs/utils/address/getAddress.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ../address/isAddressEqual.js */ "../../node_modules/viem/_cjs/utils/address/isAddressEqual.js");
const recoverMessageAddress_js_1 = __webpack_require__(/*! ./recoverMessageAddress.js */ "../../node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js");
async function verifyMessage({ address, message, signature, }) {
    return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverMessageAddress_js_1.recoverMessageAddress)({ message, signature }));
}
exports.verifyMessage = verifyMessage;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/signature/verifyTypedData.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/signature/verifyTypedData.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyTypedData = void 0;
const getAddress_js_1 = __webpack_require__(/*! ../address/getAddress.js */ "../../node_modules/viem/_cjs/utils/address/getAddress.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ../address/isAddressEqual.js */ "../../node_modules/viem/_cjs/utils/address/isAddressEqual.js");
const recoverTypedDataAddress_js_1 = __webpack_require__(/*! ./recoverTypedDataAddress.js */ "../../node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js");
async function verifyTypedData({ address, domain, message, primaryType, signature, types, }) {
    return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverTypedDataAddress_js_1.recoverTypedDataAddress)({
        domain,
        message,
        primaryType,
        signature,
        types,
    }));
}
exports.verifyTypedData = verifyTypedData;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/stringify.js":
/*!*******************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/stringify.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringify = void 0;
const stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
    const value = typeof value_ === 'bigint' ? value_.toString() : value_;
    return typeof replacer === 'function' ? replacer(key, value) : value;
}, space);
exports.stringify = stringify;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/transaction/assertRequest.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/transaction/assertRequest.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertRequest = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "../../node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "../../node_modules/viem/_cjs/errors/node.js");
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
function assertRequest(args) {
    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to, } = args;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
    if (account && !(0, isAddress_js_1.isAddress)(account.address))
        throw new address_js_1.InvalidAddressError({ address: account.address });
    if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
    if (typeof gasPrice !== 'undefined' &&
        (typeof maxFeePerGas !== 'undefined' ||
            typeof maxPriorityFeePerGas !== 'undefined'))
        throw new transaction_js_1.FeeConflictError();
    if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas &&
        maxFeePerGas &&
        maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
exports.assertRequest = assertRequest;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/transaction/assertTransaction.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/transaction/assertTransaction.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = void 0;
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "../../node_modules/viem/_cjs/errors/base.js");
const chain_js_1 = __webpack_require__(/*! ../../errors/chain.js */ "../../node_modules/viem/_cjs/errors/chain.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "../../node_modules/viem/_cjs/errors/node.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
function assertTransactionEIP1559(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
    if (gasPrice)
        throw new base_js_1.BaseError('`gasPrice` is not a valid EIP-1559 Transaction attribute.');
    if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas &&
        maxFeePerGas &&
        maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
exports.assertTransactionEIP1559 = assertTransactionEIP1559;
function assertTransactionEIP2930(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
    if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.');
    if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
}
exports.assertTransactionEIP2930 = assertTransactionEIP2930;
function assertTransactionLegacy(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList, } = transaction;
    if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
    if (typeof chainId !== 'undefined' && chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
    if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.');
    if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
    if (accessList)
        throw new base_js_1.BaseError('`accessList` is not a valid Legacy Transaction attribute.');
}
exports.assertTransactionLegacy = assertTransactionLegacy;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSerializedTransactionType = void 0;
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "../../node_modules/viem/_cjs/utils/data/slice.js");
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
function getSerializedTransactionType(serializedTransaction) {
    const serializedType = (0, slice_js_1.sliceHex)(serializedTransaction, 0, 1);
    if (serializedType === '0x02')
        return 'eip1559';
    if (serializedType === '0x01')
        return 'eip2930';
    if (serializedType !== '0x' && (0, fromHex_js_1.hexToNumber)(serializedType) >= 0xc0)
        return 'legacy';
    throw new transaction_js_1.InvalidSerializedTransactionTypeError({ serializedType });
}
exports.getSerializedTransactionType = getSerializedTransactionType;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/transaction/getTransactionType.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/transaction/getTransactionType.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransactionType = void 0;
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
function getTransactionType(transaction) {
    if (transaction.type)
        return transaction.type;
    if (typeof transaction.maxFeePerGas !== 'undefined' ||
        typeof transaction.maxPriorityFeePerGas !== 'undefined')
        return 'eip1559';
    if (typeof transaction.gasPrice !== 'undefined') {
        if (typeof transaction.accessList !== 'undefined')
            return 'eip2930';
        return 'legacy';
    }
    throw new transaction_js_1.InvalidSerializableTransactionError({ transaction });
}
exports.getTransactionType = getTransactionType;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/transaction/parseTransaction.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/transaction/parseTransaction.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAccessList = exports.toTransactionArray = exports.parseTransaction = void 0;
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "../../node_modules/viem/_cjs/utils/data/isHex.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "../../node_modules/viem/_cjs/utils/data/pad.js");
const trim_js_1 = __webpack_require__(/*! ../data/trim.js */ "../../node_modules/viem/_cjs/utils/data/trim.js");
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "../../node_modules/viem/_cjs/utils/encoding/fromHex.js");
const fromRlp_js_1 = __webpack_require__(/*! ../encoding/fromRlp.js */ "../../node_modules/viem/_cjs/utils/encoding/fromRlp.js");
const isHash_js_1 = __webpack_require__(/*! ../hash/isHash.js */ "../../node_modules/viem/_cjs/utils/hash/isHash.js");
const assertTransaction_js_1 = __webpack_require__(/*! ./assertTransaction.js */ "../../node_modules/viem/_cjs/utils/transaction/assertTransaction.js");
const getSerializedTransactionType_js_1 = __webpack_require__(/*! ./getSerializedTransactionType.js */ "../../node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js");
function parseTransaction(serializedTransaction) {
    const type = (0, getSerializedTransactionType_js_1.getSerializedTransactionType)(serializedTransaction);
    if (type === 'eip1559')
        return parseTransactionEIP1559(serializedTransaction);
    if (type === 'eip2930')
        return parseTransactionEIP2930(serializedTransaction);
    return parseTransactionLegacy(serializedTransaction);
}
exports.parseTransaction = parseTransaction;
function parseTransactionEIP1559(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s,] = transactionArray;
    if (!(transactionArray.length === 9 || transactionArray.length === 12))
        throw new transaction_js_1.InvalidSerializedTransactionError({
            attributes: {
                chainId,
                nonce,
                maxPriorityFeePerGas,
                maxFeePerGas,
                gas,
                to,
                value,
                data,
                accessList,
                ...(transactionArray.length > 9
                    ? {
                        v,
                        r,
                        s,
                    }
                    : {}),
            },
            serializedTransaction,
            type: 'eip1559',
        });
    const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: 'eip1559',
    };
    if ((0, isHex_js_1.isHex)(to) && to !== '0x')
        transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== '0x')
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== '0x')
        transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce) && nonce !== '0x')
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== '0x')
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== '0x')
        transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);
    if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')
        transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== '0x')
        transaction.accessList = parseAccessList(accessList);
    (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
    const signature = transactionArray.length === 12
        ? parseEIP155Signature(transactionArray)
        : undefined;
    return { ...signature, ...transaction };
}
function parseTransactionEIP2930(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;
    if (!(transactionArray.length === 8 || transactionArray.length === 11))
        throw new transaction_js_1.InvalidSerializedTransactionError({
            attributes: {
                chainId,
                nonce,
                gasPrice,
                gas,
                to,
                value,
                data,
                accessList,
                ...(transactionArray.length > 8
                    ? {
                        v,
                        r,
                        s,
                    }
                    : {}),
            },
            serializedTransaction,
            type: 'eip2930',
        });
    const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: 'eip2930',
    };
    if ((0, isHex_js_1.isHex)(to) && to !== '0x')
        transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== '0x')
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== '0x')
        transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce) && nonce !== '0x')
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== '0x')
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== '0x')
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
    if (accessList.length !== 0 && accessList !== '0x')
        transaction.accessList = parseAccessList(accessList);
    (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
    const signature = transactionArray.length === 11
        ? parseEIP155Signature(transactionArray)
        : undefined;
    return { ...signature, ...transaction };
}
function parseTransactionLegacy(serializedTransaction) {
    const transactionArray = (0, fromRlp_js_1.fromRlp)(serializedTransaction, 'hex');
    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
    if (!(transactionArray.length === 6 || transactionArray.length === 9))
        throw new transaction_js_1.InvalidSerializedTransactionError({
            attributes: {
                nonce,
                gasPrice,
                gas,
                to,
                value,
                data,
                ...(transactionArray.length > 6
                    ? {
                        v: chainIdOrV_,
                        r,
                        s,
                    }
                    : {}),
            },
            serializedTransaction,
            type: 'legacy',
        });
    const transaction = {
        type: 'legacy',
    };
    if ((0, isHex_js_1.isHex)(to) && to !== '0x')
        transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== '0x')
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== '0x')
        transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce) && nonce !== '0x')
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== '0x')
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== '0x')
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
    (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
    if (transactionArray.length === 6)
        return transaction;
    const chainIdOrV = (0, isHex_js_1.isHex)(chainIdOrV_) && chainIdOrV_ !== '0x'
        ? (0, fromHex_js_1.hexToBigInt)(chainIdOrV_)
        : 0n;
    if (s === '0x' && r === '0x') {
        if (chainIdOrV > 0)
            transaction.chainId = Number(chainIdOrV);
        return transaction;
    }
    const v = chainIdOrV;
    const chainId = Number((v - 35n) / 2n);
    if (chainId > 0)
        transaction.chainId = chainId;
    else if (v !== 27n && v !== 28n)
        throw new transaction_js_1.InvalidLegacyVError({ v });
    transaction.v = v;
    transaction.s = s;
    transaction.r = r;
    return transaction;
}
function toTransactionArray(serializedTransaction) {
    return (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, 'hex');
}
exports.toTransactionArray = toTransactionArray;
function parseAccessList(accessList_) {
    const accessList = [];
    for (let i = 0; i < accessList_.length; i++) {
        const [address, storageKeys] = accessList_[i];
        if (!(0, isAddress_js_1.isAddress)(address))
            throw new address_js_1.InvalidAddressError({ address });
        accessList.push({
            address: address,
            storageKeys: storageKeys.map((key) => ((0, isHash_js_1.isHash)(key) ? key : (0, trim_js_1.trim)(key))),
        });
    }
    return accessList;
}
exports.parseAccessList = parseAccessList;
function parseEIP155Signature(transactionArray) {
    const signature = transactionArray.slice(-3);
    const v = signature[0] === '0x' || (0, fromHex_js_1.hexToBigInt)(signature[0]) === 0n ? 27n : 28n;
    return {
        r: (0, pad_js_1.padHex)(signature[1], { size: 32 }),
        s: (0, pad_js_1.padHex)(signature[2], { size: 32 }),
        v,
        yParity: v === 27n ? 0 : 1,
    };
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/transaction/serializeAccessList.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/transaction/serializeAccessList.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeAccessList = void 0;
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
function serializeAccessList(accessList) {
    if (!accessList || accessList.length === 0)
        return [];
    const serializedAccessList = [];
    for (let i = 0; i < accessList.length; i++) {
        const { address, storageKeys } = accessList[i];
        for (let j = 0; j < storageKeys.length; j++) {
            if (storageKeys[j].length - 2 !== 64) {
                throw new transaction_js_1.InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
            }
        }
        if (!(0, isAddress_js_1.isAddress)(address)) {
            throw new address_js_1.InvalidAddressError({ address });
        }
        serializedAccessList.push([address, storageKeys]);
    }
    return serializedAccessList;
}
exports.serializeAccessList = serializeAccessList;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/transaction/serializeTransaction.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/transaction/serializeTransaction.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeTransaction = void 0;
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "../../node_modules/viem/_cjs/errors/transaction.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "../../node_modules/viem/_cjs/utils/data/concat.js");
const trim_js_1 = __webpack_require__(/*! ../data/trim.js */ "../../node_modules/viem/_cjs/utils/data/trim.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const toRlp_js_1 = __webpack_require__(/*! ../encoding/toRlp.js */ "../../node_modules/viem/_cjs/utils/encoding/toRlp.js");
const assertTransaction_js_1 = __webpack_require__(/*! ./assertTransaction.js */ "../../node_modules/viem/_cjs/utils/transaction/assertTransaction.js");
const getTransactionType_js_1 = __webpack_require__(/*! ./getTransactionType.js */ "../../node_modules/viem/_cjs/utils/transaction/getTransactionType.js");
const serializeAccessList_js_1 = __webpack_require__(/*! ./serializeAccessList.js */ "../../node_modules/viem/_cjs/utils/transaction/serializeAccessList.js");
function serializeTransaction(transaction, signature) {
    const type = (0, getTransactionType_js_1.getTransactionType)(transaction);
    if (type === 'eip1559')
        return serializeTransactionEIP1559(transaction, signature);
    if (type === 'eip2930')
        return serializeTransactionEIP2930(transaction, signature);
    return serializeTransactionLegacy(transaction, signature);
}
exports.serializeTransaction = serializeTransaction;
function serializeTransactionEIP1559(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, } = transaction;
    (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
    const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : '0x',
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : '0x',
        gas ? (0, toHex_js_1.toHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, toHex_js_1.toHex)(value) : '0x',
        data ?? '0x',
        serializedAccessList,
    ];
    if (signature) {
        const yParity = (() => {
            if (signature.v === 0n)
                return '0x';
            if (signature.v === 1n)
                return (0, toHex_js_1.toHex)(1);
            return signature.v === 27n ? '0x' : (0, toHex_js_1.toHex)(1);
        })();
        serializedTransaction.push(yParity, (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
    }
    return (0, concat_js_1.concatHex)([
        '0x02',
        (0, toRlp_js_1.toRlp)(serializedTransaction),
    ]);
}
function serializeTransactionEIP2930(transaction, signature) {
    const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
    (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
    const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : '0x',
        gas ? (0, toHex_js_1.toHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, toHex_js_1.toHex)(value) : '0x',
        data ?? '0x',
        serializedAccessList,
    ];
    if (signature) {
        const yParity = (() => {
            if (signature.v === 0n)
                return '0x';
            if (signature.v === 1n)
                return (0, toHex_js_1.toHex)(1);
            return signature.v === 27n ? '0x' : (0, toHex_js_1.toHex)(1);
        })();
        serializedTransaction.push(yParity, (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
    }
    return (0, concat_js_1.concatHex)([
        '0x01',
        (0, toRlp_js_1.toRlp)(serializedTransaction),
    ]);
}
function serializeTransactionLegacy(transaction, signature) {
    const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
    (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
    let serializedTransaction = [
        nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : '0x',
        gas ? (0, toHex_js_1.toHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, toHex_js_1.toHex)(value) : '0x',
        data ?? '0x',
    ];
    if (signature) {
        const v = (() => {
            if (chainId > 0)
                return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
            if (signature.v >= 35n) {
                const inferredChainId = (signature.v - 35n) / 2n;
                if (inferredChainId > 0)
                    return signature.v;
                return 27n + (signature.v === 35n ? 0n : 1n);
            }
            const v = 27n + (signature.v === 27n ? 0n : 1n);
            if (signature.v !== v)
                throw new transaction_js_1.InvalidLegacyVError({ v: signature.v });
            return v;
        })();
        serializedTransaction = [
            ...serializedTransaction,
            (0, toHex_js_1.toHex)(v),
            signature.r,
            signature.s,
        ];
    }
    else if (chainId > 0) {
        serializedTransaction = [
            ...serializedTransaction,
            (0, toHex_js_1.toHex)(chainId),
            '0x',
            '0x',
        ];
    }
    return (0, toRlp_js_1.toRlp)(serializedTransaction);
}


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/typedData.js":
/*!*******************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/typedData.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.domainSeparator = exports.getTypesForEIP712Domain = exports.validateTypedData = void 0;
const abi_js_1 = __webpack_require__(/*! ../errors/abi.js */ "../../node_modules/viem/_cjs/errors/abi.js");
const address_js_1 = __webpack_require__(/*! ../errors/address.js */ "../../node_modules/viem/_cjs/errors/address.js");
const isAddress_js_1 = __webpack_require__(/*! ./address/isAddress.js */ "../../node_modules/viem/_cjs/utils/address/isAddress.js");
const size_js_1 = __webpack_require__(/*! ./data/size.js */ "../../node_modules/viem/_cjs/utils/data/size.js");
const toHex_js_1 = __webpack_require__(/*! ./encoding/toHex.js */ "../../node_modules/viem/_cjs/utils/encoding/toHex.js");
const regex_js_1 = __webpack_require__(/*! ./regex.js */ "../../node_modules/viem/_cjs/utils/regex.js");
const hashTypedData_js_1 = __webpack_require__(/*! ./signature/hashTypedData.js */ "../../node_modules/viem/_cjs/utils/signature/hashTypedData.js");
function validateTypedData({ domain, message, primaryType, types: types_, }) {
    const types = types_;
    const validateData = (struct, value_) => {
        for (const param of struct) {
            const { name, type: type_ } = param;
            const type = type_;
            const value = value_[name];
            const integerMatch = type.match(regex_js_1.integerRegex);
            if (integerMatch &&
                (typeof value === 'number' || typeof value === 'bigint')) {
                const [_type, base, size_] = integerMatch;
                (0, toHex_js_1.numberToHex)(value, {
                    signed: base === 'int',
                    size: parseInt(size_) / 8,
                });
            }
            if (type === 'address' && typeof value === 'string' && !(0, isAddress_js_1.isAddress)(value))
                throw new address_js_1.InvalidAddressError({ address: value });
            const bytesMatch = type.match(regex_js_1.bytesRegex);
            if (bytesMatch) {
                const [_type, size_] = bytesMatch;
                if (size_ && (0, size_js_1.size)(value) !== parseInt(size_))
                    throw new abi_js_1.BytesSizeMismatchError({
                        expectedSize: parseInt(size_),
                        givenSize: (0, size_js_1.size)(value),
                    });
            }
            const struct = types[type];
            if (struct)
                validateData(struct, value);
        }
    };
    if (types.EIP712Domain && domain)
        validateData(types.EIP712Domain, domain);
    if (primaryType !== 'EIP712Domain') {
        const type = types[primaryType];
        validateData(type, message);
    }
}
exports.validateTypedData = validateTypedData;
function getTypesForEIP712Domain({ domain, }) {
    return [
        typeof domain?.name === 'string' && { name: 'name', type: 'string' },
        domain?.version && { name: 'version', type: 'string' },
        typeof domain?.chainId === 'number' && {
            name: 'chainId',
            type: 'uint256',
        },
        domain?.verifyingContract && {
            name: 'verifyingContract',
            type: 'address',
        },
        domain?.salt && { name: 'salt', type: 'bytes32' },
    ].filter(Boolean);
}
exports.getTypesForEIP712Domain = getTypesForEIP712Domain;
function domainSeparator({ domain }) {
    return (0, hashTypedData_js_1.hashDomain)({
        domain,
        types: {
            EIP712Domain: getTypesForEIP712Domain({ domain }),
        },
    });
}
exports.domainSeparator = domainSeparator;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/uid.js":
/*!*************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/uid.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uid = void 0;
const size = 256;
let index = size;
let buffer;
function uid(length = 11) {
    if (!buffer || index + length > size * 2) {
        buffer = '';
        index = 0;
        for (let i = 0; i < size; i++) {
            buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1);
        }
    }
    return buffer.substring(index, index++ + length);
}
exports.uid = uid;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/unit/formatEther.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/unit/formatEther.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatEther = void 0;
const unit_js_1 = __webpack_require__(/*! ../../constants/unit.js */ "../../node_modules/viem/_cjs/constants/unit.js");
const formatUnits_js_1 = __webpack_require__(/*! ./formatUnits.js */ "../../node_modules/viem/_cjs/utils/unit/formatUnits.js");
function formatEther(wei, unit = 'wei') {
    return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.etherUnits[unit]);
}
exports.formatEther = formatEther;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/unit/formatGwei.js":
/*!*************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/unit/formatGwei.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatGwei = void 0;
const unit_js_1 = __webpack_require__(/*! ../../constants/unit.js */ "../../node_modules/viem/_cjs/constants/unit.js");
const formatUnits_js_1 = __webpack_require__(/*! ./formatUnits.js */ "../../node_modules/viem/_cjs/utils/unit/formatUnits.js");
function formatGwei(wei, unit = 'wei') {
    return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.gweiUnits[unit]);
}
exports.formatGwei = formatGwei;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/unit/formatUnits.js":
/*!**************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/unit/formatUnits.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatUnits = void 0;
function formatUnits(value, decimals) {
    let display = value.toString();
    const negative = display.startsWith('-');
    if (negative)
        display = display.slice(1);
    display = display.padStart(decimals, '0');
    let [integer, fraction] = [
        display.slice(0, display.length - decimals),
        display.slice(display.length - decimals),
    ];
    fraction = fraction.replace(/(0+)$/, '');
    return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;
}
exports.formatUnits = formatUnits;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/unit/parseEther.js":
/*!*************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/unit/parseEther.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseEther = void 0;
const unit_js_1 = __webpack_require__(/*! ../../constants/unit.js */ "../../node_modules/viem/_cjs/constants/unit.js");
const parseUnits_js_1 = __webpack_require__(/*! ./parseUnits.js */ "../../node_modules/viem/_cjs/utils/unit/parseUnits.js");
function parseEther(ether, unit = 'wei') {
    return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.etherUnits[unit]);
}
exports.parseEther = parseEther;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/unit/parseGwei.js":
/*!************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/unit/parseGwei.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseGwei = void 0;
const unit_js_1 = __webpack_require__(/*! ../../constants/unit.js */ "../../node_modules/viem/_cjs/constants/unit.js");
const parseUnits_js_1 = __webpack_require__(/*! ./parseUnits.js */ "../../node_modules/viem/_cjs/utils/unit/parseUnits.js");
function parseGwei(ether, unit = 'wei') {
    return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.gweiUnits[unit]);
}
exports.parseGwei = parseGwei;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/unit/parseUnits.js":
/*!*************************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/unit/parseUnits.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseUnits = void 0;
function parseUnits(value, decimals) {
    let [integer, fraction = '0'] = value.split('.');
    const negative = integer.startsWith('-');
    if (negative)
        integer = integer.slice(1);
    fraction = fraction.replace(/(0+)$/, '');
    if (decimals === 0) {
        if (Math.round(Number(`.${fraction}`)) === 1)
            integer = `${BigInt(integer) + 1n}`;
        fraction = '';
    }
    else if (fraction.length > decimals) {
        const [left, unit, right] = [
            fraction.slice(0, decimals - 1),
            fraction.slice(decimals - 1, decimals),
            fraction.slice(decimals),
        ];
        const rounded = Math.round(Number(`${unit}.${right}`));
        if (rounded > 9)
            fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0');
        else
            fraction = `${left}${rounded}`;
        if (fraction.length > decimals) {
            fraction = fraction.slice(1);
            integer = `${BigInt(integer) + 1n}`;
        }
        fraction = fraction.slice(0, decimals);
    }
    else {
        fraction = fraction.padEnd(decimals, '0');
    }
    return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);
}
exports.parseUnits = parseUnits;


/***/ }),

/***/ "../../node_modules/viem/_cjs/utils/wait.js":
/*!**************************************************!*\
  !*** ../../node_modules/viem/_cjs/utils/wait.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wait = void 0;
async function wait(time) {
    return new Promise((res) => setTimeout(res, time));
}
exports.wait = wait;


/***/ }),

/***/ "./node_modules/superstruct/dist/index.mjs":
/*!*************************************************!*\
  !*** ./node_modules/superstruct/dist/index.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Struct: () => (/* binding */ Struct),
/* harmony export */   StructError: () => (/* binding */ StructError),
/* harmony export */   any: () => (/* binding */ any),
/* harmony export */   array: () => (/* binding */ array),
/* harmony export */   assert: () => (/* binding */ assert),
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   bigint: () => (/* binding */ bigint),
/* harmony export */   boolean: () => (/* binding */ boolean),
/* harmony export */   coerce: () => (/* binding */ coerce),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   date: () => (/* binding */ date),
/* harmony export */   defaulted: () => (/* binding */ defaulted),
/* harmony export */   define: () => (/* binding */ define),
/* harmony export */   deprecated: () => (/* binding */ deprecated),
/* harmony export */   dynamic: () => (/* binding */ dynamic),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   enums: () => (/* binding */ enums),
/* harmony export */   func: () => (/* binding */ func),
/* harmony export */   instance: () => (/* binding */ instance),
/* harmony export */   integer: () => (/* binding */ integer),
/* harmony export */   intersection: () => (/* binding */ intersection),
/* harmony export */   is: () => (/* binding */ is),
/* harmony export */   lazy: () => (/* binding */ lazy),
/* harmony export */   literal: () => (/* binding */ literal),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mask: () => (/* binding */ mask),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   never: () => (/* binding */ never),
/* harmony export */   nonempty: () => (/* binding */ nonempty),
/* harmony export */   nullable: () => (/* binding */ nullable),
/* harmony export */   number: () => (/* binding */ number),
/* harmony export */   object: () => (/* binding */ object),
/* harmony export */   omit: () => (/* binding */ omit),
/* harmony export */   optional: () => (/* binding */ optional),
/* harmony export */   partial: () => (/* binding */ partial),
/* harmony export */   pattern: () => (/* binding */ pattern),
/* harmony export */   pick: () => (/* binding */ pick),
/* harmony export */   record: () => (/* binding */ record),
/* harmony export */   refine: () => (/* binding */ refine),
/* harmony export */   regexp: () => (/* binding */ regexp),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   size: () => (/* binding */ size),
/* harmony export */   string: () => (/* binding */ string),
/* harmony export */   struct: () => (/* binding */ struct),
/* harmony export */   trimmed: () => (/* binding */ trimmed),
/* harmony export */   tuple: () => (/* binding */ tuple),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   union: () => (/* binding */ union),
/* harmony export */   unknown: () => (/* binding */ unknown),
/* harmony export */   validate: () => (/* binding */ validate)
/* harmony export */ });
/**
 * A `StructFailure` represents a single specific failure in validation.
 */
/**
 * `StructError` objects are thrown (or returned) when validation fails.
 *
 * Validation logic is design to exit early for maximum performance. The error
 * represents the first error encountered during validation. For more detail,
 * the `error.failures` property is a generator function that can be run to
 * continue validation and receive all the failures in the data.
 */
class StructError extends TypeError {
    constructor(failure, failures) {
        let cached;
        const { message, explanation, ...rest } = failure;
        const { path } = failure;
        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;
        super(explanation ?? msg);
        if (explanation != null)
            this.cause = msg;
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = () => {
            return (cached ?? (cached = [failure, ...failures()]));
        };
    }
}

/**
 * Check if a value is an iterator.
 */
function isIterable(x) {
    return isObject(x) && typeof x[Symbol.iterator] === 'function';
}
/**
 * Check if a value is a plain object.
 */
function isObject(x) {
    return typeof x === 'object' && x != null;
}
/**
 * Check if a value is a plain object.
 */
function isPlainObject(x) {
    if (Object.prototype.toString.call(x) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(x);
    return prototype === null || prototype === Object.prototype;
}
/**
 * Return a value as a printable string.
 */
function print(value) {
    if (typeof value === 'symbol') {
        return value.toString();
    }
    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;
}
/**
 * Shifts (removes and returns) the first value from the `input` iterator.
 * Like `Array.prototype.shift()` but for an `Iterator`.
 */
function shiftIterator(input) {
    const { done, value } = input.next();
    return done ? undefined : value;
}
/**
 * Convert a single validation result to a failure.
 */
function toFailure(result, context, struct, value) {
    if (result === true) {
        return;
    }
    else if (result === false) {
        result = {};
    }
    else if (typeof result === 'string') {
        result = { message: result };
    }
    const { path, branch } = context;
    const { type } = struct;
    const { refinement, message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ''}, but received: \`${print(value)}\``, } = result;
    return {
        value,
        type,
        refinement,
        key: path[path.length - 1],
        path,
        branch,
        ...result,
        message,
    };
}
/**
 * Convert a validation result to an iterable of failures.
 */
function* toFailures(result, context, struct, value) {
    if (!isIterable(result)) {
        result = [result];
    }
    for (const r of result) {
        const failure = toFailure(r, context, struct, value);
        if (failure) {
            yield failure;
        }
    }
}
/**
 * Check a value against a struct, traversing deeply into nested values, and
 * returning an iterator of failures or success.
 */
function* run(value, struct, options = {}) {
    const { path = [], branch = [value], coerce = false, mask = false } = options;
    const ctx = { path, branch };
    if (coerce) {
        value = struct.coercer(value, ctx);
        if (mask &&
            struct.type !== 'type' &&
            isObject(struct.schema) &&
            isObject(value) &&
            !Array.isArray(value)) {
            for (const key in value) {
                if (struct.schema[key] === undefined) {
                    delete value[key];
                }
            }
        }
    }
    let status = 'valid';
    for (const failure of struct.validator(value, ctx)) {
        failure.explanation = options.message;
        status = 'not_valid';
        yield [failure, undefined];
    }
    for (let [k, v, s] of struct.entries(value, ctx)) {
        const ts = run(v, s, {
            path: k === undefined ? path : [...path, k],
            branch: k === undefined ? branch : [...branch, v],
            coerce,
            mask,
            message: options.message,
        });
        for (const t of ts) {
            if (t[0]) {
                status = t[0].refinement != null ? 'not_refined' : 'not_valid';
                yield [t[0], undefined];
            }
            else if (coerce) {
                v = t[1];
                if (k === undefined) {
                    value = v;
                }
                else if (value instanceof Map) {
                    value.set(k, v);
                }
                else if (value instanceof Set) {
                    value.add(v);
                }
                else if (isObject(value)) {
                    if (v !== undefined || k in value)
                        value[k] = v;
                }
            }
        }
    }
    if (status !== 'not_valid') {
        for (const failure of struct.refiner(value, ctx)) {
            failure.explanation = options.message;
            status = 'not_refined';
            yield [failure, undefined];
        }
    }
    if (status === 'valid') {
        yield [undefined, value];
    }
}

/**
 * `Struct` objects encapsulate the validation logic for a specific type of
 * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
 * validate unknown input data against the struct.
 */
class Struct {
    constructor(props) {
        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;
        this.type = type;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator) {
            this.validator = (value, context) => {
                const result = validator(value, context);
                return toFailures(result, context, this, value);
            };
        }
        else {
            this.validator = () => [];
        }
        if (refiner) {
            this.refiner = (value, context) => {
                const result = refiner(value, context);
                return toFailures(result, context, this, value);
            };
        }
        else {
            this.refiner = () => [];
        }
    }
    /**
     * Assert that a value passes the struct's validation, throwing if it doesn't.
     */
    assert(value, message) {
        return assert(value, this, message);
    }
    /**
     * Create a value with the struct's coercion logic, then validate it.
     */
    create(value, message) {
        return create(value, this, message);
    }
    /**
     * Check if a value passes the struct's validation.
     */
    is(value) {
        return is(value, this);
    }
    /**
     * Mask a value, coercing and validating it, but returning only the subset of
     * properties defined by the struct's schema.
     */
    mask(value, message) {
        return mask(value, this, message);
    }
    /**
     * Validate a value with the struct's validation logic, returning a tuple
     * representing the result.
     *
     * You may optionally pass `true` for the `withCoercion` argument to coerce
     * the value before attempting to validate it. If you do, the result will
     * contain the coerced result when successful.
     */
    validate(value, options = {}) {
        return validate(value, this, options);
    }
}
/**
 * Assert that a value passes a struct, throwing if it doesn't.
 */
function assert(value, struct, message) {
    const result = validate(value, struct, { message });
    if (result[0]) {
        throw result[0];
    }
}
/**
 * Create a value with the coercion logic of struct and validate it.
 */
function create(value, struct, message) {
    const result = validate(value, struct, { coerce: true, message });
    if (result[0]) {
        throw result[0];
    }
    else {
        return result[1];
    }
}
/**
 * Mask a value, returning only the subset of properties defined by a struct.
 */
function mask(value, struct, message) {
    const result = validate(value, struct, { coerce: true, mask: true, message });
    if (result[0]) {
        throw result[0];
    }
    else {
        return result[1];
    }
}
/**
 * Check if a value passes a struct.
 */
function is(value, struct) {
    const result = validate(value, struct);
    return !result[0];
}
/**
 * Validate a value against a struct, returning an error if invalid, or the
 * value (with potential coercion) if valid.
 */
function validate(value, struct, options = {}) {
    const tuples = run(value, struct, options);
    const tuple = shiftIterator(tuples);
    if (tuple[0]) {
        const error = new StructError(tuple[0], function* () {
            for (const t of tuples) {
                if (t[0]) {
                    yield t[0];
                }
            }
        });
        return [error, undefined];
    }
    else {
        const v = tuple[1];
        return [undefined, v];
    }
}

function assign(...Structs) {
    const isType = Structs[0].type === 'type';
    const schemas = Structs.map((s) => s.schema);
    const schema = Object.assign({}, ...schemas);
    return isType ? type(schema) : object(schema);
}
/**
 * Define a new struct type with a custom validation function.
 */
function define(name, validator) {
    return new Struct({ type: name, schema: null, validator });
}
/**
 * Create a new struct based on an existing struct, but the value is allowed to
 * be `undefined`. `log` will be called if the value is not `undefined`.
 */
function deprecated(struct, log) {
    return new Struct({
        ...struct,
        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
        validator(value, ctx) {
            if (value === undefined) {
                return true;
            }
            else {
                log(value, ctx);
                return struct.validator(value, ctx);
            }
        },
    });
}
/**
 * Create a struct with dynamic validation logic.
 *
 * The callback will receive the value currently being validated, and must
 * return a struct object to validate it with. This can be useful to model
 * validation logic that changes based on its input.
 */
function dynamic(fn) {
    return new Struct({
        type: 'dynamic',
        schema: null,
        *entries(value, ctx) {
            const struct = fn(value, ctx);
            yield* struct.entries(value, ctx);
        },
        validator(value, ctx) {
            const struct = fn(value, ctx);
            return struct.validator(value, ctx);
        },
        coercer(value, ctx) {
            const struct = fn(value, ctx);
            return struct.coercer(value, ctx);
        },
        refiner(value, ctx) {
            const struct = fn(value, ctx);
            return struct.refiner(value, ctx);
        },
    });
}
/**
 * Create a struct with lazily evaluated validation logic.
 *
 * The first time validation is run with the struct, the callback will be called
 * and must return a struct object to use. This is useful for cases where you
 * want to have self-referential structs for nested data structures to avoid a
 * circular definition problem.
 */
function lazy(fn) {
    let struct;
    return new Struct({
        type: 'lazy',
        schema: null,
        *entries(value, ctx) {
            struct ?? (struct = fn());
            yield* struct.entries(value, ctx);
        },
        validator(value, ctx) {
            struct ?? (struct = fn());
            return struct.validator(value, ctx);
        },
        coercer(value, ctx) {
            struct ?? (struct = fn());
            return struct.coercer(value, ctx);
        },
        refiner(value, ctx) {
            struct ?? (struct = fn());
            return struct.refiner(value, ctx);
        },
    });
}
/**
 * Create a new struct based on an existing object struct, but excluding
 * specific properties.
 *
 * Like TypeScript's `Omit` utility.
 */
function omit(struct, keys) {
    const { schema } = struct;
    const subschema = { ...schema };
    for (const key of keys) {
        delete subschema[key];
    }
    switch (struct.type) {
        case 'type':
            return type(subschema);
        default:
            return object(subschema);
    }
}
/**
 * Create a new struct based on an existing object struct, but with all of its
 * properties allowed to be `undefined`.
 *
 * Like TypeScript's `Partial` utility.
 */
function partial(struct) {
    const schema = struct instanceof Struct ? { ...struct.schema } : { ...struct };
    for (const key in schema) {
        schema[key] = optional(schema[key]);
    }
    return object(schema);
}
/**
 * Create a new struct based on an existing object struct, but only including
 * specific properties.
 *
 * Like TypeScript's `Pick` utility.
 */
function pick(struct, keys) {
    const { schema } = struct;
    const subschema = {};
    for (const key of keys) {
        subschema[key] = schema[key];
    }
    return object(subschema);
}
/**
 * Define a new struct type with a custom validation function.
 *
 * @deprecated This function has been renamed to `define`.
 */
function struct(name, validator) {
    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');
    return define(name, validator);
}

/**
 * Ensure that any value passes validation.
 */
function any() {
    return define('any', () => true);
}
function array(Element) {
    return new Struct({
        type: 'array',
        schema: Element,
        *entries(value) {
            if (Element && Array.isArray(value)) {
                for (const [i, v] of value.entries()) {
                    yield [i, v, Element];
                }
            }
        },
        coercer(value) {
            return Array.isArray(value) ? value.slice() : value;
        },
        validator(value) {
            return (Array.isArray(value) ||
                `Expected an array value, but received: ${print(value)}`);
        },
    });
}
/**
 * Ensure that a value is a bigint.
 */
function bigint() {
    return define('bigint', (value) => {
        return typeof value === 'bigint';
    });
}
/**
 * Ensure that a value is a boolean.
 */
function boolean() {
    return define('boolean', (value) => {
        return typeof value === 'boolean';
    });
}
/**
 * Ensure that a value is a valid `Date`.
 *
 * Note: this also ensures that the value is *not* an invalid `Date` object,
 * which can occur when parsing a date fails but still returns a `Date`.
 */
function date() {
    return define('date', (value) => {
        return ((value instanceof Date && !isNaN(value.getTime())) ||
            `Expected a valid \`Date\` object, but received: ${print(value)}`);
    });
}
function enums(values) {
    const schema = {};
    const description = values.map((v) => print(v)).join();
    for (const key of values) {
        schema[key] = key;
    }
    return new Struct({
        type: 'enums',
        schema,
        validator(value) {
            return (values.includes(value) ||
                `Expected one of \`${description}\`, but received: ${print(value)}`);
        },
    });
}
/**
 * Ensure that a value is a function.
 */
function func() {
    return define('func', (value) => {
        return (typeof value === 'function' ||
            `Expected a function, but received: ${print(value)}`);
    });
}
/**
 * Ensure that a value is an instance of a specific class.
 */
function instance(Class) {
    return define('instance', (value) => {
        return (value instanceof Class ||
            `Expected a \`${Class.name}\` instance, but received: ${print(value)}`);
    });
}
/**
 * Ensure that a value is an integer.
 */
function integer() {
    return define('integer', (value) => {
        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||
            `Expected an integer, but received: ${print(value)}`);
    });
}
/**
 * Ensure that a value matches all of a set of types.
 */
function intersection(Structs) {
    return new Struct({
        type: 'intersection',
        schema: null,
        *entries(value, ctx) {
            for (const S of Structs) {
                yield* S.entries(value, ctx);
            }
        },
        *validator(value, ctx) {
            for (const S of Structs) {
                yield* S.validator(value, ctx);
            }
        },
        *refiner(value, ctx) {
            for (const S of Structs) {
                yield* S.refiner(value, ctx);
            }
        },
    });
}
function literal(constant) {
    const description = print(constant);
    const t = typeof constant;
    return new Struct({
        type: 'literal',
        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,
        validator(value) {
            return (value === constant ||
                `Expected the literal \`${description}\`, but received: ${print(value)}`);
        },
    });
}
function map(Key, Value) {
    return new Struct({
        type: 'map',
        schema: null,
        *entries(value) {
            if (Key && Value && value instanceof Map) {
                for (const [k, v] of value.entries()) {
                    yield [k, k, Key];
                    yield [k, v, Value];
                }
            }
        },
        coercer(value) {
            return value instanceof Map ? new Map(value) : value;
        },
        validator(value) {
            return (value instanceof Map ||
                `Expected a \`Map\` object, but received: ${print(value)}`);
        },
    });
}
/**
 * Ensure that no value ever passes validation.
 */
function never() {
    return define('never', () => false);
}
/**
 * Augment an existing struct to allow `null` values.
 */
function nullable(struct) {
    return new Struct({
        ...struct,
        validator: (value, ctx) => value === null || struct.validator(value, ctx),
        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),
    });
}
/**
 * Ensure that a value is a number.
 */
function number() {
    return define('number', (value) => {
        return ((typeof value === 'number' && !isNaN(value)) ||
            `Expected a number, but received: ${print(value)}`);
    });
}
function object(schema) {
    const knowns = schema ? Object.keys(schema) : [];
    const Never = never();
    return new Struct({
        type: 'object',
        schema: schema ? schema : null,
        *entries(value) {
            if (schema && isObject(value)) {
                const unknowns = new Set(Object.keys(value));
                for (const key of knowns) {
                    unknowns.delete(key);
                    yield [key, value[key], schema[key]];
                }
                for (const key of unknowns) {
                    yield [key, value[key], Never];
                }
            }
        },
        validator(value) {
            return (isObject(value) || `Expected an object, but received: ${print(value)}`);
        },
        coercer(value) {
            return isObject(value) ? { ...value } : value;
        },
    });
}
/**
 * Augment a struct to allow `undefined` values.
 */
function optional(struct) {
    return new Struct({
        ...struct,
        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
    });
}
/**
 * Ensure that a value is an object with keys and values of specific types, but
 * without ensuring any specific shape of properties.
 *
 * Like TypeScript's `Record` utility.
 */
function record(Key, Value) {
    return new Struct({
        type: 'record',
        schema: null,
        *entries(value) {
            if (isObject(value)) {
                for (const k in value) {
                    const v = value[k];
                    yield [k, k, Key];
                    yield [k, v, Value];
                }
            }
        },
        validator(value) {
            return (isObject(value) || `Expected an object, but received: ${print(value)}`);
        },
    });
}
/**
 * Ensure that a value is a `RegExp`.
 *
 * Note: this does not test the value against the regular expression! For that
 * you need to use the `pattern()` refinement.
 */
function regexp() {
    return define('regexp', (value) => {
        return value instanceof RegExp;
    });
}
function set(Element) {
    return new Struct({
        type: 'set',
        schema: null,
        *entries(value) {
            if (Element && value instanceof Set) {
                for (const v of value) {
                    yield [v, v, Element];
                }
            }
        },
        coercer(value) {
            return value instanceof Set ? new Set(value) : value;
        },
        validator(value) {
            return (value instanceof Set ||
                `Expected a \`Set\` object, but received: ${print(value)}`);
        },
    });
}
/**
 * Ensure that a value is a string.
 */
function string() {
    return define('string', (value) => {
        return (typeof value === 'string' ||
            `Expected a string, but received: ${print(value)}`);
    });
}
/**
 * Ensure that a value is a tuple of a specific length, and that each of its
 * elements is of a specific type.
 */
function tuple(Structs) {
    const Never = never();
    return new Struct({
        type: 'tuple',
        schema: null,
        *entries(value) {
            if (Array.isArray(value)) {
                const length = Math.max(Structs.length, value.length);
                for (let i = 0; i < length; i++) {
                    yield [i, value[i], Structs[i] || Never];
                }
            }
        },
        validator(value) {
            return (Array.isArray(value) ||
                `Expected an array, but received: ${print(value)}`);
        },
    });
}
/**
 * Ensure that a value has a set of known properties of specific types.
 *
 * Note: Unrecognized properties are allowed and untouched. This is similar to
 * how TypeScript's structural typing works.
 */
function type(schema) {
    const keys = Object.keys(schema);
    return new Struct({
        type: 'type',
        schema,
        *entries(value) {
            if (isObject(value)) {
                for (const k of keys) {
                    yield [k, value[k], schema[k]];
                }
            }
        },
        validator(value) {
            return (isObject(value) || `Expected an object, but received: ${print(value)}`);
        },
        coercer(value) {
            return isObject(value) ? { ...value } : value;
        },
    });
}
/**
 * Ensure that a value matches one of a set of types.
 */
function union(Structs) {
    const description = Structs.map((s) => s.type).join(' | ');
    return new Struct({
        type: 'union',
        schema: null,
        coercer(value) {
            for (const S of Structs) {
                const [error, coerced] = S.validate(value, { coerce: true });
                if (!error) {
                    return coerced;
                }
            }
            return value;
        },
        validator(value, ctx) {
            const failures = [];
            for (const S of Structs) {
                const [...tuples] = run(value, S, ctx);
                const [first] = tuples;
                if (!first[0]) {
                    return [];
                }
                else {
                    for (const [failure] of tuples) {
                        if (failure) {
                            failures.push(failure);
                        }
                    }
                }
            }
            return [
                `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
                ...failures,
            ];
        },
    });
}
/**
 * Ensure that any value passes validation, without widening its type to `any`.
 */
function unknown() {
    return define('unknown', () => true);
}

/**
 * Augment a `Struct` to add an additional coercion step to its input.
 *
 * This allows you to transform input data before validating it, to increase the
 * likelihood that it passes validation—for example for default values, parsing
 * different formats, etc.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 */
function coerce(struct, condition, coercer) {
    return new Struct({
        ...struct,
        coercer: (value, ctx) => {
            return is(value, condition)
                ? struct.coercer(coercer(value, ctx), ctx)
                : struct.coercer(value, ctx);
        },
    });
}
/**
 * Augment a struct to replace `undefined` values with a default.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 */
function defaulted(struct, fallback, options = {}) {
    return coerce(struct, unknown(), (x) => {
        const f = typeof fallback === 'function' ? fallback() : fallback;
        if (x === undefined) {
            return f;
        }
        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
            const ret = { ...x };
            let changed = false;
            for (const key in f) {
                if (ret[key] === undefined) {
                    ret[key] = f[key];
                    changed = true;
                }
            }
            if (changed) {
                return ret;
            }
        }
        return x;
    });
}
/**
 * Augment a struct to trim string inputs.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 */
function trimmed(struct) {
    return coerce(struct, string(), (x) => x.trim());
}

/**
 * Ensure that a string, array, map, or set is empty.
 */
function empty(struct) {
    return refine(struct, 'empty', (value) => {
        const size = getSize(value);
        return (size === 0 ||
            `Expected an empty ${struct.type} but received one with a size of \`${size}\``);
    });
}
function getSize(value) {
    if (value instanceof Map || value instanceof Set) {
        return value.size;
    }
    else {
        return value.length;
    }
}
/**
 * Ensure that a number or date is below a threshold.
 */
function max(struct, threshold, options = {}) {
    const { exclusive } = options;
    return refine(struct, 'max', (value) => {
        return exclusive
            ? value < threshold
            : value <= threshold ||
                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
    });
}
/**
 * Ensure that a number or date is above a threshold.
 */
function min(struct, threshold, options = {}) {
    const { exclusive } = options;
    return refine(struct, 'min', (value) => {
        return exclusive
            ? value > threshold
            : value >= threshold ||
                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
    });
}
/**
 * Ensure that a string, array, map or set is not empty.
 */
function nonempty(struct) {
    return refine(struct, 'nonempty', (value) => {
        const size = getSize(value);
        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);
    });
}
/**
 * Ensure that a string matches a regular expression.
 */
function pattern(struct, regexp) {
    return refine(struct, 'pattern', (value) => {
        return (regexp.test(value) ||
            `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`);
    });
}
/**
 * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
 */
function size(struct, min, max = min) {
    const expected = `Expected a ${struct.type}`;
    const of = min === max ? `of \`${min}\`` : `between \`${min}\` and \`${max}\``;
    return refine(struct, 'size', (value) => {
        if (typeof value === 'number' || value instanceof Date) {
            return ((min <= value && value <= max) ||
                `${expected} ${of} but received \`${value}\``);
        }
        else if (value instanceof Map || value instanceof Set) {
            const { size } = value;
            return ((min <= size && size <= max) ||
                `${expected} with a size ${of} but received one with a size of \`${size}\``);
        }
        else {
            const { length } = value;
            return ((min <= length && length <= max) ||
                `${expected} with a length ${of} but received one with a length of \`${length}\``);
        }
    });
}
/**
 * Augment a `Struct` to add an additional refinement to the validation.
 *
 * The refiner function is guaranteed to receive a value of the struct's type,
 * because the struct's existing validation will already have passed. This
 * allows you to layer additional validation on top of existing structs.
 */
function refine(struct, name, refiner) {
    return new Struct({
        ...struct,
        *refiner(value, ctx) {
            yield* struct.refiner(value, ctx);
            const result = refiner(value, ctx);
            const failures = toFailures(result, ctx, struct, value);
            for (const failure of failures) {
                yield { ...failure, refinement: name };
            }
        },
    });
}





/***/ }),

/***/ "../../node_modules/isows/_esm/native.js":
/*!***********************************************!*\
  !*** ../../node_modules/isows/_esm/native.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebSocket: () => (/* binding */ WebSocket)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "../../node_modules/isows/_esm/utils.js");

const WebSocket = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getNativeWebSocket)();


/***/ }),

/***/ "../../node_modules/isows/_esm/utils.js":
/*!**********************************************!*\
  !*** ../../node_modules/isows/_esm/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNativeWebSocket: () => (/* binding */ getNativeWebSocket)
/* harmony export */ });
function getNativeWebSocket() {
    if (typeof WebSocket !== "undefined")
        return WebSocket;
    if (typeof global.WebSocket !== "undefined")
        return global.WebSocket;
    if (typeof window.WebSocket !== "undefined")
        return window.WebSocket;
    if (typeof self.WebSocket !== "undefined")
        return self.WebSocket;
    throw new Error("`WebSocket` is not supported in this environment");
}


/***/ }),

/***/ "./node_modules/@metamask/providers/dist/extension-provider/external-extension-config.json":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@metamask/providers/dist/extension-provider/external-extension-config.json ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"chromeIds":{"stable":"nkbihfbeogaeaoehlefnkodbefgpgknn","beta":"pbbkamfgmaedccnfkmjcofcecjhfgldn","flask":"ljfoeinjpaedjfecbmggjgodbgkmjkjk"},"firefoxIds":{"stable":"webextension@metamask.io","beta":"webextension-beta@metamask.io","flask":"webextension-flask@metamask.io"}}');

/***/ }),

/***/ "./src/coq-abi.json":
/*!**************************!*\
  !*** ./src/coq-abi.json ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"allowance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientAllowance","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientBalance","type":"error"},{"inputs":[{"internalType":"address","name":"approver","type":"address"}],"name":"ERC20InvalidApprover","type":"error"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"}],"name":"ERC20InvalidReceiver","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"ERC20InvalidSender","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"}],"name":"ERC20InvalidSpender","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"liquidityPool","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lubricating","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceTokenOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_liquidityPool","type":"address"}],"name":"setLiquidityPool","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_state","type":"bool"}],"name":"setLubricating","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*******************************!*\
  !*** ./src/content-script.js ***!
  \*******************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const { createWalletClient, createPublicClient, parseEther, custom, http } = __webpack_require__(/*! viem */ "../../node_modules/viem/_cjs/index.js");
const { avalanche } = __webpack_require__(/*! viem/chains */ "../../node_modules/viem/_cjs/chains/index.js");
const { createExternalExtensionProvider } = __webpack_require__(/*! @metamask/providers */ "./node_modules/@metamask/providers/dist/index.js");
const { WindowPostMessageStream } = __webpack_require__(/*! @metamask/post-message-stream */ "./node_modules/@metamask/post-message-stream/dist/browser.js");
const coqAbi = __webpack_require__(/*! ./coq-abi.json */ "./src/coq-abi.json");
console.log("createMetaMaskProvider:", createExternalExtensionProvider);
const COQ_ADDRESS = "0x420FcA0121DC28039145009570975747295f2329";
const provider = createExternalExtensionProvider();
console.log("provider:", provider);
const CONTENT_SCRIPT = "fisand-contentscript";
const INPAGE = "fisand-inpage";

const setupPageStream = () => {
  const pageStream = new WindowPostMessageStream({
    name: CONTENT_SCRIPT,
    target: INPAGE,
  });

  pageStream.on("data", (data) => {
    console.log(data + ", world");
    setTimeout(() => {
      pageStream.write("callback");
    }, 1500);
  });
};

// init stream
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((() => {
  setupPageStream();
})());

let link = document.createElement("link");
link.rel = "stylesheet";
link.href = "./content-script.css"; // Adjust the path as necessary
document.head.appendChild(link);

(() => {
  let twitterButtonRow;
  const currentUser = {
    username: "",
    walletAddress: "",
  };

  chrome.runtime.onMessage.addListener((req, sender, res) => {
    const { type, username, walletAddress } = req;
    if (type === "NEW") {
      currentUser.username = username;
      currentUser.walletAddress = walletAddress;
      console.log("NEW event", currentUser);
      addTipModalToTwitterUI();

      const tipBtn = document.querySelector(".coqinu-tip-btn");
      if (!tipBtn) {
        addTipButtonToTwitterUI();
      }
    }
  });

  const addTipButtonToTwitterUI = () => {
    console.log("addTipButtonToTwitterUI");
    const tipBtn = createTipBtn();
    const btnContainer = locateTipBtnContainer();
    btnContainer.prepend(tipBtn);
  };

  const createTipBtn = () => {
    const tipBtn = document.createElement("button");
    tipBtn.className = "coqinu-tip-btn";
    tipBtn.innerText = "Tip Me";
    tipBtn.addEventListener("click", openTipModal);

    return tipBtn;
  };

  const openTipModal = () => {
    const modal = document.querySelector(".modal");
    modal.classList.add("open");
  };

  const addTipModalToTwitterUI = () => {
    const body = document.querySelector("body");
    const modal = createTipModal();
    console.log("modal:", modal);
    body.appendChild(modal);
  };

  const createTipModal = () => {
    const tipModal = document.createElement("div");
    tipModal.className = "modal";

    const closeBtn = createCloseBtn();
    tipModal.appendChild(closeBtn);

    const coqLogo = createCoqLogo();
    tipModal.appendChild(coqLogo);

    const form = createForm();
    tipModal.appendChild(form);
    return tipModal;
  };

  const createCoqLogo = () => {
    const container = document.createElement("div");
    container.className = "coqinu-logo-container";

    const coqLogo = document.createElement("img");
    coqLogo.className = "coqinu-logo";
    const logoUrl = chrome.runtime.getURL("assets/img/coqinu-logo.png");
    coqLogo.src = logoUrl;

    container.appendChild(coqLogo);

    return container;
  };

  const createForm = () => {
    const form = document.createElement("form");
    form.className = "tip-form";

    const tipInput = createTipInput();
    form.appendChild(tipInput);

    const sendTipBtn = createSendTipBtn();
    form.appendChild(sendTipBtn);

    form.addEventListener("submit", handleTipSubmit);

    return form;
  };

  const createTipInput = () => {
    const tipInput = document.createElement("input");
    tipInput.className = "tip-input";
    tipInput.placeholder = "Enter amount to tip in $COQ";

    return tipInput;
  };

  const createSendTipBtn = () => {
    const sendTipBtn = document.createElement("button");
    sendTipBtn.className = "send-tip-btn";
    sendTipBtn.innerText = "Send Tip";

    return sendTipBtn;
  };

  const createCloseBtn = () => {
    const closeBtn = document.createElement("button");
    closeBtn.className = "close-btn";

    // Create SVG element
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("height", "16");
    svg.setAttribute("width", "12");
    svg.setAttribute("viewBox", "0 0 384 512");

    // Create path element
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute(
      "d",
      "M376.6 84.5c11.3-13.6 9.5-33.8-4.1-45.1s-33.8-9.5-45.1 4.1L192 206 56.6 43.5C45.3 29.9 25.1 28.1 11.5 39.4S-3.9 70.9 7.4 84.5L150.3 256 7.4 427.5c-11.3 13.6-9.5 33.8 4.1 45.1s33.8 9.5 45.1-4.1L192 306 327.4 468.5c11.3 13.6 31.5 15.4 45.1 4.1s15.4-31.5 4.1-45.1L233.7 256 376.6 84.5z"
    );

    // Append path to SVG
    svg.appendChild(path);
    svg.style.fill = "#757575";

    // Append SVG to button
    closeBtn.appendChild(svg);

    closeBtn.addEventListener("click", () => {
      const tipInput = document.querySelector(".tip-input");
      tipInput.value = "";
      const tipBtn = document.querySelector(".send-tip-btn");
      tipBtn.innerText = "Send Tip";

      const modal = document.querySelector(".modal");
      modal.classList.remove("open");
    });
    closeBtn.style.zIndex = "100";

    return closeBtn;
  };

  const handleTipSubmit = async (e) => {
    e.preventDefault();
    // send message to background.js
    const tipAmount = e.target[0].value;
    await sendTip(currentUser.walletAddress, tipAmount);
  };

  const locateTipBtnContainer = () => {
    const userActionsBtn = document.querySelector("[data-testid='userActions']");
    const btnContainer = userActionsBtn.parentNode;

    return btnContainer;
  };

  const sendTip = async (walletAddress, tipAmount) => {
    console.log("calling sendTip:", walletAddress, tipAmount);
    const clientConfig = {
      chain: avalanche,
      transport: custom({
        async request({ method, params }) {
          console.log("method:", method);
          console.log("params:", params);
          try {
            const response = await provider.request({ method, params });
            return response;
          } catch (error) {
            console.error("Error in request:", error);
            throw error;
          }
        },
      }),
    };

    const client = createWalletClient(clientConfig);
    console.log("client:", client);

    const accounts = await client.requestAddresses();
    console.log("accounts:", accounts);

    const publicClient = createPublicClient({
      chain: avalanche,
      transport: http(),
    });
    console.log("publicClient:", publicClient);

    const approveHash = await approveToken(publicClient, client, accounts[0], tipAmount);

    const tipBtn = document.querySelector(".send-tip-btn");
    tipBtn.innerText = "Approving...";

    const transaction = await publicClient.waitForTransactionReceipt({ hash: approveHash });
    tipBtn.innerText = "Send Tip";
    console.log("transaction:", transaction);

    if (transaction.status === "reverted") {
      console.log("transaction reverted");
      return;
    }

    const transferHash = await transferToken(publicClient, client, accounts[0], walletAddress, tipAmount);
    tipBtn.innerText = "Sending Tip...";
    const transferTransaction = await publicClient.waitForTransactionReceipt({ hash: transferHash });
    console.log("transferTransaction:", transferTransaction);

    if (transferTransaction.status === "success") {
      tipBtn.innerText = "Success";
      displaySuccessMessage(transferTransaction.transactionHash);
      const payload = {
        from: accounts[0],
        to: walletAddress,
        amount: tipAmount,
        hash: transferHash,
        type: "TX_SUCCESS",
      };
      chrome.runtime.sendMessage(undefined, payload);
    }
  };
})();

async function approveToken(publicClient, client, account, amount) {
  try {
    const { request: approveRequest, result: approveResult } = await publicClient.simulateContract({
      address: COQ_ADDRESS,
      abi: coqAbi,
      functionName: "approve",
      args: [account, parseEther(amount)],
      account: account,
    });
    console.log("approveResult:", approveResult);

    // You might still want to send the transaction to the blockchain
    const approveHash = await client.writeContract(approveRequest);
    console.log("approveHash:", approveHash);

    // Return the result of the simulation
    return approveHash;
  } catch (error) {
    console.error("Error in approveToken function:", error);
    throw error;
  }
}

async function transferToken(publicClient, client, fromAccount, toAccount, amount) {
  try {
    const { request, result } = await publicClient.simulateContract({
      address: COQ_ADDRESS,
      abi: coqAbi,
      functionName: "transferFrom",
      args: [fromAccount, toAccount, parseEther(amount)],
      account: fromAccount,
    });
    console.log("result:", result);

    // Sending the transaction to the blockchain
    const hash = await client.writeContract(request);
    console.log("Transaction hash:", hash);

    // Return the result of the simulation
    return hash;
  } catch (error) {
    console.error("Error in transferToken function:", error);
    throw error;
  }
}

function displaySuccessMessage(hash) {
  const modal = document.querySelector(".modal");
  const form = document.querySelector(".tip-form");
  form.remove();

  const successMessage = document.createElement("p");
  successMessage.className = "success-message";
  successMessage.innerText = "Tip sent successfully! 🎉🐓";

  const snowtraceLink = document.createElement("a");
  snowtraceLink.className = "snowtrace-link";
  snowtraceLink.innerText = "Click to view on Snowtrace";
  snowtraceLink.href = `https://snowtrace.io/tx/${hash}`;
  snowtraceLink.target = "_blank";

  modal.appendChild(successMessage);
  modal.appendChild(snowtraceLink);
}

})();

/******/ })()
;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"_process":4,"buffer":2}]},{},[5]);
